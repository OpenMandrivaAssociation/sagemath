diff -up sage-5.10/spkg/build/sage-5.10/c_lib/include/ntl_wrap.h.orig sage-5.10/spkg/build/sage-5.10/c_lib/include/ntl_wrap.h
--- sage-5.10/spkg/build/sage-5.10/c_lib/include/ntl_wrap.h.orig	2013-07-29 19:40:07.189020485 -0300
+++ sage-5.10/spkg/build/sage-5.10/c_lib/include/ntl_wrap.h	2013-07-29 19:40:11.831020662 -0300
@@ -40,91 +40,92 @@ EXTERN void setup_NTL_error_callback(voi
 ////////  ZZ //////////
 
 #ifndef __cplusplus
-struct ZZ;
+typedef struct ZZ ZZ;
 #endif
 
-EXTERN int ZZ_to_int(const struct ZZ* x);
-EXTERN struct ZZ* int_to_ZZ(int value);
-EXTERN void ZZ_to_mpz(mpz_t* output, const struct ZZ* x);
-EXTERN void mpz_to_ZZ(struct ZZ *output, const mpz_t* x);
-EXTERN void ZZ_set_from_int(struct ZZ* x, int value);
+EXTERN int ZZ_to_int(const ZZ* x);
+EXTERN ZZ* int_to_ZZ(int value);
+EXTERN void ZZ_to_mpz(mpz_t* output, const ZZ* x);
+EXTERN void mpz_to_ZZ(ZZ *output, const mpz_t* x);
+EXTERN void ZZ_set_from_int(ZZ* x, int value);
 /*Random-number generation */
-//EXTERN void setSeed(const struct ZZ* n);
-//EXTERN struct ZZ* ZZ_randomBnd(const struct ZZ* x);
-//EXTERN struct ZZ* ZZ_randomBits(long n);
+//EXTERN void setSeed(const ZZ* n);
+//EXTERN ZZ* ZZ_randomBnd(const ZZ* x);
+//EXTERN ZZ* ZZ_randomBits(long n);
 
 #ifdef __cplusplus
-EXTERN long ZZ_remove(struct ZZ& x, const struct ZZ& a, const struct ZZ& p);
+EXTERN long ZZ_remove(ZZ& x, const ZZ& a, const ZZ& p);
 #endif
 
 ////////  ZZ_p //////////
 
 #ifndef __cplusplus
-struct ZZ_p;
+typedef struct ZZ_p ZZ_p;
+typedef struct ZZ_pContext ZZ_pContext;
 #endif
 
 #ifdef __cplusplus  // sorry, if you want a C version, feel free to add it
 EXTERN int ZZ_p_to_int(const ZZ_p& x);
 EXTERN ZZ_p int_to_ZZ_p(int value);
 #endif
-EXTERN void ZZ_p_set_from_int(struct ZZ_p* x, int value);
-EXTERN struct ZZ_p* ZZ_p_pow(const struct ZZ_p* x, long e);
-EXTERN void ntl_ZZ_set_modulus(struct ZZ* x);
-EXTERN struct ZZ_p* ZZ_p_inv(struct ZZ_p* x);
-EXTERN struct ZZ_p* ZZ_p_neg(struct ZZ_p* x);
-EXTERN struct ZZ_p* ZZ_p_random(void);
-EXTERN void ZZ_p_modulus(struct ZZ* mod, const struct ZZ_p* x);
+EXTERN void ZZ_p_set_from_int(ZZ_p* x, int value);
+EXTERN ZZ_p* ZZ_p_pow(const ZZ_p* x, long e);
+EXTERN void ntl_ZZ_set_modulus(ZZ* x);
+EXTERN ZZ_p* ZZ_p_inv(ZZ_p* x);
+EXTERN ZZ_p* ZZ_p_neg(ZZ_p* x);
+EXTERN ZZ_p* ZZ_p_random(void);
+EXTERN void ZZ_p_modulus(ZZ* mod, const ZZ_p* x);
 
 
-EXTERN struct ZZ_pContext* ZZ_pContext_new(struct ZZ* p);
-EXTERN struct ZZ_pContext* ZZ_pContext_construct(void* mem, struct ZZ* p);
+EXTERN ZZ_pContext* ZZ_pContext_new(ZZ* p);
+EXTERN ZZ_pContext* ZZ_pContext_construct(void* mem, ZZ* p);
 
 //////// ZZX //////////
 #ifndef __cplusplus
-struct ZZX;
+typedef struct ZZX ZZX;
 #endif
 
-EXTERN char* ZZX_repr(struct ZZX* x);
-EXTERN struct ZZX* ZZX_copy(struct ZZX* x);
-EXTERN void ZZX_setitem_from_int(struct ZZX* x, long i, int value);
-EXTERN int ZZX_getitem_as_int(struct ZZX* x, long i);
-EXTERN void ZZX_getitem_as_mpz(mpz_t* output, struct ZZX* x, long i);
-EXTERN struct ZZX* ZZX_div(struct ZZX* x, struct ZZX* y, int* divisible);
-EXTERN void ZZX_quo_rem(struct ZZX* x, struct ZZX* other, struct ZZX** r, struct ZZX** q);
-EXTERN struct ZZX* ZZX_square(struct ZZX* x);
-EXTERN int ZZX_equal(struct ZZX* x, struct ZZX* y);
-EXTERN int ZZX_is_monic(struct ZZX* x);
-EXTERN struct ZZX* ZZX_neg(struct ZZX* x);
-EXTERN struct ZZX* ZZX_left_shift(struct ZZX* x, long n);
-EXTERN struct ZZX* ZZX_right_shift(struct ZZX* x, long n);
-EXTERN char* ZZX_content(struct ZZX* x);
-EXTERN struct ZZX* ZZX_primitive_part(struct ZZX* x);
-EXTERN void ZZX_pseudo_quo_rem(struct ZZX* x, struct ZZX* y, struct ZZX** r, struct ZZX** q);
-EXTERN struct ZZX* ZZX_gcd(struct ZZX* x, struct ZZX* y);
-EXTERN void ZZX_xgcd(struct ZZX* x, struct ZZX* y, struct ZZ** r, struct ZZX** s, struct ZZX** t, int proof);
-EXTERN long ZZX_degree(struct ZZX* x);
-EXTERN struct ZZ* ZZX_leading_coefficient(struct ZZX* x);
-EXTERN char* ZZX_constant_term(struct ZZX* x);
-EXTERN void ZZX_set_x(struct ZZX* x);
-EXTERN int ZZX_is_x(struct ZZX* x);
-EXTERN struct ZZX* ZZX_derivative(struct ZZX* x);
-EXTERN struct ZZX* ZZX_reverse(struct ZZX* x);
-EXTERN struct ZZX* ZZX_reverse_hi(struct ZZX* x, int hi);
-EXTERN struct ZZX* ZZX_truncate(struct ZZX* x, long m);
-EXTERN struct ZZX* ZZX_multiply_and_truncate(struct ZZX* x, struct ZZX* y, long m);
-EXTERN struct ZZX* ZZX_square_and_truncate(struct ZZX* x, long m);
-EXTERN struct ZZX* ZZX_invert_and_truncate(struct ZZX* x, long m);
-EXTERN struct ZZX* ZZX_multiply_mod(struct ZZX* x, struct ZZX* y,  struct ZZX* modulus);
-EXTERN struct ZZ* ZZX_trace_mod(struct ZZX* x, struct ZZX* y);
-/* EXTERN struct ZZ* ZZX_polyeval(struct ZZX* f, struct ZZ* a); */
-EXTERN char* ZZX_trace_list(struct ZZX* x);
-EXTERN struct ZZ* ZZX_resultant(struct ZZX* x, struct ZZX* y, int proof);
-EXTERN struct ZZ* ZZX_norm_mod(struct ZZX* x, struct ZZX* y, int proof);
-EXTERN struct ZZ* ZZX_discriminant(struct ZZX* x, int proof);
-EXTERN struct ZZX* ZZX_charpoly_mod(struct ZZX* x, struct ZZX* y, int proof);
-EXTERN struct ZZX* ZZX_minpoly_mod(struct ZZX* x, struct ZZX* y);
-EXTERN void ZZX_clear(struct ZZX* x);
-EXTERN void ZZX_preallocate_space(struct ZZX* x, long n);
+EXTERN char* ZZX_repr(ZZX* x);
+EXTERN ZZX* ZZX_copy(ZZX* x);
+EXTERN void ZZX_setitem_from_int(ZZX* x, long i, int value);
+EXTERN int ZZX_getitem_as_int(ZZX* x, long i);
+EXTERN void ZZX_getitem_as_mpz(mpz_t* output, ZZX* x, long i);
+EXTERN ZZX* ZZX_div(ZZX* x, ZZX* y, int* divisible);
+EXTERN void ZZX_quo_rem(ZZX* x, ZZX* other, ZZX** r, ZZX** q);
+EXTERN ZZX* ZZX_square(ZZX* x);
+EXTERN int ZZX_equal(ZZX* x, ZZX* y);
+EXTERN int ZZX_is_monic(ZZX* x);
+EXTERN ZZX* ZZX_neg(ZZX* x);
+EXTERN ZZX* ZZX_left_shift(ZZX* x, long n);
+EXTERN ZZX* ZZX_right_shift(ZZX* x, long n);
+EXTERN char* ZZX_content(ZZX* x);
+EXTERN ZZX* ZZX_primitive_part(ZZX* x);
+EXTERN void ZZX_pseudo_quo_rem(ZZX* x, ZZX* y, ZZX** r, ZZX** q);
+EXTERN ZZX* ZZX_gcd(ZZX* x, ZZX* y);
+EXTERN void ZZX_xgcd(ZZX* x, ZZX* y, ZZ** r, ZZX** s, ZZX** t, int proof);
+EXTERN long ZZX_degree(ZZX* x);
+EXTERN ZZ* ZZX_leading_coefficient(ZZX* x);
+EXTERN char* ZZX_constant_term(ZZX* x);
+EXTERN void ZZX_set_x(ZZX* x);
+EXTERN int ZZX_is_x(ZZX* x);
+EXTERN ZZX* ZZX_derivative(ZZX* x);
+EXTERN ZZX* ZZX_reverse(ZZX* x);
+EXTERN ZZX* ZZX_reverse_hi(ZZX* x, int hi);
+EXTERN ZZX* ZZX_truncate(ZZX* x, long m);
+EXTERN ZZX* ZZX_multiply_and_truncate(ZZX* x, ZZX* y, long m);
+EXTERN ZZX* ZZX_square_and_truncate(ZZX* x, long m);
+EXTERN ZZX* ZZX_invert_and_truncate(ZZX* x, long m);
+EXTERN ZZX* ZZX_multiply_mod(ZZX* x, ZZX* y,  ZZX* modulus);
+EXTERN ZZ* ZZX_trace_mod(ZZX* x, ZZX* y);
+/* EXTERN ZZ* ZZX_polyeval(ZZX* f, ZZ* a); */
+EXTERN char* ZZX_trace_list(ZZX* x);
+EXTERN ZZ* ZZX_resultant(ZZX* x, ZZX* y, int proof);
+EXTERN ZZ* ZZX_norm_mod(ZZX* x, ZZX* y, int proof);
+EXTERN ZZ* ZZX_discriminant(ZZX* x, int proof);
+EXTERN ZZX* ZZX_charpoly_mod(ZZX* x, ZZX* y, int proof);
+EXTERN ZZX* ZZX_minpoly_mod(ZZX* x, ZZX* y);
+EXTERN void ZZX_clear(ZZX* x);
+EXTERN void ZZX_preallocate_space(ZZX* x, long n);
 
 //////// ZZXFactoring //////////
 
@@ -132,76 +133,77 @@ EXTERN void ZZX_preallocate_space(struct
 //         e -- point to list of e longs (the exponents)
 //         n -- length of above two lists
 //  The lists v and e are mallocd, and must be freed by the calling code.
-EXTERN void ZZX_squarefree_decomposition(struct ZZX*** v, long** e, long* n, struct ZZX* x);
+EXTERN void ZZX_squarefree_decomposition(ZZX*** v, long** e, long* n, ZZX* x);
 
 
 //////// ZZ_pX //////////
 #ifndef __cplusplus
-struct ZZ_pX;
+typedef struct ZZ_pX ZZ_pX;
 #endif
 
-EXTERN struct ZZ_pX* ZZ_pX_init();
-//EXTERN char* ZZ_pX_repr(struct ZZ_pX* x);
-/* EXTERN struct ZZ_pX* ZZ_pX_copy(struct ZZ_pX* x); */
-/* EXTERN void ZZ_pX_setitem_from_int(struct ZZ_pX* x, long i, int value); */
-/* EXTERN int ZZ_pX_getitem_as_int(struct ZZ_pX* x, long i); */
-/* EXTERN struct ZZ_pX* ZZ_pX_div(struct ZZ_pX* x, struct ZZ_pX* y, int* divisible); */
-/* EXTERN struct ZZ_pX* ZZ_pX_mod(struct ZZ_pX* x, struct ZZ_pX* y); */
-/* EXTERN void ZZ_pX_quo_rem(struct ZZ_pX* x, struct ZZ_pX* other, struct ZZ_pX** r, struct ZZ_pX** q); */
-/* EXTERN struct ZZ_pX* ZZ_pX_square(struct ZZ_pX* x); */
-/* EXTERN int ZZ_pX_equal(struct ZZ_pX* x, struct ZZ_pX* y); */
-/* EXTERN int ZZ_pX_is_monic(struct ZZ_pX* x); */
-/* EXTERN struct ZZ_pX* ZZ_pX_neg(struct ZZ_pX* x); */
-/* EXTERN struct ZZ_pX* ZZ_pX_left_shift(struct ZZ_pX* x, long n); */
-/* EXTERN struct ZZ_pX* ZZ_pX_right_shift(struct ZZ_pX* x, long n); */
-/* EXTERN void ZZ_pX_quo_rem(struct ZZ_pX* x, struct ZZ_pX* y, struct ZZ_pX** r, struct ZZ_pX** q); */
-/* EXTERN struct ZZ_pX* ZZ_pX_gcd(struct ZZ_pX* x, struct ZZ_pX* y); */
-/* EXTERN void ZZ_pX_xgcd(struct ZZ_pX** d, struct ZZ_pX** s, struct ZZ_pX** t, struct ZZ_pX* a, struct ZZ_pX* b); */
-/* EXTERN void ZZ_pX_plain_xgcd(struct ZZ_pX** d, struct ZZ_pX** s, struct ZZ_pX** t, struct ZZ_pX* a, struct ZZ_pX* b); */
-/* EXTERN long ZZ_pX_degree(struct ZZ_pX* x); */
-/* EXTERN void ZZ_pX_set_x(struct ZZ_pX* x); */
-/* EXTERN int ZZ_pX_is_x(struct ZZ_pX* x); */
-/* EXTERN struct ZZ_pX* ZZ_pX_derivative(struct ZZ_pX* x); */
-/* EXTERN struct ZZ_pX* ZZ_pX_reverse(struct ZZ_pX* x); */
-/* EXTERN struct ZZ_pX* ZZ_pX_reverse_hi(struct ZZ_pX* x, int hi); */
-/* EXTERN struct ZZ_pX* ZZ_pX_truncate(struct ZZ_pX* x, long m); */
-/* EXTERN struct ZZ_pX* ZZ_pX_multiply_and_truncate(struct ZZ_pX* x, struct ZZ_pX* y, long m); */
-/* EXTERN struct ZZ_pX* ZZ_pX_square_and_truncate(struct ZZ_pX* x, long m); */
-/* EXTERN struct ZZ_pX* ZZ_pX_invert_and_truncate(struct ZZ_pX* x, long m); */
-/* EXTERN struct ZZ_pX* ZZ_pX_multiply_mod(struct ZZ_pX* x, struct ZZ_pX* y,  struct ZZ_pX* modulus); */
-/* EXTERN struct ZZ_p* ZZ_pX_trace_mod(struct ZZ_pX* x, struct ZZ_pX* y); */
-EXTERN char* ZZ_pX_trace_list(struct ZZ_pX* x);
-/* EXTERN struct ZZ_p* ZZ_pX_resultant(struct ZZ_pX* x, struct ZZ_pX* y); */
-/* EXTERN struct ZZ_p* ZZ_pX_norm_mod(struct ZZ_pX* x, struct ZZ_pX* y); */
-/* EXTERN struct ZZ_pX* ZZ_pX_charpoly_mod(struct ZZ_pX* x, struct ZZ_pX* y); */
-/* EXTERN struct ZZ_pX* ZZ_pX_minpoly_mod(struct ZZ_pX* x, struct ZZ_pX* y); */
-/* EXTERN void ZZ_pX_clear(struct ZZ_pX* x); */
-// EXTERN void ZZ_pX_preallocate_space(struct ZZ_pX* x, long n);
+EXTERN ZZ_pX* ZZ_pX_init();
+//EXTERN char* ZZ_pX_repr(ZZ_pX* x);
+/* EXTERN ZZ_pX* ZZ_pX_copy(ZZ_pX* x); */
+/* EXTERN void ZZ_pX_setitem_from_int(ZZ_pX* x, long i, int value); */
+/* EXTERN int ZZ_pX_getitem_as_int(ZZ_pX* x, long i); */
+/* EXTERN ZZ_pX* ZZ_pX_div(ZZ_pX* x, ZZ_pX* y, int* divisible); */
+/* EXTERN ZZ_pX* ZZ_pX_mod(ZZ_pX* x, ZZ_pX* y); */
+/* EXTERN void ZZ_pX_quo_rem(ZZ_pX* x, ZZ_pX* other, ZZ_pX** r, ZZ_pX** q); */
+/* EXTERN ZZ_pX* ZZ_pX_square(ZZ_pX* x); */
+/* EXTERN int ZZ_pX_equal(ZZ_pX* x, ZZ_pX* y); */
+/* EXTERN int ZZ_pX_is_monic(ZZ_pX* x); */
+/* EXTERN ZZ_pX* ZZ_pX_neg(ZZ_pX* x); */
+/* EXTERN ZZ_pX* ZZ_pX_left_shift(ZZ_pX* x, long n); */
+/* EXTERN ZZ_pX* ZZ_pX_right_shift(ZZ_pX* x, long n); */
+/* EXTERN void ZZ_pX_quo_rem(ZZ_pX* x, ZZ_pX* y, ZZ_pX** r, ZZ_pX** q); */
+/* EXTERN ZZ_pX* ZZ_pX_gcd(ZZ_pX* x, ZZ_pX* y); */
+/* EXTERN void ZZ_pX_xgcd(ZZ_pX** d, ZZ_pX** s, ZZ_pX** t, ZZ_pX* a, ZZ_pX* b); */
+/* EXTERN void ZZ_pX_plain_xgcd(ZZ_pX** d, ZZ_pX** s, ZZ_pX** t, ZZ_pX* a, ZZ_pX* b); */
+/* EXTERN long ZZ_pX_degree(ZZ_pX* x); */
+/* EXTERN void ZZ_pX_set_x(ZZ_pX* x); */
+/* EXTERN int ZZ_pX_is_x(ZZ_pX* x); */
+/* EXTERN ZZ_pX* ZZ_pX_derivative(ZZ_pX* x); */
+/* EXTERN ZZ_pX* ZZ_pX_reverse(ZZ_pX* x); */
+/* EXTERN ZZ_pX* ZZ_pX_reverse_hi(ZZ_pX* x, int hi); */
+/* EXTERN ZZ_pX* ZZ_pX_truncate(ZZ_pX* x, long m); */
+/* EXTERN ZZ_pX* ZZ_pX_multiply_and_truncate(ZZ_pX* x, ZZ_pX* y, long m); */
+/* EXTERN ZZ_pX* ZZ_pX_square_and_truncate(ZZ_pX* x, long m); */
+/* EXTERN ZZ_pX* ZZ_pX_invert_and_truncate(ZZ_pX* x, long m); */
+/* EXTERN ZZ_pX* ZZ_pX_multiply_mod(ZZ_pX* x, ZZ_pX* y,  ZZ_pX* modulus); */
+/* EXTERN ZZ_p* ZZ_pX_trace_mod(ZZ_pX* x, ZZ_pX* y); */
+EXTERN char* ZZ_pX_trace_list(ZZ_pX* x);
+/* EXTERN ZZ_p* ZZ_pX_resultant(ZZ_pX* x, ZZ_pX* y); */
+/* EXTERN ZZ_p* ZZ_pX_norm_mod(ZZ_pX* x, ZZ_pX* y); */
+/* EXTERN ZZ_pX* ZZ_pX_charpoly_mod(ZZ_pX* x, ZZ_pX* y); */
+/* EXTERN ZZ_pX* ZZ_pX_minpoly_mod(ZZ_pX* x, ZZ_pX* y); */
+/* EXTERN void ZZ_pX_clear(ZZ_pX* x); */
+// EXTERN void ZZ_pX_preallocate_space(ZZ_pX* x, long n);
 
 // Factoring elements of ZZ_pX:
 // OUTPUT: v -- pointer to list of n ZZ_pX elements (the irred factors)
 //         e -- point to list of e longs (the exponents)
 //         n -- length of above two lists
 //  The lists v and e are mallocd, and must be freed by the calling code.
-EXTERN void ZZ_pX_factor(struct ZZ_pX*** v, long** e, long* n, struct ZZ_pX* x, long verbose);
-EXTERN void ZZ_pX_linear_roots(struct ZZ_p*** v, long* n, struct ZZ_pX* f);
+EXTERN void ZZ_pX_factor(ZZ_pX*** v, long** e, long* n, ZZ_pX* x, long verbose);
+EXTERN void ZZ_pX_linear_roots(ZZ_p*** v, long* n, ZZ_pX* f);
 
 #ifdef __cplusplus
-EXTERN void ZZ_pX_conv_modulus(struct ZZ_pX &fout, const struct ZZ_pX &fin, const struct ZZ_pContext &mod);
-EXTERN void ZZ_pEX_conv_modulus(struct ZZ_pEX &fout, const struct ZZ_pEX &fin, const struct ZZ_pContext &mod);
-EXTERN void ZZ_pX_min_val_coeff(long &valuation, long &index, const struct ZZ_pX &f, const struct ZZ &p);
-EXTERN long ZZ_pX_get_val_coeff(const struct ZZ_pX &f, const struct ZZ &p, long i);
-EXTERN void ZZ_pX_left_pshift(struct ZZ_pX &x, const struct ZZ_pX &a, const struct ZZ &pn, const struct ZZ_pContext &c);
-EXTERN void ZZ_pX_right_pshift(struct ZZ_pX &x, const struct ZZ_pX &a, const struct ZZ &pn, const struct ZZ_pContext &c);
-EXTERN void ZZ_pX_InvMod_newton_unram(struct ZZ_pX &x, const struct ZZ_pX &a, const struct ZZ_pXModulus &F, const struct ZZ_pContext &cpn, const struct ZZ_pContext &cp);
-EXTERN void ZZ_pX_InvMod_newton_ram(struct ZZ_pX &x, const struct ZZ_pX &a, const struct ZZ_pXModulus &F, const struct ZZ_pContext &cpn);
+EXTERN void ZZ_pX_conv_modulus(ZZ_pX &fout, const ZZ_pX &fin, const ZZ_pContext &mod);
+EXTERN void ZZ_pEX_conv_modulus(ZZ_pEX &fout, const ZZ_pEX &fin, const ZZ_pContext &mod);
+EXTERN void ZZ_pX_min_val_coeff(long &valuation, long &index, const ZZ_pX &f, const ZZ &p);
+EXTERN long ZZ_pX_get_val_coeff(const ZZ_pX &f, const ZZ &p, long i);
+EXTERN void ZZ_pX_left_pshift(ZZ_pX &x, const ZZ_pX &a, const ZZ &pn, const ZZ_pContext &c);
+EXTERN void ZZ_pX_right_pshift(ZZ_pX &x, const ZZ_pX &a, const ZZ &pn, const ZZ_pContext &c);
+EXTERN void ZZ_pX_InvMod_newton_unram(ZZ_pX &x, const ZZ_pX &a, const ZZ_pXModulus &F, const ZZ_pContext &cpn, const ZZ_pContext &cp);
+EXTERN void ZZ_pX_InvMod_newton_ram(ZZ_pX &x, const ZZ_pX &a, const ZZ_pXModulus &F, const ZZ_pContext &cpn);
 
 #endif
 
 //////// zz_p //////////
 
 #ifndef __cplusplus
-struct zz_p;
+typedef struct zz_p zz_p;
+typedef struct zz_pContext zz_pContext;
 #endif
 
 #define zz_p_set_from_long( obj1, obj2 )\
@@ -209,14 +211,14 @@ struct zz_p;
 #define NTL_zz_p_DOUBLE_EQUALS( obj1, obj2 )\
         (obj1) == (obj2)
 
-EXTERN struct zz_pContext* zz_pContext_new(long p);
-EXTERN struct zz_pContext* zz_pContext_construct(void* mem, long p);
-EXTERN void zz_pContext_restore(struct zz_pContext* ctx);
+EXTERN zz_pContext* zz_pContext_new(long p);
+EXTERN zz_pContext* zz_pContext_construct(void* mem, long p);
+EXTERN void zz_pContext_restore(zz_pContext* ctx);
 
 //////// zz_pX //////////
 
 #ifndef __cplusplus
-struct zz_pX; 
+typedef struct zz_pX zz_pX;
 #endif 
 
 #define NTL_zz_pX_DOUBLE_EQUALS( obj1, obj2 )\
@@ -225,104 +227,106 @@ struct zz_pX;
 //////// ZZ_pEContext ///////////////
 
 #ifndef __cplusplus
-struct ZZ_pEContext;
+typedef struct ZZ_pEContext ZZ_pEContext;
 #endif
 
-EXTERN struct ZZ_pEContext* ZZ_pEContext_new(struct ZZ_pX *f);
-EXTERN struct ZZ_pEContext* ZZ_pEContext_construct(void* mem, struct ZZ_pX *f);
-EXTERN void ZZ_pEContext_restore(struct ZZ_pEContext* ctx);
+EXTERN ZZ_pEContext* ZZ_pEContext_new(ZZ_pX *f);
+EXTERN ZZ_pEContext* ZZ_pEContext_construct(void* mem, ZZ_pX *f);
+EXTERN void ZZ_pEContext_restore(ZZ_pEContext* ctx);
 
 //////// ZZ_pE ////////////
 
 #ifndef __cplusplus
-struct ZZ_pE;
+typedef struct ZZ_pE ZZ_pE;
 #endif
 
-EXTERN struct ZZ_pX ZZ_pE_to_ZZ_pX(struct ZZ_pE x);
+EXTERN ZZ_pX ZZ_pE_to_ZZ_pX(ZZ_pE x);
 
 //////// ZZ_pEX /////////
 
 #ifndef __cplusplus
-struct ZZ_pEX;
+typedef struct ZZ_pEX ZZ_pEX;
 #endif
 
 //////// mat_ZZ //////////
 
 #ifndef __cplusplus
-struct mat_ZZ;
+typedef struct mat_ZZ mat_ZZ;
 #endif
 
-EXTERN void mat_ZZ_SetDims(struct mat_ZZ* mZZ, long nrows, long ncols);
-EXTERN struct mat_ZZ* mat_ZZ_pow(const struct mat_ZZ* x, long e);
-EXTERN long mat_ZZ_nrows(const struct mat_ZZ* x);
-EXTERN long mat_ZZ_ncols(const struct mat_ZZ* x);
-EXTERN void mat_ZZ_setitem(struct mat_ZZ* x, int i, int j, const struct ZZ* z);
-EXTERN struct ZZ* mat_ZZ_getitem(const struct mat_ZZ* x, int i, int j);
-EXTERN struct ZZ* mat_ZZ_determinant(const struct mat_ZZ* x, long deterministic);
-EXTERN struct mat_ZZ* mat_ZZ_HNF(const struct mat_ZZ* A, const struct ZZ* D);
-EXTERN struct ZZX* mat_ZZ_charpoly(const struct mat_ZZ* A);
-EXTERN long mat_ZZ_LLL(struct ZZ **det, struct mat_ZZ *x, long a, long b, long verbose);
-EXTERN long mat_ZZ_LLL_U(struct ZZ **det, struct mat_ZZ *x, struct mat_ZZ *U, long a, long b, long verbose);
+EXTERN void mat_ZZ_SetDims(mat_ZZ* mZZ, long nrows, long ncols);
+EXTERN mat_ZZ* mat_ZZ_pow(const mat_ZZ* x, long e);
+EXTERN long mat_ZZ_nrows(const mat_ZZ* x);
+EXTERN long mat_ZZ_ncols(const mat_ZZ* x);
+EXTERN void mat_ZZ_setitem(mat_ZZ* x, int i, int j, const ZZ* z);
+EXTERN ZZ* mat_ZZ_getitem(const mat_ZZ* x, int i, int j);
+EXTERN ZZ* mat_ZZ_determinant(const mat_ZZ* x, long deterministic);
+EXTERN mat_ZZ* mat_ZZ_HNF(const mat_ZZ* A, const ZZ* D);
+EXTERN ZZX* mat_ZZ_charpoly(const mat_ZZ* A);
+EXTERN long mat_ZZ_LLL(ZZ **det, mat_ZZ *x, long a, long b, long verbose);
+EXTERN long mat_ZZ_LLL_U(ZZ **det, mat_ZZ *x, mat_ZZ *U, long a, long b, long verbose);
 
 /* //////// ZZ_p ////////// */
 /* #ifndef __cplusplus */
-/* struct ZZ_p; */
+/* typedef struct ZZ_p ZZ_p; */
 /* #endif */
 
-/* EXTERN void ZZ_p_set_modulus(const struct ZZ* p); */
-/* EXTERN struct ZZ_p* new_ZZ_p(void); */
-/* EXTERN void del_ZZ_p(struct ZZ_p* x); */
-/* EXTERN struct ZZ_p* ZZ_p_add(const struct ZZ_p* x, const struct ZZ_p* y); */
-/* EXTERN struct ZZ_p* ZZ_p_sub(const struct ZZ_p* x, const struct ZZ_p* y); */
-/* EXTERN struct ZZ_p* ZZ_p_mul(const struct ZZ_p* x, const struct ZZ_p* y); */
-/* EXTERN struct ZZ_p* ZZ_p_pow(const struct ZZ_p* x, long e); */
-/* EXTERN int ZZ_p_is_zero(struct ZZ_p*x ); */
-/* EXTERN int ZZ_p_is_one(struct ZZ_p*x ); */
+/* EXTERN void ZZ_p_set_modulus(const ZZ* p); */
+/* EXTERN ZZ_p* new_ZZ_p(void); */
+/* EXTERN void del_ZZ_p(ZZ_p* x); */
+/* EXTERN ZZ_p* ZZ_p_add(const ZZ_p* x, const ZZ_p* y); */
+/* EXTERN ZZ_p* ZZ_p_sub(const ZZ_p* x, const ZZ_p* y); */
+/* EXTERN ZZ_p* ZZ_p_mul(const ZZ_p* x, const ZZ_p* y); */
+/* EXTERN ZZ_p* ZZ_p_pow(const ZZ_p* x, long e); */
+/* EXTERN int ZZ_p_is_zero(ZZ_p*x ); */
+/* EXTERN int ZZ_p_is_one(ZZ_p*x ); */
 
 
 //////// ZZ_pE //////////
 #ifndef __cplusplus
-struct ZZ_pE;
+typedef struct ZZ_pE ZZ_pE;
 #endif
 
-// EXTERN struct ZZ_pE* new_ZZ_pE
+// EXTERN ZZ_pE* new_ZZ_pE
 
 
 
 //////// ZZ_pEX //////////
 
 //#ifndef __cplusplus
-//struct ZZ_pEX;
+//typedef struct ZZ_pEX ZZ_pEX;
 //#endif
 
-//EXTERN struct ZZ_pEX* new_ZZ_pEX
+//EXTERN ZZ_pEX* new_ZZ_pEX
 
 /////// GF2X ////////////////
 #ifndef __cplusplus
-struct GF2X;
+typedef struct GF2X GF2X;
 #endif
 
 /////// GF2EContext ////////////////
 
 #ifndef __cplusplus
-struct GF2EContext;
+typedef struct GF2E GF2E;
+typedef struct GF2EContext GF2EContext;
 #endif
 
-EXTERN struct GF2EContext* GF2EContext_new(struct GF2X_c* p);
-EXTERN struct GF2EContext* GF2EContext_construct(void *mem, const struct GF2X *p);
+EXTERN GF2EContext* GF2EContext_new(GF2X* p);
+EXTERN GF2EContext* GF2EContext_construct(void *mem, const GF2X *p);
 
 //////// mat_GF2E //////////
 
 #ifndef __cplusplus
-struct mat_GF2E;
+typedef struct mat_GF2E mat_GF2E;
 #endif
 
-EXTERN void mat_GF2E_setitem(struct mat_GF2E* x, int i, int j, const struct GF2E* z);
+EXTERN void mat_GF2E_setitem(mat_GF2E* x, int i, int j, const GF2E* z);
 
 //////// mat_GF2 //////////
 
 #ifndef __cplusplus
-struct mat_GF2;
+typedef struct GF2 GF2;
+typedef struct mat_GF2 mat_GF2;
 #endif
 
-EXTERN void mat_GF2_setitem(struct mat_GF2* x, int i, int j, const struct GF2* z);
+EXTERN void mat_GF2_setitem(mat_GF2* x, int i, int j, const GF2* z);
diff -up sage-5.10/spkg/build/sage-5.10/c_lib/src/ntl_wrap.cpp.orig sage-5.10/spkg/build/sage-5.10/c_lib/src/ntl_wrap.cpp
--- sage-5.10/spkg/build/sage-5.10/c_lib/src/ntl_wrap.cpp.orig	2013-07-29 19:40:07.197020485 -0300
+++ sage-5.10/spkg/build/sage-5.10/c_lib/src/ntl_wrap.cpp	2013-07-29 19:40:11.834020662 -0300
@@ -29,7 +29,7 @@ int ZZ_to_int(const ZZ* x)
 
 /* Returns a *new* ZZ object.
    AUTHOR: David Harvey (2008-06-08) */
-struct ZZ* int_to_ZZ(int value)
+ZZ* int_to_ZZ(int value)
 {
     ZZ* output = new ZZ();
     conv(*output, value);
@@ -40,7 +40,7 @@ struct ZZ* int_to_ZZ(int value)
    Assumes output has been mpz_init'd.
    AUTHOR: David Harvey
            Joel B. Mohler moved the ZZX_getitem_as_mpz code out to this function (2007-03-13) */
-void ZZ_to_mpz(mpz_t* output, const struct ZZ* x)
+void ZZ_to_mpz(mpz_t* output, const ZZ* x)
 {
     unsigned char stack_bytes[4096];
     int use_heap;
@@ -62,7 +62,7 @@ void ZZ_to_mpz(mpz_t* output, const stru
 /* Copies the mpz_t into the ZZ
    AUTHOR: Joel B. Mohler (2007-03-15) */
 // This should be changed to an mpz_t not an mpz_t*
-void mpz_to_ZZ(struct ZZ* output, const mpz_t *x)
+void mpz_to_ZZ(ZZ* output, const mpz_t *x)
 {
     unsigned char stack_bytes[4096];
     int use_heap;
@@ -86,7 +86,7 @@ void ZZ_set_from_int(ZZ* x, int value)
     conv(*x, value);
 }
 
-long ZZ_remove(struct ZZ &dest, const struct ZZ &src, const struct ZZ &f)
+long ZZ_remove(ZZ &dest, const ZZ &src, const ZZ &f)
 {
     // Based on the code for mpz_remove
     ZZ fpow[40];            // inexaustible...until year 2020 or so
@@ -172,12 +172,12 @@ void ZZ_p_set_from_int(ZZ_p* x, int valu
     conv(*x, value);
 }
 
-void ZZ_p_modulus(struct ZZ* mod, const struct ZZ_p* x)
+void ZZ_p_modulus(ZZ* mod, const ZZ_p* x)
 {
     (*mod) = x->modulus();
 }
 
-struct ZZ_p* ZZ_p_pow(const struct ZZ_p* x, long e) 
+ZZ_p* ZZ_p_pow(const ZZ_p* x, long e) 
 {
     ZZ_p *z = new ZZ_p();
     power(*z, *x, e);
@@ -203,7 +203,7 @@ ZZ_p* ZZ_p_random(void)
     return z;
 }
 
-struct ZZ_p* ZZ_p_neg(struct ZZ_p* x)
+ZZ_p* ZZ_p_neg(ZZ_p* x)
 {
     return new ZZ_p(-(*x));
 }
@@ -214,7 +214,7 @@ struct ZZ_p* ZZ_p_neg(struct ZZ_p* x)
 //////// ZZX //////////
 ///////////////////////////////////////////////
 
-char* ZZX_repr(struct ZZX* x)
+char* ZZX_repr(ZZX* x)
 {
     ostringstream instore;
     instore << (*x);
@@ -224,13 +224,13 @@ char* ZZX_repr(struct ZZX* x)
     return buf;
 }
 
-struct ZZX* ZZX_copy(struct ZZX* x) {
+ZZX* ZZX_copy(ZZX* x) {
     return new ZZX(*x);
 }
 
 /* Sets ith coefficient of x to value.
    AUTHOR: David Harvey (2006-06-08) */
-void ZZX_setitem_from_int(struct ZZX* x, long i, int value)
+void ZZX_setitem_from_int(ZZX* x, long i, int value)
 {
     SetCoeff(*x, i, value);
 }
@@ -238,7 +238,7 @@ void ZZX_setitem_from_int(struct ZZX* x,
 /* Returns ith coefficient of x.
    Return value is only valid if the result should fit into an int.
    AUTHOR: David Harvey (2006-06-08) */
-int ZZX_getitem_as_int(struct ZZX* x, long i)
+int ZZX_getitem_as_int(ZZX* x, long i)
 {
     return ZZ_to_int(&coeff(*x, i));
 }
@@ -246,75 +246,75 @@ int ZZX_getitem_as_int(struct ZZX* x, lo
 /* Copies ith coefficient of x to output.
    Assumes output has been mpz_init'd.
    AUTHOR: David Harvey (2007-02) */
-void ZZX_getitem_as_mpz(mpz_t* output, struct ZZX* x, long i)
+void ZZX_getitem_as_mpz(mpz_t* output, ZZX* x, long i)
 {
     const ZZ& z = coeff(*x, i);
     ZZ_to_mpz(output, &z);
 }
 
-struct ZZX* ZZX_div(struct ZZX* x, struct ZZX* y, int* divisible)
+ZZX* ZZX_div(ZZX* x, ZZX* y, int* divisible)
 {
-    struct ZZX* z = new ZZX();
+    ZZX* z = new ZZX();
     *divisible = divide(*z, *x, *y);
     return z;
 }
 
 
 
-void ZZX_quo_rem(struct ZZX* x, struct ZZX* other, struct ZZX** r, struct ZZX** q)
+void ZZX_quo_rem(ZZX* x, ZZX* other, ZZX** r, ZZX** q)
 {
-    struct ZZX *qq = new ZZX(), *rr = new ZZX();
+    ZZX *qq = new ZZX(), *rr = new ZZX();
     DivRem(*qq, *rr, *x, *other);
     *r = rr; *q = qq;
 }
 
 
-struct ZZX* ZZX_square(struct ZZX* x)
+ZZX* ZZX_square(ZZX* x)
 {
-    struct ZZX* s = new ZZX();
+    ZZX* s = new ZZX();
     sqr(*s, *x);
     return s;
 }
 
 
-int ZZX_is_monic(struct ZZX* x)
+int ZZX_is_monic(ZZX* x)
 {
     return IsOne(LeadCoeff(*x));
 }
 
 
-struct ZZX* ZZX_neg(struct ZZX* x)
+ZZX* ZZX_neg(ZZX* x)
 {
-    struct ZZX* y = new ZZX();
+    ZZX* y = new ZZX();
     *y = -*x;
     return y;
 }
 
 
-struct ZZX* ZZX_left_shift(struct ZZX* x, long n)
+ZZX* ZZX_left_shift(ZZX* x, long n)
 {
-    struct ZZX* y = new ZZX();
+    ZZX* y = new ZZX();
     LeftShift(*y, *x, n);
     return y;
 }
 
 
-struct ZZX* ZZX_right_shift(struct ZZX* x, long n)
+ZZX* ZZX_right_shift(ZZX* x, long n)
 {
-    struct ZZX* y = new ZZX();
+    ZZX* y = new ZZX();
     RightShift(*y, *x, n);
     return y;
 }
 
-struct ZZX* ZZX_primitive_part(struct ZZX* x)
+ZZX* ZZX_primitive_part(ZZX* x)
 {
-    struct ZZX* p = new ZZX();
+    ZZX* p = new ZZX();
     PrimitivePart(*p, *x);
     return p;
 }
 
 
-void ZZX_pseudo_quo_rem(struct ZZX* x, struct ZZX* y, struct ZZX** r, struct ZZX** q)
+void ZZX_pseudo_quo_rem(ZZX* x, ZZX* y, ZZX** r, ZZX** q)
 {
     *r = new ZZX();
     *q = new ZZX();
@@ -322,16 +322,15 @@ void ZZX_pseudo_quo_rem(struct ZZX* x, s
 }
 
 
-struct ZZX* ZZX_gcd(struct ZZX* x, struct ZZX* y)
+ZZX* ZZX_gcd(ZZX* x, ZZX* y)
 {
-    struct ZZX* g = new ZZX();
+    ZZX* g = new ZZX();
     GCD(*g, *x, *y);
     return g;
 }
 
 
-void ZZX_xgcd(struct ZZX* x, struct ZZX* y, struct ZZ** r, struct ZZX** s,
-          struct ZZX** t, int proof)
+void ZZX_xgcd(ZZX* x, ZZX* y, ZZ** r, ZZX** s, ZZX** t, int proof)
 {
     *r = new ZZ();
     *s = new ZZX();
@@ -340,24 +339,24 @@ void ZZX_xgcd(struct ZZX* x, struct ZZX*
 }
 
 
-long ZZX_degree(struct ZZX* x)
+long ZZX_degree(ZZX* x)
 {
     return deg(*x);
 }
 
-void ZZX_set_x(struct ZZX* x)
+void ZZX_set_x(ZZX* x)
 {
     SetX(*x);
 }
 
 
-int ZZX_is_x(struct ZZX* x)
+int ZZX_is_x(ZZX* x)
 {
     return IsX(*x);
 }
 
 
-struct ZZX* ZZX_derivative(struct ZZX* x)
+ZZX* ZZX_derivative(ZZX* x)
 {
     ZZX* d = new ZZX();
     diff(*d, *x);
@@ -365,14 +364,14 @@ struct ZZX* ZZX_derivative(struct ZZX* x
 }
 
 
-struct ZZX* ZZX_reverse(struct ZZX* x)
+ZZX* ZZX_reverse(ZZX* x)
 {
     ZZX* r = new ZZX();
     reverse(*r, *x);
     return r;
 }
 
-struct ZZX* ZZX_reverse_hi(struct ZZX* x, int hi)
+ZZX* ZZX_reverse_hi(ZZX* x, int hi)
 {
     ZZX* r = new ZZX();
     reverse(*r, *x, hi);
@@ -380,7 +379,7 @@ struct ZZX* ZZX_reverse_hi(struct ZZX* x
 }
 
 
-struct ZZX* ZZX_truncate(struct ZZX* x, long m)
+ZZX* ZZX_truncate(ZZX* x, long m)
 {
     ZZX* t = new ZZX();
     trunc(*t, *x, m);
@@ -388,7 +387,7 @@ struct ZZX* ZZX_truncate(struct ZZX* x,
 }
 
 
-struct ZZX* ZZX_multiply_and_truncate(struct ZZX* x, struct ZZX* y, long m)
+ZZX* ZZX_multiply_and_truncate(ZZX* x, ZZX* y, long m)
 {
     ZZX* t = new ZZX();
     MulTrunc(*t, *x, *y, m);
@@ -396,7 +395,7 @@ struct ZZX* ZZX_multiply_and_truncate(st
 }
 
 
-struct ZZX* ZZX_square_and_truncate(struct ZZX* x, long m)
+ZZX* ZZX_square_and_truncate(ZZX* x, long m)
 {
     ZZX* t = new ZZX();
     SqrTrunc(*t, *x, m);
@@ -404,7 +403,7 @@ struct ZZX* ZZX_square_and_truncate(stru
 }
 
 
-struct ZZX* ZZX_invert_and_truncate(struct ZZX* x, long m)
+ZZX* ZZX_invert_and_truncate(ZZX* x, long m)
 {
     ZZX* t = new ZZX();
     InvTrunc(*t, *x, m);
@@ -412,7 +411,7 @@ struct ZZX* ZZX_invert_and_truncate(stru
 }
 
 
-struct ZZX* ZZX_multiply_mod(struct ZZX* x, struct ZZX* y,  struct ZZX* modulus)
+ZZX* ZZX_multiply_mod(ZZX* x, ZZX* y,  ZZX* modulus)
 {
     ZZX* p = new ZZX();
     MulMod(*p, *x, *y, *modulus);
@@ -420,7 +419,7 @@ struct ZZX* ZZX_multiply_mod(struct ZZX*
 }
 
 
-struct ZZ* ZZX_trace_mod(struct ZZX* x, struct ZZX* y)
+ZZ* ZZX_trace_mod(ZZX* x, ZZX* y)
 {
     ZZ* p = new ZZ();
     TraceMod(*p, *x, *y);
@@ -428,7 +427,7 @@ struct ZZ* ZZX_trace_mod(struct ZZX* x,
 }
 
 
-char* ZZX_trace_list(struct ZZX* x)
+char* ZZX_trace_list(ZZX* x)
 {
     vec_ZZ v;
     TraceVec(v, *x);
@@ -441,7 +440,7 @@ char* ZZX_trace_list(struct ZZX* x)
 }
 
 
-struct ZZ* ZZX_resultant(struct ZZX* x, struct ZZX* y, int proof)
+ZZ* ZZX_resultant(ZZX* x, ZZX* y, int proof)
 {
     ZZ* res = new ZZ();
     resultant(*res, *x, *y, proof);
@@ -449,7 +448,7 @@ struct ZZ* ZZX_resultant(struct ZZX* x,
 }
 
 
-struct ZZ* ZZX_norm_mod(struct ZZX* x, struct ZZX* y, int proof)
+ZZ* ZZX_norm_mod(ZZX* x, ZZX* y, int proof)
 {
     ZZ* res = new ZZ();
     NormMod(*res, *x, *y, proof);
@@ -457,7 +456,7 @@ struct ZZ* ZZX_norm_mod(struct ZZX* x, s
 }
 
 
-struct ZZ* ZZX_discriminant(struct ZZX* x, int proof)
+ZZ* ZZX_discriminant(ZZX* x, int proof)
 {
     ZZ* d = new ZZ();
     discriminant(*d, *x, proof);
@@ -465,7 +464,7 @@ struct ZZ* ZZX_discriminant(struct ZZX*
 }
 
 
-struct ZZX* ZZX_charpoly_mod(struct ZZX* x, struct ZZX* y, int proof)
+ZZX* ZZX_charpoly_mod(ZZX* x, ZZX* y, int proof)
 {
     ZZX* f = new ZZX();
     CharPolyMod(*f, *x, *y, proof);
@@ -473,7 +472,7 @@ struct ZZX* ZZX_charpoly_mod(struct ZZX*
 }
 
 
-struct ZZX* ZZX_minpoly_mod(struct ZZX* x, struct ZZX* y)
+ZZX* ZZX_minpoly_mod(ZZX* x, ZZX* y)
 {
     ZZX* f = new ZZX();
     MinPolyMod(*f, *x, *y);
@@ -481,19 +480,19 @@ struct ZZX* ZZX_minpoly_mod(struct ZZX*
 }
 
 
-void ZZX_clear(struct ZZX* x)
+void ZZX_clear(ZZX* x)
 {
     clear(*x);
 }
 
 
-void ZZX_preallocate_space(struct ZZX* x, long n)
+void ZZX_preallocate_space(ZZX* x, long n)
 {
     x->SetMaxLength(n);
 }
 
 /*
-EXTERN struct ZZ* ZZX_polyeval(struct ZZX* f, struct ZZ* a)
+EXTERN ZZ* ZZX_polyeval(ZZX* f, ZZ* a)
 {
     ZZ* b = new ZZ();
     *b = PolyEval(*f, *a);
@@ -501,7 +500,7 @@ EXTERN struct ZZ* ZZX_polyeval(struct ZZ
 }
 */
 
-void ZZX_squarefree_decomposition(struct ZZX*** v, long** e, long* n, struct ZZX* x)
+void ZZX_squarefree_decomposition(ZZX*** v, long** e, long* n, ZZX* x)
 {
     vec_pair_ZZX_long factors;
     SquareFreeDecomp(factors, *x);
@@ -518,7 +517,7 @@ void ZZX_squarefree_decomposition(struct
 //////// ZZ_pX //////////
 ///////////////////////////////////////////////
 
-// char* ZZ_pX_repr(struct ZZ_pX* x)
+// char* ZZ_pX_repr(ZZ_pX* x)
 // {
 //   ostringstream instore;
 //   instore << (*x);
@@ -528,17 +527,17 @@ void ZZX_squarefree_decomposition(struct
 //   return buf;
 // }
 
-// void ZZ_pX_dealloc(struct ZZ_pX* x) {
+// void ZZ_pX_dealloc(ZZ_pX* x) {
 //   delete x;
 // }
 
-// struct ZZ_pX* ZZ_pX_copy(struct ZZ_pX* x) {
+// ZZ_pX* ZZ_pX_copy(ZZ_pX* x) {
 //   return new ZZ_pX(*x);
 // }
 
 // /* Sets ith coefficient of x to value.
 //    AUTHOR: David Harvey (2008-06-08) */
-// void ZZ_pX_setitem_from_int(struct ZZ_pX* x, long i, int value)
+// void ZZ_pX_setitem_from_int(ZZ_pX* x, long i, int value)
 // {
 //   SetCoeff(*x, i, value);
 // }
@@ -546,26 +545,26 @@ void ZZX_squarefree_decomposition(struct
 // /* Returns ith coefficient of x.
 //    Return value is only valid if the result should fit into an int.
 //    AUTHOR: David Harvey (2008-06-08) */
-// int ZZ_pX_getitem_as_int(struct ZZ_pX* x, long i)
+// int ZZ_pX_getitem_as_int(ZZ_pX* x, long i)
 // {
 //     return ZZ_to_int(&rep(coeff(*x, i)));
 // }
 
-// struct ZZ_pX* ZZ_pX_add(struct ZZ_pX* x, struct ZZ_pX* y)
+// ZZ_pX* ZZ_pX_add(ZZ_pX* x, ZZ_pX* y)
 // {
 //   ZZ_pX *z = new ZZ_pX();
 //   add(*z, *x, *y);
 //   return z;
 // }
 
-// struct ZZ_pX* ZZ_pX_sub(struct ZZ_pX* x, struct ZZ_pX* y)
+// ZZ_pX* ZZ_pX_sub(ZZ_pX* x, ZZ_pX* y)
 // {
 //   ZZ_pX *z = new ZZ_pX();
 //   sub(*z, *x, *y);
 //   return z;
 // }
 
-// struct ZZ_pX* ZZ_pX_mul(struct ZZ_pX* x, struct ZZ_pX* y)
+// ZZ_pX* ZZ_pX_mul(ZZ_pX* x, ZZ_pX* y)
 // {
 //   ZZ_pX *z = new ZZ_pX();
 //   mul(*z, *x, *y);
@@ -573,24 +572,24 @@ void ZZX_squarefree_decomposition(struct
 // }
 
 
-// struct ZZ_pX* ZZ_pX_div(struct ZZ_pX* x, struct ZZ_pX* y, int* divisible)
+// ZZ_pX* ZZ_pX_div(ZZ_pX* x, ZZ_pX* y, int* divisible)
 // {
-//   struct ZZ_pX* z = new ZZ_pX();
+//   ZZ_pX* z = new ZZ_pX();
 //   *divisible = divide(*z, *x, *y);
 //   return z;
 // }
 
 
-// struct ZZ_pX* ZZ_pX_mod(struct ZZ_pX* x, struct ZZ_pX* y)
+// ZZ_pX* ZZ_pX_mod(ZZ_pX* x, ZZ_pX* y)
 // {
-//   struct ZZ_pX* z = new ZZ_pX();
+//   ZZ_pX* z = new ZZ_pX();
 //   rem(*z, *x, *y);
 //   return z;
 // }
 
 
 
-// void ZZ_pX_quo_rem(struct ZZ_pX* x, struct ZZ_pX* y, struct ZZ_pX** r, struct ZZ_pX** q)
+// void ZZ_pX_quo_rem(ZZ_pX* x, ZZ_pX* y, ZZ_pX** r, ZZ_pX** q)
 // {
 //   *r = new ZZ_pX();
 //   *q = new ZZ_pX();
@@ -598,55 +597,55 @@ void ZZX_squarefree_decomposition(struct
 // }
 
 
-// struct ZZ_pX* ZZ_pX_square(struct ZZ_pX* x)
+// ZZ_pX* ZZ_pX_square(ZZ_pX* x)
 // {
-//   struct ZZ_pX* s = new ZZ_pX();
+//   ZZ_pX* s = new ZZ_pX();
 //   sqr(*s, *x);
 //   return s;
 // }
 
 
 
-// int ZZ_pX_is_monic(struct ZZ_pX* x)
+// int ZZ_pX_is_monic(ZZ_pX* x)
 // {
 //   IsOne(LeadCoeff(*x));
 // }
 
 
-// struct ZZ_pX* ZZ_pX_neg(struct ZZ_pX* x)
+// ZZ_pX* ZZ_pX_neg(ZZ_pX* x)
 // {
-//   struct ZZ_pX* y = new ZZ_pX();
+//   ZZ_pX* y = new ZZ_pX();
 //   *y = -*x;
 //   return y;
 // }
 
 
-// struct ZZ_pX* ZZ_pX_left_shift(struct ZZ_pX* x, long n)
+// ZZ_pX* ZZ_pX_left_shift(ZZ_pX* x, long n)
 // {
-//   struct ZZ_pX* y = new ZZ_pX();
+//   ZZ_pX* y = new ZZ_pX();
 //   LeftShift(*y, *x, n);
 //   return y;
 // }
 
 
-// struct ZZ_pX* ZZ_pX_right_shift(struct ZZ_pX* x, long n)
+// ZZ_pX* ZZ_pX_right_shift(ZZ_pX* x, long n)
 // {
-//   struct ZZ_pX* y = new ZZ_pX();
+//   ZZ_pX* y = new ZZ_pX();
 //   RightShift(*y, *x, n);
 //   return y;
 // }
 
 
 
-// struct ZZ_pX* ZZ_pX_gcd(struct ZZ_pX* x, struct ZZ_pX* y)
+// ZZ_pX* ZZ_pX_gcd(ZZ_pX* x, ZZ_pX* y)
 // {
-//   struct ZZ_pX* g = new ZZ_pX();
+//   ZZ_pX* g = new ZZ_pX();
 //   GCD(*g, *x, *y);
 //   return g;
 // }
 
 
-// void ZZ_pX_xgcd(struct ZZ_pX** d, struct ZZ_pX** s, struct ZZ_pX** t, struct ZZ_pX* a, struct ZZ_pX* b)
+// void ZZ_pX_xgcd(ZZ_pX** d, ZZ_pX** s, ZZ_pX** t, ZZ_pX* a, ZZ_pX* b)
 // {
 //   *d = new ZZ_pX();
 //   *s = new ZZ_pX();
@@ -654,7 +653,7 @@ void ZZX_squarefree_decomposition(struct
 //   XGCD(**d, **s, **t, *a, *b);
 // }
 
-// void ZZ_pX_plain_xgcd(struct ZZ_pX** d, struct ZZ_pX** s, struct ZZ_pX** t, struct ZZ_pX* a, struct ZZ_pX* b)
+// void ZZ_pX_plain_xgcd(ZZ_pX** d, ZZ_pX** s, ZZ_pX** t, ZZ_pX* a, ZZ_pX* b)
 // {
 //   *d = new ZZ_pX();
 //   *s = new ZZ_pX();
@@ -662,25 +661,25 @@ void ZZX_squarefree_decomposition(struct
 //   PlainXGCD(**d, **s, **t, *a, *b);
 // }
 
-// ZZ_p* ZZ_pX_leading_coefficient(struct ZZ_pX* x)
+// ZZ_p* ZZ_pX_leading_coefficient(ZZ_pX* x)
 // {
 //   return new ZZ_p(LeadCoeff(*x));
 // }
 
 
-// void ZZ_pX_set_x(struct ZZ_pX* x)
+// void ZZ_pX_set_x(ZZ_pX* x)
 // {
 //   SetX(*x);
 // }
 
 
-// int ZZ_pX_is_x(struct ZZ_pX* x)
+// int ZZ_pX_is_x(ZZ_pX* x)
 // {
 //   return IsX(*x);
 // }
 
 
-// struct ZZ_pX* ZZ_pX_derivative(struct ZZ_pX* x)
+// ZZ_pX* ZZ_pX_derivative(ZZ_pX* x)
 // {
 //   ZZ_pX* d = new ZZ_pX();
 //   diff(*d, *x);
@@ -688,14 +687,14 @@ void ZZX_squarefree_decomposition(struct
 // }
 
 
-// struct ZZ_pX* ZZ_pX_reverse(struct ZZ_pX* x)
+// ZZ_pX* ZZ_pX_reverse(ZZ_pX* x)
 // {
 //   ZZ_pX* r = new ZZ_pX();
 //   reverse(*r, *x);
 //   return r;
 // }
 
-// struct ZZ_pX* ZZ_pX_reverse_hi(struct ZZ_pX* x, int hi)
+// ZZ_pX* ZZ_pX_reverse_hi(ZZ_pX* x, int hi)
 // {
 //   ZZ_pX* r = new ZZ_pX();
 //   reverse(*r, *x, hi);
@@ -703,7 +702,7 @@ void ZZX_squarefree_decomposition(struct
 // }
 
 
-// struct ZZ_pX* ZZ_pX_truncate(struct ZZ_pX* x, long m)
+// ZZ_pX* ZZ_pX_truncate(ZZ_pX* x, long m)
 // {
 //   ZZ_pX* t = new ZZ_pX();
 //   trunc(*t, *x, m);
@@ -711,7 +710,7 @@ void ZZX_squarefree_decomposition(struct
 // }
 
 
-// struct ZZ_pX* ZZ_pX_multiply_and_truncate(struct ZZ_pX* x, struct ZZ_pX* y, long m)
+// ZZ_pX* ZZ_pX_multiply_and_truncate(ZZ_pX* x, ZZ_pX* y, long m)
 // {
 //   ZZ_pX* t = new ZZ_pX();
 //   MulTrunc(*t, *x, *y, m);
@@ -719,7 +718,7 @@ void ZZX_squarefree_decomposition(struct
 // }
 
 
-// struct ZZ_pX* ZZ_pX_square_and_truncate(struct ZZ_pX* x, long m)
+// ZZ_pX* ZZ_pX_square_and_truncate(ZZ_pX* x, long m)
 // {
 //   ZZ_pX* t = new ZZ_pX();
 //   SqrTrunc(*t, *x, m);
@@ -727,7 +726,7 @@ void ZZX_squarefree_decomposition(struct
 // }
 
 
-// struct ZZ_pX* ZZ_pX_invert_and_truncate(struct ZZ_pX* x, long m)
+// ZZ_pX* ZZ_pX_invert_and_truncate(ZZ_pX* x, long m)
 // {
 //   ZZ_pX* t = new ZZ_pX();
 //   InvTrunc(*t, *x, m);
@@ -735,7 +734,7 @@ void ZZX_squarefree_decomposition(struct
 // }
 
 
-// struct ZZ_pX* ZZ_pX_multiply_mod(struct ZZ_pX* x, struct ZZ_pX* y,  struct ZZ_pX* modulus)
+// ZZ_pX* ZZ_pX_multiply_mod(ZZ_pX* x, ZZ_pX* y,  ZZ_pX* modulus)
 // {
 //   ZZ_pX* p = new ZZ_pX();
 //   MulMod(*p, *x, *y, *modulus);
@@ -743,7 +742,7 @@ void ZZX_squarefree_decomposition(struct
 // }
 
 
-// struct ZZ_p* ZZ_pX_trace_mod(struct ZZ_pX* x, struct ZZ_pX* y)
+// ZZ_p* ZZ_pX_trace_mod(ZZ_pX* x, ZZ_pX* y)
 // {
 //   ZZ_p* p = new ZZ_p();
 //   TraceMod(*p, *x, *y);
@@ -751,7 +750,7 @@ void ZZX_squarefree_decomposition(struct
 // }
 
 
-char* ZZ_pX_trace_list(struct ZZ_pX* x)
+char* ZZ_pX_trace_list(ZZ_pX* x)
 {
     vec_ZZ_p v;
     TraceVec(v, *x);
@@ -764,7 +763,7 @@ char* ZZ_pX_trace_list(struct ZZ_pX* x)
 }
 
 
-// struct ZZ_p* ZZ_pX_resultant(struct ZZ_pX* x, struct ZZ_pX* y)
+// ZZ_p* ZZ_pX_resultant(ZZ_pX* x, ZZ_pX* y)
 // {
 //   ZZ_p* res = new ZZ_p();
 //   resultant(*res, *x, *y);
@@ -772,7 +771,7 @@ char* ZZ_pX_trace_list(struct ZZ_pX* x)
 // }
 
 
-// struct ZZ_p* ZZ_pX_norm_mod(struct ZZ_pX* x, struct ZZ_pX* y)
+// ZZ_p* ZZ_pX_norm_mod(ZZ_pX* x, ZZ_pX* y)
 // {
 //   ZZ_p* res = new ZZ_p();
 //   NormMod(*res, *x, *y);
@@ -781,7 +780,7 @@ char* ZZ_pX_trace_list(struct ZZ_pX* x)
 
 
 
-// struct ZZ_pX* ZZ_pX_charpoly_mod(struct ZZ_pX* x, struct ZZ_pX* y)
+// ZZ_pX* ZZ_pX_charpoly_mod(ZZ_pX* x, ZZ_pX* y)
 // {
 //   ZZ_pX* f = new ZZ_pX();
 //   CharPolyMod(*f, *x, *y);
@@ -789,7 +788,7 @@ char* ZZ_pX_trace_list(struct ZZ_pX* x)
 // }
 
 
-// struct ZZ_pX* ZZ_pX_minpoly_mod(struct ZZ_pX* x, struct ZZ_pX* y)
+// ZZ_pX* ZZ_pX_minpoly_mod(ZZ_pX* x, ZZ_pX* y)
 // {
 //   ZZ_pX* f = new ZZ_pX();
 //   MinPolyMod(*f, *x, *y);
@@ -797,18 +796,18 @@ char* ZZ_pX_trace_list(struct ZZ_pX* x)
 // }
 
 
-// void ZZ_pX_clear(struct ZZ_pX* x)
+// void ZZ_pX_clear(ZZ_pX* x)
 // {
 //   clear(*x);
 // }
 
 
-// void ZZ_pX_preallocate_space(struct ZZ_pX* x, long n)
+// void ZZ_pX_preallocate_space(ZZ_pX* x, long n)
 // {
 //   x->SetMaxLength(n);
 // }
 
-void ZZ_pX_factor(struct ZZ_pX*** v, long** e, long* n, struct ZZ_pX* x, long verbose)
+void ZZ_pX_factor(ZZ_pX*** v, long** e, long* n, ZZ_pX* x, long verbose)
 {
     long i;
     vec_pair_ZZ_pX_long factors;
@@ -822,7 +821,7 @@ void ZZ_pX_factor(struct ZZ_pX*** v, lon
     }
 }
 
-void ZZ_pX_linear_roots(struct ZZ_p*** v, long* n, struct ZZ_pX* f)
+void ZZ_pX_linear_roots(ZZ_p*** v, long* n, ZZ_pX* f)
 {
     long i;
     vec_ZZ_p w;
@@ -836,7 +835,7 @@ void ZZ_pX_linear_roots(struct ZZ_p*** v
 
 /////////// ZZ_pE //////////////
 
-struct ZZ_pX ZZ_pE_to_ZZ_pX(struct ZZ_pE x)
+ZZ_pX ZZ_pE_to_ZZ_pX(ZZ_pE x)
 {
     return ZZ_pX(rep(x));
 }
@@ -845,67 +844,67 @@ struct ZZ_pX ZZ_pE_to_ZZ_pX(struct ZZ_pE
 
 //////// mat_ZZ //////////
 
-void mat_ZZ_SetDims(struct mat_ZZ* mZZ, long nrows, long ncols){
+void mat_ZZ_SetDims(mat_ZZ* mZZ, long nrows, long ncols){
     mZZ->SetDims(nrows, ncols);
 }
 
-struct mat_ZZ* mat_ZZ_pow(const struct mat_ZZ* x, long e) 
+mat_ZZ* mat_ZZ_pow(const mat_ZZ* x, long e) 
 {
     mat_ZZ *z = new mat_ZZ();
     power(*z, *x, e);
     return z;
 }
 
-long mat_ZZ_nrows(const struct mat_ZZ* x)
+long mat_ZZ_nrows(const mat_ZZ* x)
 {
     return x->NumRows();
 }
 
 
-long mat_ZZ_ncols(const struct mat_ZZ* x)
+long mat_ZZ_ncols(const mat_ZZ* x)
 {
     return x->NumCols();
 }
 
-void mat_ZZ_setitem(struct mat_ZZ* x, int i, int j, const struct ZZ* z)
+void mat_ZZ_setitem(mat_ZZ* x, int i, int j, const ZZ* z)
 {
     (*x)[i][j] = *z;
   
 }
 
-struct ZZ* mat_ZZ_getitem(const struct mat_ZZ* x, int i, int j)
+ZZ* mat_ZZ_getitem(const mat_ZZ* x, int i, int j)
 {
     return new ZZ((*x)(i,j));
 }
 
-struct ZZ* mat_ZZ_determinant(const struct mat_ZZ* x, long deterministic)
+ZZ* mat_ZZ_determinant(const mat_ZZ* x, long deterministic)
 {
     ZZ* d = new ZZ();
     determinant(*d, *x, deterministic);
     return d;
 }
 
-struct mat_ZZ* mat_ZZ_HNF(const struct mat_ZZ* A, const struct ZZ* D)
+mat_ZZ* mat_ZZ_HNF(const mat_ZZ* A, const ZZ* D)
 {
-    struct mat_ZZ* W = new mat_ZZ();
+    mat_ZZ* W = new mat_ZZ();
     HNF(*W, *A, *D);
     return W;
 }
 
-long mat_ZZ_LLL(struct ZZ **det, struct mat_ZZ *x, long a, long b, long verbose)
+long mat_ZZ_LLL(ZZ **det, mat_ZZ *x, long a, long b, long verbose)
 {
     *det = new ZZ();
     return LLL(**det,*x,a,b,verbose);
 }
 
-long mat_ZZ_LLL_U(struct ZZ **det, struct mat_ZZ *x, struct mat_ZZ *U, long a, long b, long verbose)
+long mat_ZZ_LLL_U(ZZ **det, mat_ZZ *x, mat_ZZ *U, long a, long b, long verbose)
 {
     *det = new ZZ();
     return LLL(**det,*x,*U,a,b,verbose);
 }
 
 
-struct ZZX* mat_ZZ_charpoly(const struct mat_ZZ* A)
+ZZX* mat_ZZ_charpoly(const mat_ZZ* A)
 {
     ZZX* f = new ZZX();
     CharPoly(*f, *A);
@@ -928,12 +927,12 @@ GF2EContext* GF2EContext_new(const GF2X
 }
 
 
-void mat_GF2E_setitem(struct mat_GF2E* x, int i, int j, const struct GF2E* z)
+void mat_GF2E_setitem(mat_GF2E* x, int i, int j, const GF2E* z)
 {
     (*x)[i][j] = *z;
 }
 
-void mat_GF2_setitem(struct mat_GF2* x, int i, int j, const struct GF2* z)
+void mat_GF2_setitem(mat_GF2* x, int i, int j, const GF2* z)
 {
     (*x)[i][j] = *z;
 }
@@ -1022,7 +1021,7 @@ void ZZ_pEX_conv_modulus(ZZ_pEX &fout, c
     fout.normalize();
 }
 
-void ZZ_pX_min_val_coeff(long & valuation, long &index, const struct ZZ_pX &f, const struct ZZ &p)
+void ZZ_pX_min_val_coeff(long & valuation, long &index, const ZZ_pX &f, const ZZ &p)
 {
     // Sets index, where the indexth coefficient of f has the minimum p-adic valuation.
     // Sets valuation to be this valuation.
@@ -1067,7 +1066,7 @@ void ZZ_pX_min_val_coeff(long & valuatio
     delete u;
 }
 
-long ZZ_pX_get_val_coeff(const struct ZZ_pX &f, const struct ZZ &p, long i)
+long ZZ_pX_get_val_coeff(const ZZ_pX &f, const ZZ &p, long i)
 {
     // Gets the p-adic valuation of the ith coefficient of f.
     ZZ *u = new ZZ();
@@ -1076,7 +1075,7 @@ long ZZ_pX_get_val_coeff(const struct ZZ
     return ans;
 }
 
-void ZZ_pX_left_pshift(struct ZZ_pX &x, const struct ZZ_pX &a, const struct ZZ &pn, const struct ZZ_pContext &c)
+void ZZ_pX_left_pshift(ZZ_pX &x, const ZZ_pX &a, const ZZ &pn, const ZZ_pContext &c)
 {
     // Multiplies each coefficient by pn, and sets the context of the answer to c.
 
@@ -1102,7 +1101,7 @@ void ZZ_pX_left_pshift(struct ZZ_pX &x,
     x.normalize();    
 }
 
-void ZZ_pX_right_pshift(struct ZZ_pX &x, const struct ZZ_pX &a, const struct ZZ &pn, const struct ZZ_pContext &c)
+void ZZ_pX_right_pshift(ZZ_pX &x, const ZZ_pX &a, const ZZ &pn, const ZZ_pContext &c)
 {
     // Divides each coefficient by pn, and sets the context of the answer to c.
 
@@ -1128,7 +1127,7 @@ void ZZ_pX_right_pshift(struct ZZ_pX &x,
     x.normalize();    
 }
 
-void ZZ_pX_InvMod_newton_unram(struct ZZ_pX &x, const struct ZZ_pX &a, const struct ZZ_pXModulus &F, const struct ZZ_pContext &cpn, const struct ZZ_pContext &cp)
+void ZZ_pX_InvMod_newton_unram(ZZ_pX &x, const ZZ_pX &a, const ZZ_pXModulus &F, const ZZ_pContext &cpn, const ZZ_pContext &cp)
 {
     //int j;
     cp.restore();
@@ -1163,7 +1162,7 @@ void ZZ_pX_InvMod_newton_unram(struct ZZ
     delete xn;
 }
 
-void ZZ_pX_InvMod_newton_ram(struct ZZ_pX &x, const struct ZZ_pX &a, const struct ZZ_pXModulus &F, const struct ZZ_pContext &cpn)
+void ZZ_pX_InvMod_newton_ram(ZZ_pX &x, const ZZ_pX &a, const ZZ_pXModulus &F, const ZZ_pContext &cpn)
 {
     //int j;
     cpn.restore();
diff -up sage-5.10/spkg/build/sage-5.10/sage/libs/ntl/decl.pxi.orig sage-5.10/spkg/build/sage-5.10/sage/libs/ntl/decl.pxi
--- sage-5.10/spkg/build/sage-5.10/sage/libs/ntl/decl.pxi.orig	2013-07-29 19:39:08.246018227 -0300
+++ sage-5.10/spkg/build/sage-5.10/sage/libs/ntl/decl.pxi	2013-07-29 19:40:11.836020662 -0300
@@ -22,7 +22,7 @@ from sage.libs.ntl.ntl_ZZ_pEX_decl cimpo
 
 cdef extern from "ntl_wrap.h":
     #### mat_ZZ_c
-    ctypedef struct mat_ZZ_c "struct mat_ZZ":
+    ctypedef struct mat_ZZ_c "mat_ZZ":
         pass
 
     # Some boiler-plate
@@ -92,7 +92,7 @@ cdef extern from "ntl_wrap.h":
     cdef long mat_ZZ_G_BKZ_RR_U   "G_BKZ_RR"(mat_ZZ_c B, mat_ZZ_c U, double delta, long BlockSize, long prune, int check, long verbose)
 
     #### GF2_c
-    ctypedef struct GF2_c "struct GF2":
+    ctypedef struct GF2_c "GF2":
         pass
 
     GF2_c* GF2_new "New<GF2>"()
@@ -118,7 +118,7 @@ cdef extern from "ntl_wrap.h":
 
     #### GF2X_c
 
-    ctypedef struct GF2X_c "struct GF2X":
+    ctypedef struct GF2X_c "GF2X":
         pass
 
     long *GF2XHexOutput_c "(&GF2X::HexOutput)" # work-around for Cython bug
@@ -175,7 +175,7 @@ cdef extern from "ntl_wrap.h":
     void GF2X_BuildIrred "BuildIrred" (GF2X_c f, long n)
 
     #### GF2XModulus_c
-    ctypedef struct GF2XModulus_c "struct GF2XModulus":
+    ctypedef struct GF2XModulus_c "GF2XModulus":
         pass
 
     GF2X_c GF2XModulus_GF2X "GF2X" (GF2XModulus_c m)
@@ -184,7 +184,7 @@ cdef extern from "ntl_wrap.h":
 
     #### GF2EContext_c
 
-    ctypedef struct GF2EContext_c "struct GF2EContext":
+    ctypedef struct GF2EContext_c "GF2EContext":
         void (*restore)()
 
     GF2EContext_c* GF2EContext_new "New<GF2EContext>"()
@@ -195,7 +195,7 @@ cdef extern from "ntl_wrap.h":
     void GF2EContext_delete "Delete<GF2EContext>"(GF2EContext_c *mem)
 
     #### GF2E_c
-    ctypedef struct GF2E_c "struct GF2E":
+    ctypedef struct GF2E_c "GF2E":
         pass
 
     void GF2E_init "GF2E::init"(GF2X_c x)
@@ -230,7 +230,7 @@ cdef extern from "ntl_wrap.h":
     GF2_c GF2E_trace "trace"(GF2E_c x)
 
     #### GF2EX_c
-    ctypedef struct GF2EX_c "struct GF2EX":
+    ctypedef struct GF2EX_c "GF2EX":
         pass
 
     GF2EX_c* GF2EX_new "New<GF2EX>"()
@@ -249,7 +249,7 @@ cdef extern from "ntl_wrap.h":
     int GF2EX_IsZero "IsZero"(GF2EX_c x)
 
     #### vec_GF2E_c
-    ctypedef struct vec_GF2E_c "struct vec_GF2E":
+    ctypedef struct vec_GF2E_c "vec_GF2E":
         pass
 
     vec_GF2E_c* vec_GF2E_new "New<vec_GF2E>"()
@@ -260,7 +260,7 @@ cdef extern from "ntl_wrap.h":
     object vec_GF2E_to_PyString "_to_PyString<vec_GF2E>"(vec_GF2E_c *x)
 
     #### mat_GF2E_c
-    ctypedef struct mat_GF2E_c "struct mat_GF2E":
+    ctypedef struct mat_GF2E_c "mat_GF2E":
         void (*SetDims)(long nrows, long ncols)
         long (*NumRows)()
         long (*NumCols)()
@@ -299,7 +299,7 @@ cdef extern from "ntl_wrap.h":
     void mat_GF2E_conv_vec_GF2E(mat_GF2E_c out, vec_GF2E_c inp)
 
     #### vec_GF2_c
-    ctypedef struct vec_GF2_c "struct vec_GF2":
+    ctypedef struct vec_GF2_c "vec_GF2":
         pass
 
     vec_GF2_c* vec_GF2_new "New<vec_GF2>"()
@@ -311,7 +311,7 @@ cdef extern from "ntl_wrap.h":
 
 
     #### mat_GF2_c
-    ctypedef struct mat_GF2_c "struct mat_GF2":
+    ctypedef struct mat_GF2_c "mat_GF2":
         void (*SetDims)(long nrows, long ncols)
         long (*NumRows)()
         long (*NumCols)()
