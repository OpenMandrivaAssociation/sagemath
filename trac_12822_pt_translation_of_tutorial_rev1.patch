# HG changeset patch
# User Gustavo de Oliveira <goliveira5d@gmail.com>
# Date 1336320704 -7200
# Node ID f35ca5dd36d8ccfeba96947e9e10402f6e6ed79b
# Parent  ad8e41651a3187a45f087335cb048418bf545506
Trac 12822: Portuguese translation of "Tutorial" (revision 1).

diff --git a/doc/pt/tutorial/interactive_shell.rst b/doc/pt/tutorial/interactive_shell.rst
--- a/doc/pt/tutorial/interactive_shell.rst
+++ b/doc/pt/tutorial/interactive_shell.rst
@@ -361,8 +361,8 @@
 
 Note que o GAP e o Maxima são os mais lentos neste teste (isso foi
 executado no computador ``sage.math.washington.edu``). Devido ao
-"overhead" da interface pexpect, talvez não seja apropriado comparar
-esses resultados com o Sage, que é o mais rápido.
+processamento extra (overhead) da interface pexpect, talvez não seja
+apropriado comparar esses resultados com o Sage, que é o mais rápido.
 
 Outras Dicas para o IPython
 ===========================
@@ -402,7 +402,7 @@
 
 - Você pode usar ``%edit`` (ou ``%ed`` ou ``ed``) para abrir um
   editor, se você desejar digitar algum código mais complexo. Antes de
-  iniciar o Sage, certifique-se de que a variável de environment
+  iniciar o Sage, certifique-se de que a variável de ambiente
   :envvar:`EDITOR` está definida com o seu editor favorito (colocando
   ``export EDITOR=/usr/bin/emacs`` ou ``export EDITOR=/usr/bin/vim``
   or algo similar no lugar apropriado, como um arquivo ``.profile``).
@@ -789,7 +789,7 @@
     sage: v = E.anlist(100000)              # instant!
 
 (Em Python, salvar e restaurar é feito usando o módulo ``cPickle``. Em
-particular, um objeto ``x`` do Sage pode ser salvado usando
+particular, um objeto ``x`` do Sage pode ser salvo usando
 ``cPickle.dumps(x, 2)``. Note o ``2``!)
 
 O sage não pode salvar e carregar objetos criados em algum outro
@@ -811,7 +811,7 @@
     ValueError: The session in which this object was defined is no longer 
     running.
 
-Objetos do GP/PARI também podem ser salvados e carregados pois suas
+Objetos do GP/PARI também podem ser salvos e carregados pois suas
 representações em forma impressa são suficientes para reconstruí-los.
 
 .. skip
@@ -823,7 +823,7 @@
     sage: load('a')
     2
 
-Objetos que foram salvados podem ser abertos posteriormente em
+Objetos que foram salvos podem ser abertos posteriormente em
 computadores com arquiteturas e sistemas operacionais diferentes, por
 exemplo, você poderia salvar uma matriz muito grande em um OS X de
 32-bits e abri-lo em um Linux de 64-bits, encontrar a forma reduzida,
@@ -868,7 +868,7 @@
 ``sessionname``. (No caso raro de uma variável não poder ser salva,
 ela simplesmente não aparece no dicionário.) O resultado é um arquivo
 ``.sobj`` que pode ser aberto como qualquer outro objeto que foi
-salvado. Quando você abre os objetos que foram salvados em uma sessão,
+salvo. Quando você abre os objetos que foram salvos em uma sessão,
 você obtém um dicionário cujas chaves (keys) são os nomes das
 variáveis e os valores são os objetos.
 
@@ -954,7 +954,7 @@
     sage: notebook()
 
 na linha de comando do Sage. Isso inicia o Notebook e abre o seu
-browser padrão para visualizá-lo. Os arquivos de estado do servidor
+navegador padrão para visualizá-lo. Os arquivos de estado do servidor
 são armazenados em ``$HOME/.sage/sage\_notebook``.
 
 Outras opções incluem:
diff --git a/doc/pt/tutorial/interfaces.rst b/doc/pt/tutorial/interfaces.rst
--- a/doc/pt/tutorial/interfaces.rst
+++ b/doc/pt/tutorial/interfaces.rst
@@ -48,15 +48,15 @@
     Mod(5, 10007)
 
 No primeiro caso, uma cópia separada do interpretador GP é iniciada
-como um servidor, e a string ``´znprimroot(10007)'`` é enviada,
+como um servidor, e a string ``znprimroot(10007)`` é enviada,
 calculada pelo GP, e o resultado é armazenado em uma variável no GP
 (que ocupa espaço na memória dos processos do GP que não serão
 liberados). Então o valor dessa variável é exibido. No segundo caso,
-nenhum programa separado é iniciado, e a string
-``´znprimroot(10007)'`` é calculada por uma certa função da biblioteca
-C do PARI. O resultado é armazenado na memória em uso pelo Python, que
-é liberada quando a variável não for mais referenciada. Os objetos
-possuem tipos diferentes:
+nenhum programa separado é iniciado, e a string ``znprimroot(10007)``
+é calculada por uma certa função da biblioteca C do PARI. O resultado
+é armazenado na memória em uso pelo Python, que é liberada quando a
+variável não for mais referenciada. Os objetos possuem tipos
+diferentes:
 
 ::
 
@@ -187,7 +187,7 @@
 ========
 
 O Singular fornece uma biblioteca massiva e madura para bases de
-Gröbner, máximo divisor comum para poliômios em várias variaveis,
+Gröbner, máximo divisor comum para polinômios em várias variáveis,
 bases de espaços de Riemann-Roch de uma curva plana, e fatorização,
 entre outras coisas. Vamos ilustrar a fatorização de polinômios em
 várias variáveis usando a interface do Sage para o Singular (não
diff --git a/doc/pt/tutorial/introduction.rst b/doc/pt/tutorial/introduction.rst
--- a/doc/pt/tutorial/introduction.rst
+++ b/doc/pt/tutorial/introduction.rst
@@ -68,7 +68,7 @@
 principal do Sage [SA]_ para instruções de como instalar o Sage no seu
 computador. Aqui faremos apenas alguns comentários.
 
-#. O arquivo para download do Sage vem com "baterias incluídas". Em
+#. O arquivo para instalação do Sage vem com "baterias incluídas". Em
    outras palavras, embora o Sage use o Python, IPython, PARI, GAP,
    Singular, Maxima, NTL, GMP, e uma série de outros programas, você
    não precisa instalá-los separadamente pois eles estão incluídos no
diff --git a/doc/pt/tutorial/latex.rst b/doc/pt/tutorial/latex.rst
--- a/doc/pt/tutorial/latex.rst
+++ b/doc/pt/tutorial/latex.rst
@@ -31,15 +31,15 @@
 
 #. A interface Notebook é configurada para usar o `jsMath
    <http://www.math.union.edu/~dpvc/jsMath/>`_ para representar
-   fórmulas matemáticas de forma clara em um web browser. O jsMath é
+   fórmulas matemáticas de forma clara em um web navegador. O jsMath é
    uma coleção de rotinas em JavaScript e fontes associadas.
    Tipicamente esses fontes ficam armazenadas em um servidor e são
-   enviadas para o browser juntamente com a página onde elas estão
+   enviadas para o navegador juntamente com a página onde elas estão
    sendo usadas. No caso do Sage, o Notebook está sempre conectado a
    um servidor usado para executar os comando do Sage, e esse servidor
    também fornece as fontes do jsMath necessárias. Logo não é
    necessário configurar nada mais para ter formulas matemáticas
-   representadas no seu browser quando você usa o Notebook do Sage.
+   representadas no seu navegador quando você usa o Notebook do Sage.
 
    O jsMath é implementado para representar um subconjunto grande,
    mas não completo, do TeX. Ele não suporta objetos como, por
@@ -154,7 +154,7 @@
 Um segundo recurso disponível no Notebook é possibilidade de inserir
 código TeX para fazer anotações na folha de trabalho. Quando o cursos
 esta posicionado entre células de modo que uma barra azul fica
-visível, então shift-click irá abrir um mini processador de texto,
+visível, então shift+clique irá abrir um mini processador de texto,
 TinyMCE. Isso permite digitar texto, usando um editor WSISYG para
 criar HTML e CSS. Logo é possível inserir texto formatado para
 complementar a folha de trabalho. Todavia, texto entre símbolos $, ou
@@ -176,8 +176,9 @@
 usado para alterar a notação de matrizes -- parênteses grandes,
 colchetes, barras verticais. Nenhuma noção de estilo é enfatizada,
 você pode configurar como desejado. Observe como as barras invertidas
-usadas em LaTeX requerem uma barra adicional de modo que elas possam
-ser interpretadas (escaped) corretamente em uma string do Python. ::
+usadas em LaTeX requerem uma barra adicional para que elas não sejam
+interpretadas pelo Python como um comando (ou seja, sejam implementadas
+simplesmente como parte de uma string. ::
 
     sage: A = matrix(ZZ, 2, 2, range(4))
     sage: latex(A)
@@ -217,10 +218,10 @@
     <html><div class="math">\newcommand{\Bold}[1]{\mathbb{#1}}\Bold{Q}</div></html>
     sage: latex.blackboard_bold(False)
 
-É possível aproveitar os recursos do TeX adicionando novas macros e
-novos pacotes. Primeiro, macros individuais podem ser adicionadas para
-serem usadas quando o jsMath interpreta pequenos trechos de códigos
-TeX no Notebook. ::
+É possível aproveitar os recursos do TeX adicionando novas funções
+(macros em inglês) e novos pacotes. Primeiro, funções individuais podem
+ser adicionadas para serem usadas quando o jsMath interpreta pequenos
+trechos de códigos TeX no Notebook. ::
 
     sage: latex.extra_macros()
     ''
@@ -436,7 +437,7 @@
 Para uma experiência semelhante no Notebook, é necessário desabilitar
 o processador jsMath para o código LaTeX do grafo usando a "lista de
 comandos a serem evitados pelo jsMath". Grafos são criados usando o
-environment ``tikzpicture``, logo essa uma boa escolha para uma string
+ambiente ``tikzpicture``, logo essa uma boa escolha para uma string
 a ser incluída na lista que acabamos de mencionar. Agora,
 ``view(graphs.CompleteGraph(4))`` em uma folha de trabalho deve
 executar o pdflatex para criar um PDF e então o programa ``convert``
@@ -486,7 +487,7 @@
 
 Existem três programas disponíveis para integrar ainda mais o TeX e o
 Sage. O primeiro é o sagetex. Uma descrição concisa do sagetex é que
-ele é uma coleção de macros do TeX que permitem incluir em um
+ele é uma coleção de funções do TeX que permitem incluir em um
 documento LaTeX instruções para usar o Sage para calcular vários
 objetos, e/ou formatar objetos usando o comando ``latex()`` existente
 no Sage. Logo, como um passo intermediário para compilar um documento
@@ -496,7 +497,7 @@
 sagetex para fazer cálculos com o Sage. Veja :ref:`sec-sagetex` para
 mais informações.
 
-O tex2sws começa com um documento LaTeX, mas define environments
+O tex2sws começa com um documento LaTeX, mas define ambientes
 adicionais para inserir código em Sage. Quando processado com as
 ferramentas adequadas, o resultado é uma folha de trabalho do Sage,
 com conteúdo apropriadamente formatado para o jsMath e com código em
diff --git a/doc/pt/tutorial/programming.rst b/doc/pt/tutorial/programming.rst
--- a/doc/pt/tutorial/programming.rst
+++ b/doc/pt/tutorial/programming.rst
@@ -66,7 +66,7 @@
 (Em Python, ``^`` significa "ou exclusivo" e ``**`` significa
 "exponenciação".)
 
-Esse "preparsing" está implementado em ``sage/misc/interpreter.py``.)
+Esse "" está implementado em ``sage/misc/interpreter.py``.)
 
 Você pode colar código tabulado com muitas linhas no Sage desde que
 existam linhas em branco separando blocos de código (isso não é
@@ -130,7 +130,7 @@
 em ``$HOME/.sage/temp/hostname/pid/spyx``. Esses arquivos são
 excluídos quando você encerra o Sage.
 
-Nenhum pré-processador (preparsing) é aplicado em arquivos spyx, por
+Nenhum pré-processamento (preparsing) é aplicado em arquivos spyx, por
 exemplo, ``1/3`` vai resultar em 0 em um arquivo spyx em vez do número
 racional :math:`1/3`. Se ``foo`` é uma função da biblioteca Sage, para
 usá-la em um arquivo spyx importe ``sage.all`` e use ``sage.all.foo``.
@@ -456,10 +456,10 @@
 Dicionários
 ===========
 
-Um dicionário (também chamado as vezes de lista associativa) é um
-mapeamento de objetos "hashable" em objetos arbitrários. (Exemplos de
-objetos "hashable" são strings e números; veja a documentação Python
-em http://docs.python.org/tut/node7.html e
+Um dicionário (também chamado as vezes de lista associativa ou "hash
+table") é um mapeamento de objetos em objetos arbitrários. (Exemplos
+de objetos que admitem uma lista associativa são strings e números;
+veja a documentação Python em http://docs.python.org/tut/node7.html e
 http://docs.python.org/lib/typesmapping.html para detalhes).
 
 ::
@@ -502,7 +502,7 @@
 Conjuntos
 =========
 
-O Python possui um tipo set (conjuntos) nativo. O principal recurso
+O Python possui um tipo de conjuntos (set) nativo. O principal recurso
 que ele oferece é a rápida verificação se um objeto está ou não em um
 conjunto, juntamente com as operações comuns em conjuntos.
 
diff --git a/doc/pt/tutorial/sagetex.rst b/doc/pt/tutorial/sagetex.rst
--- a/doc/pt/tutorial/sagetex.rst
+++ b/doc/pt/tutorial/sagetex.rst
@@ -88,14 +88,14 @@
 que tudo que foi calculado, incluindo os gráficos, foi incluído em seu
 documento.
 
-As macros utilizadas acima devem ser fáceis de entender. Um
-environment ``sageblock`` insere código "verbatim" (exatamente como é
-digitado) e também executa o código quando você executa o Sage. Quando
-você insere ``\sage{foo}``, é incluído em seu documento o resultado
-que você obteria executando ``latex(foo)`` no Sage. Comandos para
-fazer gráficos são um pouco mais complicados, mas em sua forma mais
-simples, ``\sageplot{foo}`` insere a imagem que você obtêm usando
-``foo.save('filename.eps')``.
+As funções (macros em inglês) utilizadas acima devem ser fáceis de
+entender. Um ambiente ``sageblock`` insere código "verbatim"
+(exatamente como é digitado) e também executa o código quando você
+executa o Sage. Quando você insere ``\sage{foo}``, é incluído em seu
+documento o resultado que você obteria executando ``latex(foo)`` no
+Sage. Comandos para fazer gráficos são um pouco mais complicados, mas
+em sua forma mais simples, ``\sageplot{foo}`` insere a imagem que você
+obtêm usando ``foo.save('filename.eps')``.
 
 Em geral, a rotina é a seguinte:
 
diff --git a/doc/pt/tutorial/tour_advanced.rst b/doc/pt/tutorial/tour_advanced.rst
--- a/doc/pt/tutorial/tour_advanced.rst
+++ b/doc/pt/tutorial/tour_advanced.rst
@@ -84,7 +84,7 @@
 funcionalidade para curvas elípticas do PARI, acesso aos dados da base
 de dados Cremona (isso requer um pacote adicional), os recursos do
 mwrank, isto é, "2-descends" com cálculos do grupo de Mordell-Weil
-completo, o algoritmo SEA (singla em inglês), cálculo de todas as
+completo, o algoritmo SEA (sigla em inglês), cálculo de todas as
 isogenias, bastante código novo para curvas sobre :math:`\QQ`, e parte
 do software "algebraic descent" de Denis Simons.
 
@@ -98,7 +98,7 @@
    .. math::  y^2+a_1xy+a_3y=x^3+a_2x^2+a_4x+a_6,
 
 
-   onde os :math:`a_i`'s são coagidos para os parentes de :math:`a_1`.
+   onde os :math:`a_i`'s são coagidos para a família de :math:`a_1`.
    Se todos os :math:`a_i` possuem parente :math:`\ZZ`, então eles são
    coagidos para :math:`\QQ`.
 
diff --git a/doc/pt/tutorial/tour_assignment.rst b/doc/pt/tutorial/tour_assignment.rst
--- a/doc/pt/tutorial/tour_assignment.rst
+++ b/doc/pt/tutorial/tour_assignment.rst
@@ -81,10 +81,9 @@
     sage: numerical_approx(pi, prec=200)
     3.1415926535897932384626433832795028841971693993751058209749
 
-O Python é uma linguagem "dinâmicamente digitada" (dynamically typed),
-portanto o valor referido por cada variável possui um tipo associado a
-ele, mas uma variável pode possuir valores de qualquer tipo em
-determinado escopo:
+O Python é uma linguagem de tipagem dinâmica, portanto o valor
+referido por cada variável possui um tipo associado a ele, mas uma
+variável pode possuir valores de qualquer tipo em determinado escopo:
 
 ::
 
@@ -98,9 +97,9 @@
     sage: type(a)
     <type 'str'>
 
-A linguagem de programação C, que é "estaticamente digitada"
-(statically typed), é muito diferente; uma variável que foi declarada
-como int pode apenas armazenar um int em seu escopo.
+A linguagem de programação C, que é de tipagem estática , é muito
+diferente; uma variável que foi declarada como int pode apenas
+armazenar um int em seu escopo.
 
 Uma potencial fonte de confusão em Python é que um inteiro literal que
 começa com zero é tratado como um número octal, isto é, um número na
diff --git a/doc/pt/tutorial/tour_coercion.rst b/doc/pt/tutorial/tour_coercion.rst
--- a/doc/pt/tutorial/tour_coercion.rst
+++ b/doc/pt/tutorial/tour_coercion.rst
@@ -3,11 +3,11 @@
 .. _section-coercion:
 
 ============================
-Parentes, Conversão e Coação
+Famílias, Conversão e Coação
 ============================
 
 Esta seção pode parecer mais técnica do que as anteriores, mas
-acreditamos que é importante entender o significado de parentes e
+acreditamos que é importante entender o significado de famílias e
 coação de modo a usar anéis e outras estruturas algébricas no Sage de
 forma efetiva e eficiente.
 
@@ -25,8 +25,8 @@
 ``__mul__``, obviamente garantindo que os axiomas de anel são
 verificados.
 
-Como o Python é uma linguagem "strongly typed" (ainda que "dynamically
-typed"), poderia-se, pelo menos a princípio, esperar-se que fosse
+Como o Python é uma linguagem de tipagem forte (ainda que de tipagem
+dinâmica), poderia-se, pelo menos a princípio, esperar-se que fosse
 implementado em Python uma classe para cada anel. No final das contas,
 o Python contém um tipo ``<int>`` para os inteiros, um tipo
 ``<float>`` para os reais, e assim por diante. Mas essa estratégia
@@ -87,7 +87,7 @@
     Univariate Polynomial Ring in c over Integer Ring (using NTL)
 
 
-Parentes e Categorias
+Famílias e Categorias
 ---------------------
 
 De forma similar à hierarquia de classes em Python voltada para
@@ -137,10 +137,9 @@
 gerais independentemente de uma implementação específica nas
 categorias.
 
-Estruturas parentes em Sage são supostamente objetos únicos em Python.
-Por exemplo, uma vez que um anel de polinômios sobre um certo anel
-base e com uma certa lista de geradores é criada, o resultado é
-arquivado:
+Estruturas da mesma família em Sage são supostamente objetos únicos em
+Python. Por exemplo, uma vez que um anel de polinômios sobre um certo anel
+base e com uma certa lista de geradores é criada, o resultado é arquivado:
 
 ::
 
@@ -163,7 +162,7 @@
     sage: isinstance(M, RingElement)
     True
 
-Enquanto *parentes* são únicos, elementos iguais de um parente em Sage
+Enquanto *famílias* são únicas, elementos iguais de uma família em Sage
 não são necessariamente idênticos. Isso contrasta com o comportamento
 do Python para alguns (embora não todos) inteiros:
 
@@ -177,7 +176,7 @@
     False
 
 É importante observar que elementos de anéis diferentes em geral não
-podem ser distinguidos pelos seus tipos, mas sim por seus parentes:
+podem ser distinguidos pelos seus tipos, mas sim por sua família:
 
 ::
 
@@ -203,7 +202,7 @@
 O leitor pode conhecer as noções de *conversão de tipo* e *coação de
 tipo* como na linguagem C, por exemplo. Existem noções de *conversão*
 e *coação* em Sage também. Mas as noções em Sage são centradas em
-*parentes*, não em tipos. Então, por favor não confunda conversão de
+*família*, não em tipos. Então, por favor não confunda conversão de
 tipo em C com conversão em Sage!
 
 Aqui se encontra uma breve apresentação. Para uma descrição detalhada
@@ -227,12 +226,12 @@
   permitidas. O elemento neutro da multiplicação existe em todos os
   corpos e em vários anéis, e eles devem ser todos iguais.
 
-O Sage faz uma concessão. Se ``P1`` e ``P2`` são estruturas parentes e
-``p1`` é um elemento de ``P1``, então o usuário pode explicitamente
-perguntar por uma interpretação de ``p1`` em ``P2``. Isso pode não
-fazer sentido em todos os casos ou não estar definido para todos os
-elementos de ``P1``, e fica a cargo do usuário assegurar que isso faz
-sentido. Nos referimos a isso como **conversão**:
+O Sage faz uma concessão. Se ``P1`` e ``P2`` são estruturas da mesma família
+e ``p1`` é um elemento de ``P1``, então o usuário pode explicitamente
+perguntar por uma interpretação de ``p1`` em ``P2``. Isso pode não fazer
+sentido em todos os casos ou não estar definido para todos os elementos de
+``P1``, e fica a cargo do usuário assegurar que isso faz sentido. Nos
+referimos a isso como **conversão**:
 
 ::
 
@@ -283,7 +282,7 @@
     sage: R2(y)
     y
 
-Se não existir homomorfismo de anel que preserve nomes, coerção não é
+Se não existir homomorfismo de anel que preserve nomes, coação não é
 definida. Todavia, conversão pode ainda ser possível, a saber,
 mapeando geradores de anel de acordo com sua posição da lista de
 geradores:
@@ -309,7 +308,7 @@
 Se houver coação, ela será usada para comparar elementos de anéis
 diferentes ou fazer aritmética. Isso é frequentemente conveniente, mas
 o usuário deve estar ciente que estender a relação ``==`` além das
-fronteiras de parentes diferentes pode facilmente resultar em 
+fronteiras de famílias diferentes pode facilmente resultar em 
 problemas. Por exemplo, enquanto ``==`` é supostamente uma relação de
 equivalência sobre os elementos de *um* anel, isso não é
 necessariamente o caso se anéis *diferentes* estão envolvidos. Por
@@ -360,7 +359,7 @@
     sage: 1/10^200+1/10^100 == 1/10^100
     False
 
-Quando se compara elementos de dois parentes ``P1`` e ``P2``, é
+Quando se compara elementos de duas famílias ``P1`` e ``P2``, é
 possível que não haja coação entre os dois anéis, mas existe uma
 escolha canônica de um parente ``P3`` de modo que tanto ``P1`` como
 ``P2`` são coagidos em ``P3``. Nesse caso, coação vai ocorrer também.
@@ -381,7 +380,7 @@
 Note que a princípio o resultado deveria também fazer sentido no
 corpo de frações de ``ZZ['x']``. Todavia, o Sage tenta escolher um
 parente *canônico* comum que parece ser o mais natural (``QQ['x']`` no
-nosso exemplo). Se vários potenciais parentes comuns parecem
+nosso exemplo). Se várias famílias potencialmente comuns parecem
 igualmente naturais, o Sage *não* vai escolher um deles
 aleatoriamente. Os mecanismos sobre os quais essa escolha se baseia é
 explicado em um `arquivo tutorial
@@ -401,5 +400,5 @@
 A razão é que o Sage não escolhe um dos potenciais candidatos
 ``QQ['x']['y']``, ``QQ['y']['x']``, ``QQ['x','y']`` ou
 ``QQ['y','x']``, porque todas essas estruturas combinadas em pares
-diferentes parecem ser parentes comuns naturais, e não existe escolha
+diferentes parecem ser de famílias comuns naturais, e não existe escolha
 canônica aparente.
