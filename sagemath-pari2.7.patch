From f26a0a0136b0067e12b05c207e0939ba5654a4ee Mon Sep 17 00:00:00 2001
From: Jeroen Demeyer <jdemeyer@cage.ugent.be>
Date: Mon, 05 May 2014 08:27:34 +0000
Subject: Upgrade to PARI-2.7.1

diff --git a/src/doc/de/tutorial/interfaces.rst b/src/doc/de/tutorial/interfaces.rst
index 9ace22d..9f79b8f 100644
--- a/src/doc/de/tutorial/interfaces.rst
+++ b/src/doc/de/tutorial/interfaces.rst
@@ -135,7 +135,7 @@ Dinge mit ihr berechnen.
     sage: e.elltors()
     [1, [], []]
     sage: e.ellglobalred()
-    [10351, [1, -1, 0, -1], 1]
+    [10351, [1, -1, 0, -1], 1, [11, 1; 941, 1], [[1, 5, 0, 1], [1, 5, 0, 1]]]
     sage: f = e.ellchangecurve([1,-1,0,-1])
     sage: f[:5]
     [1, -1, 0, 4, 3]
diff --git a/src/doc/de/tutorial/tour_advanced.rst b/src/doc/de/tutorial/tour_advanced.rst
index b5fff8e..9308ac7 100644
--- a/src/doc/de/tutorial/tour_advanced.rst
+++ b/src/doc/de/tutorial/tour_advanced.rst
@@ -359,12 +359,12 @@ Nun berechnen wir mehrere Invarianten von ``G``:
 
     sage: G.gens()
     (Dirichlet character modulo 20 of conductor 4 mapping 11 |--> -1, 17 |--> 1,
-    Dirichlet character modulo 20 of conductor 5 mapping 11 |--> 1, 17 |--> -i)
+    Dirichlet character modulo 20 of conductor 5 mapping 11 |--> 1, 17 |--> i)
 
     sage: G.unit_gens()
     (11, 17)
     sage: G.zeta()
-    -i
+    i
     sage: G.zeta_order()
     4
 
diff --git a/src/doc/en/bordeaux_2008/nf_galois_groups.rst b/src/doc/en/bordeaux_2008/nf_galois_groups.rst
index c67867b..4061d96 100644
--- a/src/doc/en/bordeaux_2008/nf_galois_groups.rst
+++ b/src/doc/en/bordeaux_2008/nf_galois_groups.rst
@@ -311,7 +311,7 @@ ideal classes containing :math:`(5,\sqrt{-30})` and
     sage: category(C)
     Category of groups
     sage: C.gens()
-    (Fractional ideal class (5, a), Fractional ideal class (3, a))
+    (Fractional ideal class (2, a), Fractional ideal class (3, a))
 
 
 Arithmetic in the class group
@@ -328,17 +328,17 @@ means "the product of the 0th and 1st generators of the class group
     sage: K.<a> = QuadraticField(-30)
     sage: C = K.class_group()
     sage: C.0
-    Fractional ideal class (5, a)
+    Fractional ideal class (2, a)
     sage: C.0.ideal()
-    Fractional ideal (5, a)
+    Fractional ideal (2, a)
     sage: I = C.0 * C.1
     sage: I
-    Fractional ideal class (2, a)
+    Fractional ideal class (5, a)
 
 
 Next we find that the class of the fractional ideal
 :math:`(2,\sqrt{-30}+4/3)` is equal to the ideal class
-:math:`I`.
+:math:`C.0`.
 
 .. link
 
@@ -348,7 +348,7 @@ Next we find that the class of the fractional ideal
     sage: J = C(A)
     sage: J
     Fractional ideal class (2/3, 1/3*a)
-    sage: J == I
+    sage: J == C.0
     True
 
 
diff --git a/src/doc/en/tutorial/interfaces.rst b/src/doc/en/tutorial/interfaces.rst
index b1dc175..0d3c598 100644
--- a/src/doc/en/tutorial/interfaces.rst
+++ b/src/doc/en/tutorial/interfaces.rst
@@ -132,7 +132,7 @@ things about it.
     sage: e.elltors()
     [1, [], []]
     sage: e.ellglobalred()
-    [10351, [1, -1, 0, -1], 1]
+    [10351, [1, -1, 0, -1], 1, [11, 1; 941, 1], [[1, 5, 0, 1], [1, 5, 0, 1]]]
     sage: f = e.ellchangecurve([1,-1,0,-1])
     sage: f[:5]
     [1, -1, 0, 4, 3]
diff --git a/src/doc/en/tutorial/tour_advanced.rst b/src/doc/en/tutorial/tour_advanced.rst
index 5069d4b..32717e4 100644
--- a/src/doc/en/tutorial/tour_advanced.rst
+++ b/src/doc/en/tutorial/tour_advanced.rst
@@ -357,12 +357,12 @@ We next compute several invariants of ``G``:
 
     sage: G.gens()
     (Dirichlet character modulo 20 of conductor 4 mapping 11 |--> -1, 17 |--> 1,
-    Dirichlet character modulo 20 of conductor 5 mapping 11 |--> 1, 17 |--> -i)
+    Dirichlet character modulo 20 of conductor 5 mapping 11 |--> 1, 17 |--> i)
 
     sage: G.unit_gens()
     (11, 17)
     sage: G.zeta()
-    -i
+    i
     sage: G.zeta_order()
     4
 
diff --git a/src/doc/fr/tutorial/interfaces.rst b/src/doc/fr/tutorial/interfaces.rst
index 147fd49..e420350 100644
--- a/src/doc/fr/tutorial/interfaces.rst
+++ b/src/doc/fr/tutorial/interfaces.rst
@@ -133,7 +133,7 @@ calculs avec.
     sage: e.elltors()
     [1, [], []]
     sage: e.ellglobalred()
-    [10351, [1, -1, 0, -1], 1]
+    [10351, [1, -1, 0, -1], 1, [11, 1; 941, 1], [[1, 5, 0, 1], [1, 5, 0, 1]]]
     sage: f = e.ellchangecurve([1,-1,0,-1])
     sage: f[:5]
     [1, -1, 0, 4, 3]
diff --git a/src/doc/fr/tutorial/tour_advanced.rst b/src/doc/fr/tutorial/tour_advanced.rst
index fbaa3ac..92e300d 100644
--- a/src/doc/fr/tutorial/tour_advanced.rst
+++ b/src/doc/fr/tutorial/tour_advanced.rst
@@ -357,12 +357,12 @@ Nous calculons ensuite diffÃ©rents invariants de ``G``:
 
     sage: G.gens()
     (Dirichlet character modulo 20 of conductor 4 mapping 11 |--> -1, 17 |--> 1,
-    Dirichlet character modulo 20 of conductor 5 mapping 11 |--> 1, 17 |--> -i)
+    Dirichlet character modulo 20 of conductor 5 mapping 11 |--> 1, 17 |--> i)
 
     sage: G.unit_gens()
     (11, 17)
     sage: G.zeta()
-    -i
+    i
     sage: G.zeta_order()
     4
 
diff --git a/src/doc/ru/tutorial/interfaces.rst b/src/doc/ru/tutorial/interfaces.rst
index 8baa52c..497707b 100644
--- a/src/doc/ru/tutorial/interfaces.rst
+++ b/src/doc/ru/tutorial/interfaces.rst
@@ -128,7 +128,7 @@ Sage Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÑ‚ Ð¡-Ð±Ð¸Ð±Ð»Ð¸Ð¾Ñ‚ÐµÐºÑƒ PARI, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¿Ð¾Ð´Ð´ÐµÑ€Ð
     sage: e.elltors()
     [1, [], []]
     sage: e.ellglobalred()
-    [10351, [1, -1, 0, -1], 1]
+    [10351, [1, -1, 0, -1], 1, [11, 1; 941, 1], [[1, 5, 0, 1], [1, 5, 0, 1]]]
     sage: f = e.ellchangecurve([1,-1,0,-1])
     sage: f[:5]
     [1, -1, 0, 4, 3]
diff --git a/src/doc/ru/tutorial/tour_advanced.rst b/src/doc/ru/tutorial/tour_advanced.rst
index d9ab2c5..b7a64a7 100644
--- a/src/doc/ru/tutorial/tour_advanced.rst
+++ b/src/doc/ru/tutorial/tour_advanced.rst
@@ -322,12 +322,12 @@ Sage Ð¼Ð¾Ð¶ÐµÑ‚ Ð²Ñ‹Ñ‡Ð¸ÑÐ»Ð¸Ñ‚ÑŒ Ñ‚Ð¾Ñ€Ð¾Ð¸Ð´Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Ð¸Ð´ÐµÐ°Ð» Ð½ÐµÐ¿Ð»Ð
 
     sage: G.gens()
     (Dirichlet character modulo 20 of conductor 4 mapping 11 |--> -1, 17 |--> 1,
-    Dirichlet character modulo 20 of conductor 5 mapping 11 |--> 1, 17 |--> -i)
+    Dirichlet character modulo 20 of conductor 5 mapping 11 |--> 1, 17 |--> i)
 
     sage: G.unit_gens()
     (11, 17)
     sage: G.zeta()
-    -i
+    i
     sage: G.zeta_order()
     4
 
diff --git a/src/ext/pari/dokchitser/computel.gp b/src/ext/pari/dokchitser/computel.gp
index f7f5d66..9768874 100644
--- a/src/ext/pari/dokchitser/computel.gp
+++ b/src/ext/pari/dokchitser/computel.gp
@@ -169,7 +169,7 @@ errprint(x)=if(type(x)=="t_COMPLEX",x=abs(x));
 
 {
 gammaseries(z0,terms,
-    Avec,Bvec,Qvec,n,z,err,res,c0,c1,c2,c3,sinser,reflect,digits,srprec,negint)=
+    Avec,Bvec,Qvec,n,z,err,res,c0,c1,c2,c3,sinser,reflect,digits_,srprec,negint)=
   srprec=default(seriesprecision);
   if (z0==real(round(z0)),z0=real(round(z0)));    \\ you don't want to know
   negint=type(z0)=="t_INT" && z0<=0;              \\ z0 is a pole
@@ -181,17 +181,17 @@ gammaseries(z0,terms,
   if (z0==1, res=gamma(1+x),
   if (z0==2, res=gamma(1+x)*(1+x),
   \\ otherwise use Luke's rational approximations for psi(x)
-  digits=default(realprecision);   \\ save working precision
-  default(realprecision,digits+3);  \\   and work with 3 digits more
+  digits_=default(realprecision);   \\ save working precision
+  default(realprecision,digits_+3);  \\   and work with 3 digits more
   reflect=real(z0)<0.5;               \\ left of 1/2 use reflection formula
   if (reflect,z0=1-z0);
-  z=subst(Ser(precision(1.*z0,digits+3)+X),X,x);
+  z=subst(Ser(precision(1.*z0,digits_+3)+X),X,x);
     \\ work with z0+x as a variable gives power series in X as an answer
   Avec=[1,(z+6)/2,(z^2+82*z+96)/6,(z^3+387*z^2+2906*z+1920)/12];
   Bvec=[1,4,8*z+28,14*z^2+204*z+310];
   Qvec=[0,0,0,Avec[4]/Bvec[4]];
   n=4;
-  until(err<0.1^(digits+1.5),         \\ Luke's recursions for psi(x)
+  until(err<0.1^(digits_+1.5),         \\ Luke's recursions for psi(x)
     c1=(2*n-1)*(3*(n-1)*z+7*n^2-9*n-6);
     c2=-(2*n-3)*(z-n-1)*(3*(n-1)*z-7*n^2+19*n-4);
     c3=(2*n-1)*(n-3)*(z-n)*(z-n-1)*(z+n-4);
@@ -208,7 +208,7 @@ gammaseries(z0,terms,
     if (negint,sinser[1]=0);          \\ taking slight care at integers<0
     res=subst(Pi/res/Ser(sinser),x,-x);
   );
-  default(realprecision,digits);
+  default(realprecision,digits_);
   )))));
   default(seriesprecision,srprec);
   res;
@@ -231,10 +231,10 @@ fullgamma(ss) = if(ss!=lastFGs,lastFGs=ss;\
 
 {
 fullgammaseries(ss,extraterms,
-    digits,GSD)=
-  digits=default(realprecision);
+    digits_,GSD)=
+  digits_=default(realprecision);
   if (lastFGSs!=ss || lastFGSterms!=extraterms,
-    GSD=sum(j=1,numpoles,(abs((ss+poles[j])/2-round(real((ss+poles[j])/2)))<10^(2-digits)) * PoleOrders[j] )+extraterms;
+    GSD=sum(j=1,numpoles,(abs((ss+poles[j])/2-round(real((ss+poles[j])/2)))<10^(2-digits_)) * PoleOrders[j] )+extraterms;
     lastFGSs=ss;
     lastFGSterms=extraterms;
     lastFGSval=subst(prod(j=1,length(gammaV),gammaseries((ss+gammaV[j])/2,GSD)),x,S/2);
diff --git a/src/ext/pari/simon/ell.gp b/src/ext/pari/simon/ell.gp
index 0d130f4..acd807c 100644
--- a/src/ext/pari/simon/ell.gp
+++ b/src/ext/pari/simon/ell.gp
@@ -84,6 +84,11 @@
 
 */
 
+
+nf_scalar_or_multable_to_alg(nf, z) = {
+  if (type(z) == "t_MAT", nfbasistoalg(nf, z[,1]), z);
+}
+
 {
 \\
 \\ Usual global variables
@@ -505,7 +510,7 @@ if( DEBUGLEVEL_ell >= 5, print("     end of nfissquaremodp"));
 if( DEBUGLEVEL_ell >= 5, print("     end of nfissquaremodp"));
     return(0));
   if( valap,
-    zlog = ideallog(nf,a*(nfbasistoalg(nf,p[5])/p.p)^valap,zinit)
+    zlog = ideallog(nf,a*(nf_scalar_or_multable_to_alg(nf,p[5])/p.p)^valap,zinit)
   ,
     zlog = ideallog(nf,a,zinit));
   for( i = 1, #zinit[2][2],
@@ -533,7 +538,7 @@ if( DEBUGLEVEL_ell >= 5, print("     end of nfissquaremodpq"));
 if( DEBUGLEVEL_ell >= 5, print("     end of nfissquaremodpq"));
     return(0));
   zinit = idealstar(nf,idealpow(nf,p,q-vala),2);
-  zlog = ideallog(nf,a*nfbasistoalg(nf,p[5]/2)^vala,zinit);
+  zlog = ideallog(nf,a*nf_scalar_or_multable_to_alg(nf,p[5]/2)^vala,zinit);
   for( i = 1, #zinit[2][2],
     if( !(zinit[2][2][i]%2) && (zlog[i]%2),
 if( DEBUGLEVEL_ell >= 5, print("     end of nfissquaremodpq"));
@@ -556,7 +561,7 @@ if( DEBUGLEVEL_ell >= 5, print("     end of nfsqrtmodpq"));
     return(0));
 if( f%2, error("nfsqrtmodpq: a is not a square, odd valuation"));
   a = nfalgtobasis(nf,a);
-  if( f, aaa = nfeltpow(nf,nfeltdiv(nf,a,p[5]/p.p),f), aaa = a);
+  if( f, aaa = nfeltpow(nf,nfeltdiv(nf,a,nf_scalar_or_multable_to_alg(nf,p[5]/p.p)),f), aaa = a);
   p_hnf = idealhnf(nf,p);
   p_ini = nfmodprinit(nf,p);
 if( DEBUGLEVEL_ell >= 5, print("     p_hnf = ",p_hnf));
@@ -680,7 +685,7 @@ if( DEBUGLEVEL_ell >= 5, print("fin de nflemma7"));
     if( q > 2*v,
 if( DEBUGLEVEL_ell >= 5, print("fin de nflemma7"));
       return(-1));
-    if( nfissquaremodpq(nf,gx*nfbasistoalg(nf,p[5]/2)^lambda,p,q),
+    if( nfissquaremodpq(nf,gx*nf_scalar_or_multable_to_alg(nf,p[5]/2)^lambda,p,q),
 if( DEBUGLEVEL_ell >= 5, print("fin de nflemma7"));
       return(1))
   ,
@@ -694,7 +699,7 @@ if( DEBUGLEVEL_ell >= 5, print("fin de nflemma7"));
     if( q > 2*v,
 if( DEBUGLEVEL_ell >= 5, print("fin de nflemma7"));
       return(-1));
-    if( nfissquaremodpq(nf,gx*nfbasistoalg(nf,p[5]/2)^lambda,p,q),
+    if( nfissquaremodpq(nf,gx*nf_scalar_or_multable_to_alg(nf,p[5]/2)^lambda,p,q),
 if( DEBUGLEVEL_ell >= 5, print("fin de nflemma7"));
       return(0))
   );
@@ -772,7 +777,7 @@ if( DEBUGLEVEL_ell >= 4, print("    end of nfqp_solublebig"));
   cont = idealval(nf,polcoeff(pol,0),p);
   for( i = 1, deg,
     if( cont, cont = min(cont,idealval(nf,polcoeff(pol,i),p))));
-  if( cont, pi = nfbasistoalg(nf,p[5]/p.p));
+  if( cont, pi = nf_scalar_or_multable_to_alg(nf,p[5]/p.p));
   if( cont > 1, pol *= pi^(2*(cont\2)));
 
 \\ On essaye des valeurs de x au hasard
@@ -984,7 +989,7 @@ if( DEBUGLEVEL_ell >= 2, print("  Algorithm of 2-descent via isogenies"));
 if( DEBUGLEVEL_ell >= 3, print("   starting bnfell2descent_viaisog"));
   if( variable(bnf.pol) != 'y,
     error("bnfell2descent_viaisog: the variable of the number field must be y"));
-  ell = ellinit(Mod(lift(ell),bnf.pol),1);
+  ell = ellinit(Mod(lift(ell),bnf.pol));
 
   if( ell.disc == 0,
     error("bnfell2descent_viaisog: singular curve !!"));
@@ -1231,7 +1236,7 @@ if( DEBUGLEVEL_ell >= 4, print("    bbbnf.clgp = ",bbbnf.clgp));
   SL = idealfactor(bbbnf,SL1)[,1]~;
   sunL = bnfsunit(bbbnf,SL);
   fondsunL = concat(bbbnf.futu,vector(#sunL[1],i,nfbasistoalg(bbbnf,sunL[1][i])));
-  normfondsunL = norm(rnfeltabstorel( rrrnf,fondsunL));
+  normfondsunL = vector(#fondsunL, i, norm(rnfeltabstorel(rrrnf,fondsunL[i])));
   SK = idealfactor(bnf,idealnorm(bbbnf,SL1))[,1]~;
   sunK = bnfsunit(bnf,SK);
   fondsunK = concat(bnf.futu,vector(#sunK[1],i,nfbasistoalg(bnf,sunK[1][i])));
@@ -1500,7 +1505,7 @@ if( DEBUGLEVEL_ell >= 4, print("    starting bnfell2descent_gen"));
   nf = bnf.nf;
   unnf = Mod(1,nf.pol);
   ellnf = ell*unnf;
-  if( #ellnf <= 5, ellnf = ellinit(ellnf,1));
+  if( #ellnf <= 5, ellnf = ellinit(ellnf));
 
   A = ellnf.a2; if( DEBUGLEVEL_ell >= 2, print("  A = ",A));
   B = ellnf.a4; if( DEBUGLEVEL_ell >= 2, print("  B = ",B));
@@ -1887,7 +1892,8 @@ if( DEBUGLEVEL_ell >= 4, print("    end of bnfell2descent_gen"));
 local(urst,urst1,den,factden,eqtheta,rnfeq,bbnf,ext,rang,f);
 
 if( DEBUGLEVEL_ell >= 3, print("   starting bnfellrank"));
-  if( #ell <= 5, ell = ellinit(ell,1));
+  if( #ell < 5, ell = ellinit(ell));
+  ell = vector(5, i, ell[i]);
 
 \\ removes the coefficients a1 and a3
   urst = [1,0,0,0];
diff --git a/src/ext/pari/simon/ellQ.gp b/src/ext/pari/simon/ellQ.gp
index c114534..6861066 100644
--- a/src/ext/pari/simon/ellQ.gp
+++ b/src/ext/pari/simon/ellQ.gp
@@ -117,7 +117,7 @@
   Courbes de la forme : k*y^2 = x^3+A*x^2+B*x+C
   sans 2-torsion, A,B,C entiers.
   gp > bnf = bnfinit(x^3+A*x^2+B*x+C);
-  gp > ell = ellinit([0,A,0,B,C],1);
+  gp > ell = ellinit([0,A,0,B,C]);
   gp > rank = ell2descent_gen(ell,bnf,k);
 
   Courbes avec #E[2](Q) >= 2 :
@@ -833,7 +833,7 @@ if( DEBUGLEVEL_ell >= 4, print("    end of LS2localimage"));
 \\ returns all the points Q on ell such that 2Q = P.
 my(pol2,ratroots,half,x2,y2,P2);
 
-  if(#ell < 13, ell=ellinit(ell,1));
+  if(#ell < 13, ell=ellinit(ell));
 
   pol2 = Pol([4,ell.b2,2*ell.b4,ell.b6]); \\ 2-division polynomial
 
@@ -880,7 +880,7 @@ if( DEBUGLEVEL_ell >= 3, print("   E[2] = ",tors2));
 my(torseven,P2);
 
 if( DEBUGLEVEL_ell >= 4, print("    computing the 2^n-torsion"));
-  if(#ell < 13, ell=ellinit(ell,1));
+  if(#ell < 13, ell=ellinit(ell));
   torseven = elltors2(ell);
 
   while( torseven[1] != 1,
@@ -976,7 +976,7 @@ if( DEBUGLEVEL_ell >= 5, print("     ell=",ell));
   d = #listgen;
   if( d == 0, return([]));  
 
-  if( #ell < 13, ell = ellinit(ell,1));
+  if( #ell < 13, ell = ellinit(ell));
 
   if( K != 1,
     if( ell.a1 != 0 || ell.a3 != 0, error(" ellredgen: a1*a3 != 0"));
@@ -1323,7 +1323,7 @@ my(A,B,C,polrel,polprime,ttheta,badprimes,S,LS2,selmer,rootapprox,p,pp,locimage,
 
 if( DEBUGLEVEL_ell >= 4, print("    starting ell2descent_gen"));
 
-  if( #ell < 13, ell = ellinit(ell,1));
+  if( #ell < 13, ell = ellinit(ell));
 
   if( ell.a1 != 0 || ell.a3 != 0,
     error(" ell2descent_gen: the curve is not of the form [0,a,0,b,c]"));
@@ -1579,7 +1579,7 @@ if( DEBUGLEVEL_ell >= 4, print("    end of ell2descent_gen"));
 my(urst,urst1,den,eqell,tors2,bnf,rang,time1);
 
 if( DEBUGLEVEL_ell >= 3, print("   starting ellrank"));
-  if( #ell < 13, ell = ellinit(ell,1));
+  if( #ell < 13, ell = ellinit(ell));
 
 \\ kill the coefficients a1 and a3
   urst = [1,0,0,0];
@@ -1915,7 +1915,7 @@ if( DEBUGLEVEL_ell >= 4, print("    end of ellcount"));
 my(P,Pfact,tors,listpointstriv,KS2prod,KS2gen,listpoints,pointgen,n1,n2,certain,apinit,bpinit,np1,np2,listpoints2,aux1,aux2,certainp,rang,strange);
 
 if( DEBUGLEVEL_ell >= 2, print("  Algorithm of 2-descent via isogenies"));
-  if( #ell < 13, ell = ellinit(ell,1));
+  if( #ell < 13, ell = ellinit(ell));
 
   if( ell.disc == 0,
     error(" ell2descent_viaisog: singular curve !!"));
diff --git a/src/sage/calculus/calculus.py b/src/sage/calculus/calculus.py
index bb6660a..b0f24c0 100644
--- a/src/sage/calculus/calculus.py
+++ b/src/sage/calculus/calculus.py
@@ -732,13 +732,13 @@ def nintegral(ex, x, a, b,
     to high precision::
 
         sage: gp.eval('intnum(x=17,42,exp(-x^2)*log(x))')
-        '2.565728500561051482917356396 E-127'        # 32-bit
-        '2.5657285005610514829173563961304785900 E-127'    # 64-bit
+        '2.565728500561051482917356396 E-127'            # 32-bit
+        '2.5657285005610514829173563961304785900 E-127'  # 64-bit
         sage: old_prec = gp.set_real_precision(50)
         sage: gp.eval('intnum(x=17,42,exp(-x^2)*log(x))')
         '2.5657285005610514829173563961304785900147709554020 E-127'
         sage: gp.set_real_precision(old_prec)
-        50
+        57
 
     Note that the input function above is a string in PARI syntax.
     """
diff --git a/src/sage/functions/exp_integral.py b/src/sage/functions/exp_integral.py
index 182e80c..69f0e0d 100644
--- a/src/sage/functions/exp_integral.py
+++ b/src/sage/functions/exp_integral.py
@@ -1493,10 +1493,10 @@ def exponential_integral_1(x, n=0):
 
         sage: exponential_integral_1(2)
         0.0489005107080611
-        sage: exponential_integral_1(2,4)  # abs tol 1e-18
+        sage: exponential_integral_1(2, 4)  # abs tol 1e-18
         [0.0489005107080611, 0.00377935240984891, 0.000360082452162659, 0.0000376656228439245]
-        sage: exponential_integral_1(40,5)
-        [1.03677326145166e-19, 2.22854325868847e-37, 6.33732515501151e-55, 2.02336191509997e-72, 6.88522610630764e-90]
+        sage: exponential_integral_1(40, 5)
+        [0.000000000000000, 2.22854325868847e-37, 6.33732515501151e-55, 2.02336191509997e-72, 6.88522610630764e-90]
         sage: exponential_integral_1(0)
         +Infinity
         sage: r = exponential_integral_1(RealField(150)(1))
@@ -1569,7 +1569,7 @@ def exponential_integral_1(x, n=0):
     if n <= 0:
         # Add extra bits to the input.
         # (experimentally verified -- Jeroen Demeyer)
-        inprec = prec + math.ceil(math.log(2*prec))
+        inprec = prec + 5 + math.ceil(math.log(prec))
         x = RealField(inprec)(x)._pari_()
         return R(x.eint1())
     else:
diff --git a/src/sage/groups/generic.py b/src/sage/groups/generic.py
index ff20df8..cde865e 100644
--- a/src/sage/groups/generic.py
+++ b/src/sage/groups/generic.py
@@ -420,8 +420,7 @@ def bsgs(a, b, bounds, operation='*', identity=None, inverse=None, op=None):
         sage: F.<a> = GF(37^5)
         sage: E = EllipticCurve(F, [1,1])
         sage: P = E.lift_x(a); P
-        (a : 28*a^4 + 15*a^3 + 14*a^2 + 7 : 1)  # 32-bit
-        (a : 9*a^4 + 22*a^3 + 23*a^2 + 30 : 1)  # 64-bit
+        (a : 28*a^4 + 15*a^3 + 14*a^2 + 7 : 1)
 
     This will return a multiple of the order of P::
 
@@ -853,8 +852,8 @@ def discrete_log_lambda(a, base, bounds, operation='*', hash_function=hash):
         sage: F.<a> = GF(37^5)
         sage: E = EllipticCurve(F, [1,1])
         sage: P = E.lift_x(a); P
-        (a : 9*a^4 + 22*a^3 + 23*a^2 + 30 : 1)  # 32-bit
-        (a : 28*a^4 + 15*a^3 + 14*a^2 + 7 : 1)  # 64-bit
+        (a : 28*a^4 + 15*a^3 + 14*a^2 + 7 : 1)  # 32-bit
+        (a : 9*a^4 + 22*a^3 + 23*a^2 + 30 : 1)  # 64-bit
 
     This will return a multiple of the order of P::
 
diff --git a/src/sage/interfaces/gp.py b/src/sage/interfaces/gp.py
index 767c668..6f13f3c 100644
--- a/src/sage/interfaces/gp.py
+++ b/src/sage/interfaces/gp.py
@@ -24,7 +24,7 @@ PARI interpreter)::
 
     sage: E = gp.ellinit([1,2,3,4,5])
     sage: E.ellglobalred()
-    [10351, [1, -1, 0, -1], 1]
+    [10351, [1, -1, 0, -1], 1, [11, 1; 941, 1], [[1, 5, 0, 1], [1, 5, 0, 1]]]
     sage: E.ellan(20)
     [1, 1, 0, -1, -3, 0, -1, -3, -3, -3, -1, 0, 1, -1, 0, -1, 5, -3, 4, 3]
 
@@ -113,7 +113,7 @@ Test error recovery::
     PARI/GP ERROR:
       ***   at top-level: sage[...]=1/0
       ***                          ^--
-      *** _/_: division by zero
+      *** _/_: impossible inverse in gdiv: 0.
 
 AUTHORS:
 
@@ -322,9 +322,16 @@ class Gp(Expect):
 
     get_real_precision = get_precision
 
-    def set_precision(self, prec=None):
+    def set_precision(self, prec):
         """
-        Sets the PARI precision (in decimal digits) for real computations, and returns the old value.
+        Sets the PARI precision (in decimal digits) for real
+        computations, and returns the old value.
+
+        .. NOTE::
+
+            PARI/GP rounds up precisions to the nearest machine word,
+            so the result of :meth:`get_precision` is not always the
+            same as the last value inputted to :meth:`set_precision`.
 
         EXAMPLES::
 
@@ -332,9 +339,9 @@ class Gp(Expect):
             28              # 32-bit
             38              # 64-bit
             sage: gp.get_precision()
-            53
+            57
             sage: gp.set_precision(old_prec)
-            53
+            57
             sage: gp.get_precision()
             28              # 32-bit
             38              # 64-bit
@@ -436,25 +443,23 @@ class Gp(Expect):
             return m - t
         return m
 
-    def set_default(self, var=None, value=None):
+    def set_default(self, var, value):
         """
         Set a PARI gp configuration variable, and return the old value.
 
         INPUT:
 
-        - ``var`` (string, default None) -- the name of a PARI gp
+        - ``var`` (string) -- the name of a PARI gp
           configuration variable.  (See ``gp.default()`` for a list.)
         - ``value`` -- the value to set the variable to.
 
         EXAMPLES::
 
-            sage: old_prec = gp.set_default('realprecision',100); old_prec
-            28              # 32-bit
-            38              # 64-bit
+            sage: old_prec = gp.set_default('realprecision', 110)
             sage: gp.get_default('realprecision')
-            100
-            sage: gp.set_default('realprecision',old_prec)
-            100
+            115
+            sage: gp.set_default('realprecision', old_prec)
+            115
             sage: gp.get_default('realprecision')
             28              # 32-bit
             38              # 64-bit
@@ -463,13 +468,13 @@ class Gp(Expect):
         self._eval_line('default(%s,%s)'%(var,value))
         return old
 
-    def get_default(self, var=None):
+    def get_default(self, var):
         """
         Return the current value of a PARI gp configuration variable.
 
         INPUT:
 
-        - ``var`` (string, default None) -- the name of a PARI gp
+        - ``var`` (string) -- the name of a PARI gp
           configuration variable.  (See ``gp.default()`` for a list.)
 
         OUTPUT:
@@ -808,13 +813,16 @@ class GpElement(ExpectElement):
 
         sage: E = gp('ellinit([1,2,3,4,5])')
         sage: loads(dumps(E)) == E
+        True
+        sage: x = gp.Pi()/3
+        sage: loads(dumps(x)) == x
         False
-        sage: loads(E.dumps())
-        [1, 2, 3, 4, 5, 9, 11, 29, 35, -183, -3429, -10351, 6128487/10351, [-1.618909932267371342378000940, -0.3155450338663143288109995302 - 2.092547096911958607981689447*I, -0.3155450338663143288109995302 + 2.092547096911958607981689447*I]~, 2.780740013766729771063197627, 1.390370006883364885531598814 - 1.068749776356193066159263548*I, 3.109648242324380328550149122 + 1.009741959000000000000000000 E-28*I, 1.554824121162190164275074561 + 1.064374745210273756943885994*I, 2.971915267817909670771647951] # 32-bit
-        [1, 2, 3, 4, 5, 9, 11, 29, 35, -183, -3429, -10351, 6128487/10351, [-1.6189099322673713423780009396072169751, -0.31554503386631432881099953019639151248 - 2.0925470969119586079816894466366945829*I, -0.31554503386631432881099953019639151248 + 2.0925470969119586079816894466366945829*I]~, 2.7807400137667297710631976271813584994, 1.3903700068833648855315988135906792497 - 1.0687497763561930661592635474375038788*I, 3.1096482423243803285501491221965830079 + 2.3509887016445750160000000000000000000 E-38*I, 1.5548241211621901642750745610982915040 + 1.0643747452102737569438859937299427442*I, 2.9719152678179096707716479509361896060] # 64-bit
-        sage: E
-        [1, 2, 3, 4, 5, 9, 11, 29, 35, -183, -3429, -10351, 6128487/10351, [-1.618909932267371342378000940, -0.3155450338663143288109995302 - 2.092547096911958607981689447*I, -0.3155450338663143288109995302 + 2.092547096911958607981689447*I]~, 2.780740013766729771063197627, 1.390370006883364885531598814 - 1.068749776356193066159263548*I, 3.109648242324380328550149122 + 1.009741959 E-28*I, 1.554824121162190164275074561 + 1.064374745210273756943885994*I, 2.971915267817909670771647951] # 32-bit
-        [1, 2, 3, 4, 5, 9, 11, 29, 35, -183, -3429, -10351, 6128487/10351, [-1.6189099322673713423780009396072169751, -0.31554503386631432881099953019639151248 - 2.0925470969119586079816894466366945829*I, -0.31554503386631432881099953019639151248 + 2.0925470969119586079816894466366945829*I]~, 2.7807400137667297710631976271813584994, 1.3903700068833648855315988135906792497 - 1.0687497763561930661592635474375038788*I, 3.1096482423243803285501491221965830079 + 2.350988701644575016 E-38*I, 1.5548241211621901642750745610982915040 + 1.0643747452102737569438859937299427442*I, 2.9719152678179096707716479509361896060]  # 64-bit
+        sage: x
+        1.047197551196597746154214461            # 32-bit
+        1.0471975511965977461542144610931676281  # 64-bit
+        sage: loads(dumps(x))
+        1.047197551196597746154214461            # 32-bit
+        1.0471975511965977461542144610931676281  # 64-bit
 
     The two elliptic curves look the same, but internally the floating
     point numbers are slightly different.
diff --git a/src/sage/lfunctions/dokchitser.py b/src/sage/lfunctions/dokchitser.py
index da6ae49..12e991f 100644
--- a/src/sage/lfunctions/dokchitser.py
+++ b/src/sage/lfunctions/dokchitser.py
@@ -108,7 +108,7 @@ class Dokchitser(SageObject):
         sage: L.taylor_series(1,4)
         0.000000000000000 + 0.305999773834052*z + 0.186547797268162*z^2 - 0.136791463097188*z^3 + O(z^4)
         sage: L.check_functional_equation()
-        6.11218974800000e-18                            # 32-bit
+        6.11218974700000e-18                            # 32-bit
         6.04442711160669e-18                            # 64-bit
 
     RANK 2 ELLIPTIC CURVE:
@@ -125,8 +125,8 @@ class Dokchitser(SageObject):
         sage: L.derivative(1,E.rank())
         1.51863300057685
         sage: L.taylor_series(1,4)
-        2.90759778535572e-20 + (-1.64772676916085e-20)*z + 0.759316500288427*z^2 - 0.430302337583362*z^3 + O(z^4)      # 32-bit
-        -3.11623283109075e-21 + (1.76595961125962e-21)*z + 0.759316500288427*z^2 - 0.430302337583362*z^3 + O(z^4)      # 64-bit
+        2.90760251490292e-20 + (-1.64772944938078e-20)*z + 0.759316500288427*z^2 - 0.430302337583362*z^3 + O(z^4)  # 32-bit
+        -3.11661104824958e-21 + (1.76617394576638e-21)*z + 0.759316500288427*z^2 - 0.430302337583362*z^3 + O(z^4)  # 64-bit
 
     RAMANUJAN DELTA L-FUNCTION:
 
@@ -218,7 +218,9 @@ class Dokchitser(SageObject):
         except AttributeError:
             logfile = None
             # For debugging
-            #logfile = os.path.join(DOT_SAGE, 'dokchitser.log')
+            import os
+            from sage.env import DOT_SAGE
+            logfile = os.path.join(DOT_SAGE, 'dokchitser.log')
             g = sage.interfaces.gp.Gp(script_subdirectory='dokchitser', logfile=logfile)
             g.read('computel.gp')
             self.__gp = g
@@ -484,7 +486,7 @@ class Dokchitser(SageObject):
             sage: E = EllipticCurve('389a')
             sage: L = E.lseries().dokchitser(200)
             sage: L.taylor_series(1,3)
-            6.2240188634103774348273446965620801288836328651973234573133e-73 + (-3.527132447498646306292650465494647003849868770...e-73)*z + 0.75931650028842677023019260789472201907809751649492435158581*z^2 + O(z^3)
+            -9.094...e-82 + (5.1538...e-82)*z + 0.75931650028842677023019260789472201907809751649492435158581*z^2 + O(z^3)
         """
         self.__check_init()
         a = self.__CC(a)
diff --git a/src/sage/libs/pari/decl.pxi b/src/sage/libs/pari/decl.pxi
index 41a8e1a..baa03d5 100644
--- a/src/sage/libs/pari/decl.pxi
+++ b/src/sage/libs/pari/decl.pxi
@@ -16,16 +16,14 @@ AUTHORS:
 
  - Jeroen Demeyer (2010-08-15): big clean up (#9898)
 
+ - Jeroen Demeyer (2014-02-09): upgrade to PARI 2.7 (#15767)
+
 """
 
 include 'sage/ext/cdefs.pxi'
 
-cdef extern from 'setjmp.h':
-    struct __jmp_buf_tag:
-        pass
-    ctypedef __jmp_buf_tag jmp_buf
-    int setjmp (jmp_buf __env)
-    int longjmp (jmp_buf __env, int val)
+cdef extern from '<stdarg.h>':
+    ctypedef void* va_list
 
 ctypedef unsigned long ulong
 
@@ -35,6 +33,46 @@ cdef extern from 'pari/paricfg.h':
 
 cdef extern from 'pari/pari.h':
     ctypedef long* GEN
+    ctypedef char* byteptr
+
+    # Various structures that we don't use in Sage but which need to be
+    # declared, otherwise Cython complains.
+    struct bb_group:
+        pass
+    struct bb_field:
+        pass
+    struct bb_algebra:
+        pass
+    struct qfr_data:
+        pass
+    struct nfmaxord_t:
+        pass
+    struct forcomposite_t:
+        pass
+    struct forpart_t:
+        pass
+    struct forprime_t:
+        pass
+    struct forvec_t:
+        pass
+    struct entree:
+        pass
+    struct gp_context:
+        pass
+    struct pariFILE:
+        pass
+    struct pari_mt:
+        pass
+    struct pari_thread:
+        pass
+    struct pari_timer:
+        pass
+    struct GENbin:
+        pass
+    struct hashentry:
+        pass
+    struct hashtable:
+        pass
 
     # PARI types: these are actually an enum type, but that doesn't
     # matter for Cython.
@@ -49,13 +87,19 @@ cdef extern from 'pari/pari.h':
 
     # parierr.h
 
-    int syntaxer, bugparier, alarmer, openfiler, talker, flagerr, \
-        impl, archer, notfuncer, precer, typeer, consister, user, \
-        errpile, overflower, matinv1, mattype1, arither1, primer1, \
-        invmoder, constpoler, notpoler, redpoler, zeropoler, operi, \
-        operf, gdiver, memer, negexper, sqrter5, noer
+    int e_SYNTAX, e_BUG, \
+        e_ALARM, e_FILE, \
+        e_MISC, e_FLAG, e_IMPL, e_ARCH, e_PACKAGE, e_NOTFUNC, \
+        e_PREC, e_TYPE, e_DIM, e_VAR, e_PRIORITY, e_USER, \
+        e_STACK, e_OVERFLOW, e_DOMAIN, e_COMPONENT, \
+        e_MAXPRIME, \
+        e_CONSTPOL, e_IRREDPOL, e_COPRIME, e_PRIME, e_MODULUS, e_ROOTS0, \
+        e_OP, e_TYPE2, e_INV, \
+        e_MEM, \
+        e_SQRTN, \
+        e_NONE
 
-    int warner, warnprec, warnfile, warnmem
+    int warner, warnprec, warnfile, warnmem, warnuser
 
     # parigen.h
 
@@ -93,20 +137,20 @@ cdef extern from 'pari/pari.h':
 
     # paricast.h
 
-    long    mael2(GEN,long,long)
-    long    mael3(GEN,long,long,long)
-    long    mael4(GEN,long,long,long,long)
-    long    mael5(GEN,long,long,long,long,long)
-    long    mael(GEN,long,long)
-    GEN     gmael1(GEN,long)
-    GEN     gmael2(GEN,long,long)
-    GEN     gmael3(GEN,long,long,long)
-    GEN     gmael4(GEN,long,long,long,long)
-    GEN     gmael5(GEN,long,long,long,long,long)
-    GEN     gmael(GEN,long,long)
-    GEN     gel(GEN,long)
-    GEN     gcoeff(GEN,long,long)
-    long    coeff(GEN,long,long)
+    long    mael2(GEN, long, long)
+    long    mael3(GEN, long, long, long)
+    long    mael4(GEN, long, long, long, long)
+    long    mael5(GEN, long, long, long, long, long)
+    long    mael(GEN, long, long)
+    GEN     gmael1(GEN, long)
+    GEN     gmael2(GEN, long, long)
+    GEN     gmael3(GEN, long, long, long)
+    GEN     gmael4(GEN, long, long, long, long)
+    GEN     gmael5(GEN, long, long, long, long, long)
+    GEN     gmael(GEN, long, long)
+    GEN     gel(GEN, long)
+    GEN     gcoeff(GEN, long, long)
+    long    coeff(GEN, long, long)
 
     # paricom.h
 
@@ -131,11 +175,14 @@ cdef extern from 'pari/pari.h':
     ulong  Fl_add(ulong a, ulong b, ulong p)
     long   Fl_center(ulong u, ulong p, ulong ps2)
     ulong  Fl_div(ulong a, ulong b, ulong p)
+    ulong  Fl_double(ulong a, ulong p)
     ulong  Fl_mul(ulong a, ulong b, ulong p)
     ulong  Fl_neg(ulong x, ulong p)
     ulong  Fl_sqr(ulong a, ulong p)
     ulong  Fl_sub(ulong a, ulong b, ulong p)
+    ulong  Fl_triple(ulong a, ulong p)
     GEN    absi(GEN x)
+    GEN    absi_shallow(GEN x)
     GEN    absr(GEN x)
     int    absrnz_equal1(GEN x)
     int    absrnz_equal2n(GEN x)
@@ -165,11 +212,13 @@ cdef extern from 'pari/pari.h':
     void   affui(ulong s, GEN x)
     void   affur(ulong s, GEN x)
     GEN    cgetg(long x, long y)
+    GEN    cgetg_block(long x, long y)
     GEN    cgetg_copy(GEN x, long *plx)
     GEN    cgeti(long x)
     GEN    cgetineg(long x)
     GEN    cgetipos(long x)
     GEN    cgetr(long x)
+    GEN    cgetr_block(long prec)
     int    cmpir(GEN x, GEN y)
     int    cmpis(GEN x, long y)
     int    cmpiu(GEN x, ulong y)
@@ -215,19 +264,23 @@ cdef extern from 'pari/pari.h':
     int    equalui(ulong x, GEN y)
     long   evalexpo(long x)
     long   evallg(long x)
+    long   evalprecp(long x)
     long   evalvalp(long x)
     long   expi(GEN x)
     long   expu(ulong x)
     void   fixlg(GEN z, long ly)
     GEN    fractor(GEN x, long prec)
     GEN    icopy(GEN x)
+    GEN    icopyspec(GEN x, long nx)
     GEN    icopy_avma(GEN x, pari_sp av)
+    ulong  int_bit(GEN x, long n)
     GEN    itor(GEN x, long prec)
     long   itos(GEN x)
     long   itos_or_0(GEN x)
     ulong  itou(GEN x)
     ulong  itou_or_0(GEN x)
     GEN    leafcopy(GEN x)
+    GEN    leafcopy_avma(GEN x, pari_sp av)
     double maxdd(double x, double y)
     long   maxss(long x, long y)
     long   maxuu(ulong x, ulong y)
@@ -248,6 +301,7 @@ cdef extern from 'pari/pari.h':
     GEN    modss(long x, long y)
     void   modssz(long s, long y, GEN z)
     GEN    mpabs(GEN x)
+    GEN    mpabs_shallow(GEN x)
     GEN    mpadd(GEN x, GEN y)
     void   mpaddz(GEN x, GEN y, GEN z)
     void   mpaff(GEN x, GEN y)
@@ -262,7 +316,7 @@ cdef extern from 'pari/pari.h':
     GEN    mpneg(GEN x)
     int    mpodd(GEN x)
     GEN    mpround(GEN x)
-    GEN    mpshift(GEN x,long s)
+    GEN    mpshift(GEN x, long s)
     GEN    mpsqr(GEN x)
     GEN    mpsub(GEN x, GEN y)
     void   mpsubz(GEN x, GEN y, GEN z)
@@ -289,6 +343,7 @@ cdef extern from 'pari/pari.h':
     GEN    rdivsi(long x, GEN y, long prec)
     GEN    rdivss(long x, long y, long prec)
     GEN    real2n(long n, long prec)
+    GEN    real_m2n(long n, long prec)
     GEN    real_0(long prec)
     GEN    real_0_bit(long bitprec)
     GEN    real_1(long prec)
@@ -305,15 +360,20 @@ cdef extern from 'pari/pari.h':
     long   sdivsi(long x, GEN y)
     long   sdivsi_rem(long x, GEN y, long *rem)
     long   sdivss_rem(long x, long y, long *rem)
+    ulong  udiviu_rem(GEN n, ulong d, ulong *r)
+    ulong  udivuu_rem(ulong x, ulong y, ulong *r)
     void   setabssign(GEN x)
     void   shift_left(GEN z2, GEN z1, long min, long M, ulong f,  ulong sh)
     void   shift_right(GEN z2, GEN z1, long min, long M, ulong f, ulong sh)
     ulong  shiftl(ulong x, ulong y)
     ulong  shiftlr(ulong x, ulong y)
     GEN    shiftr(GEN x, long n)
+    void   shiftr_inplace(GEN z, long d)
     long   smodis(GEN x, long y)
     long   smodss(long x, long y)
     void   stackdummy(pari_sp av, pari_sp ltop)
+    char  *stack_malloc(size_t N)
+    char  *stack_calloc(size_t N)
     GEN    stoi(long x)
     GEN    stor(long x, long prec)
     GEN    subii(GEN x, GEN y)
@@ -338,7 +398,7 @@ cdef extern from 'pari/pari.h':
     void   togglesign_safe(GEN *px)
     void   affectsign(GEN x, GEN y)
     void   affectsign_safe(GEN x, GEN *py)
-    GEN    truedivii(GEN a,GEN b)
+    GEN    truedivii(GEN a, GEN b)
     GEN    truedivis(GEN a, long b)
     GEN    truedivsi(long a, GEN b)
     ulong  udivui_rem(ulong x, GEN y, ulong *rem)
@@ -351,28 +411,51 @@ cdef extern from 'pari/pari.h':
     GEN    uutoineg(ulong x, ulong y)
     long   vali(GEN x)
 
+    # OBSOLETE
+
+    GEN     bernvec(long nomb)
+
     # F2x.c
 
+    GEN     F2c_to_Flc(GEN x)
     GEN     F2c_to_ZC(GEN x)
+    GEN     F2c_to_mod(GEN x)
+    GEN     F2m_rowslice(GEN x, long a, long b)
+    GEN     F2m_to_Flm(GEN z)
     GEN     F2m_to_ZM(GEN z)
+    GEN     F2m_to_mod(GEN z)
     void    F2v_add_inplace(GEN x, GEN y)
+    ulong   F2v_dotproduct(GEN x, GEN y)
+    GEN     F2v_slice(GEN x, long a, long b)
+    GEN     F2x_F2xq_eval(GEN Q, GEN x, GEN T)
+    GEN     F2x_F2xqV_eval(GEN P, GEN V, GEN T)
     GEN     F2x_1_add(GEN y)
     GEN     F2x_add(GEN x, GEN y)
+    GEN     F2x_deflate(GEN x0, long d)
     long    F2x_degree(GEN x)
     GEN     F2x_deriv(GEN x)
     GEN     F2x_divrem(GEN x, GEN y, GEN *pr)
+    void    F2x_even_odd(GEN p, GEN *pe, GEN *po)
     GEN     F2x_extgcd(GEN a, GEN b, GEN *ptu, GEN *ptv)
     GEN     F2x_gcd(GEN a, GEN b)
+    GEN     F2x_halfgcd(GEN a, GEN b)
+    int     F2x_issquare(GEN a)
     GEN     F2x_mul(GEN x, GEN y)
     GEN     F2x_rem(GEN x, GEN y)
+    GEN     F2x_shift(GEN y, long d)
     GEN     F2x_sqr(GEN x)
+    GEN     F2x_sqrt(GEN x)
     GEN     F2x_to_F2v(GEN x, long n)
     GEN     F2x_to_Flx(GEN x)
     GEN     F2x_to_ZX(GEN x)
+    long    F2x_valrem(GEN x, GEN *Z)
     GEN     F2xC_to_ZXC(GEN x)
     GEN     F2xV_to_F2m(GEN v, long n)
+    GEN     F2xq_Artin_Schreier(GEN a, GEN T)
+    GEN     FlxqXQV_autsum(GEN aut, long n, GEN S, GEN T, ulong p)
+    GEN     F2xq_autpow(GEN x, long n, GEN T)
     GEN     F2xq_conjvec(GEN x, GEN T)
-    GEN     F2xq_div(GEN x,GEN y,GEN T)
+    GEN     F2xq_div(GEN x, GEN y, GEN T)
     GEN     F2xq_inv(GEN x, GEN T)
     GEN     F2xq_invsafe(GEN x, GEN T)
     GEN     F2xq_log(GEN a, GEN g, GEN ord, GEN T)
@@ -380,46 +463,86 @@ cdef extern from 'pari/pari.h':
     GEN     F2xq_mul(GEN x, GEN y, GEN pol)
     GEN     F2xq_order(GEN a, GEN ord, GEN T)
     GEN     F2xq_pow(GEN x, GEN n, GEN pol)
+    GEN     F2xq_powu(GEN x, ulong n, GEN pol)
     GEN     F2xq_powers(GEN x, long l, GEN T)
-    GEN     F2xq_sqr(GEN x,GEN pol)
+    GEN     F2xq_sqr(GEN x, GEN pol)
     GEN     F2xq_sqrt(GEN a, GEN T)
+    GEN     F2xq_sqrt_fast(GEN c, GEN sqx, GEN T)
     GEN     F2xq_sqrtn(GEN a, GEN n, GEN T, GEN *zeta)
     ulong   F2xq_trace(GEN x, GEN T)
     GEN     Flm_to_F2m(GEN x)
     GEN     Flv_to_F2v(GEN x)
     GEN     Flx_to_F2x(GEN x)
-    GEN     Z_to_F2x(GEN x, long sv)
+    GEN     Rg_to_F2xq(GEN x, GEN T)
+    GEN     RgM_to_F2m(GEN x)
+    GEN     RgV_to_F2v(GEN x)
+    GEN     RgX_to_F2x(GEN x)
+    GEN     Z_to_F2x(GEN x, long v)
     GEN     ZM_to_F2m(GEN x)
     GEN     ZV_to_F2v(GEN x)
     GEN     ZX_to_F2x(GEN x)
+    GEN     ZXT_to_FlxT(GEN z, ulong p)
     GEN     ZXX_to_F2xX(GEN B, long v)
     GEN     gener_F2xq(GEN T, GEN *po)
+    bb_field *get_F2xq_field(void **E, GEN T)
     GEN     random_F2x(long d, long vs)
 
+    # F2xqE.c
+
+    GEN     F2xq_ellcard(GEN a2, GEN a6, GEN T)
+    GEN     F2xq_ellgens(GEN a2, GEN a6, GEN ch, GEN D, GEN m, GEN T)
+    GEN     F2xq_ellgroup(GEN a2, GEN a6, GEN N, GEN T, GEN *pt_m)
+    GEN     F2xqE_add(GEN P, GEN Q, GEN a2, GEN T)
+    GEN     F2xqE_changepoint(GEN x, GEN ch, GEN T)
+    GEN     F2xqE_changepointinv(GEN x, GEN ch, GEN T)
+    GEN     F2xqE_dbl(GEN P, GEN a2, GEN T)
+    GEN     F2xqE_log(GEN a, GEN b, GEN o, GEN a2, GEN T)
+    GEN     F2xqE_mul(GEN P, GEN n, GEN a2, GEN T)
+    GEN     F2xqE_neg(GEN P, GEN a2, GEN T)
+    GEN     F2xqE_order(GEN z, GEN o, GEN a2, GEN T)
+    GEN     F2xqE_sub(GEN P, GEN Q, GEN a2, GEN T)
+    GEN     F2xqE_tatepairing(GEN t, GEN s, GEN m, GEN a2, GEN T)
+    GEN     F2xqE_weilpairing(GEN t, GEN s, GEN m, GEN a2, GEN T)
+    bb_group * get_F2xqE_group(void **E, GEN a2, GEN a6, GEN T)
+    GEN     RgE_to_F2xqE(GEN x, GEN T)
+    GEN     random_F2xqE(GEN a2, GEN a6, GEN T)
+
     # Flx.c
 
     GEN     Fl_to_Flx(ulong x, long sv)
+    GEN     Flc_to_ZC(GEN z)
     GEN     Flm_to_FlxV(GEN x, long sv)
-    GEN     Flm_to_FlxX(GEN x, long v,long w)
+    GEN     Flm_to_FlxX(GEN x, long v, long w)
     GEN     Flm_to_ZM(GEN z)
     GEN     Flv_to_Flx(GEN x, long vs)
     GEN     Flv_to_ZV(GEN z)
     GEN     Flv_polint(GEN xa, GEN ya, ulong p, long vs)
     GEN     Flv_roots_to_pol(GEN a, ulong p, long vs)
+    GEN     Fly_to_FlxY(GEN B, long v)
+    GEN     Flx_Fl_add(GEN y, ulong x, ulong p)
     GEN     Flx_Fl_mul(GEN y, ulong x, ulong p)
-    GEN     Flx_to_Flv(GEN x, long N)
-    GEN     Flx_to_ZX(GEN z)
-    GEN     Flx_to_ZX_inplace(GEN z)
+    GEN     Flx_Fl_mul_to_monic(GEN y, ulong x, ulong p)
+    GEN     Flx_Flxq_eval(GEN f, GEN x, GEN T, ulong p)
+    GEN     Flx_FlxqV_eval(GEN f, GEN x, GEN T, ulong p)
     GEN     Flx_add(GEN x, GEN y, ulong p)
+    GEN     Flx_deflate(GEN x0, long d)
     GEN     Flx_deriv(GEN z, ulong p)
+    GEN     Flx_double(GEN y, ulong p)
     GEN     Flx_div_by_X_x(GEN a, ulong x, ulong p, ulong *rem)
     GEN     Flx_divrem(GEN x, GEN y, ulong p, GEN *pr)
+    int     Flx_equal(GEN V, GEN W)
     ulong   Flx_eval(GEN x, ulong y, ulong p)
     GEN     Flx_extgcd(GEN a, GEN b, ulong p, GEN *ptu, GEN *ptv)
     ulong   Flx_extresultant(GEN a, GEN b, ulong p, GEN *ptU, GEN *ptV)
     GEN     Flx_gcd(GEN a, GEN b, ulong p)
-    GEN     Flx_gcd_i(GEN a, GEN b, ulong p)
+    GEN     Flx_get_red(GEN T, ulong p)
+    GEN     Flx_halfgcd(GEN a, GEN b, ulong p)
+    GEN     Flx_inflate(GEN x0, long d)
+    GEN     Flx_invBarrett(GEN T, ulong p)
     int     Flx_is_squarefree(GEN z, ulong p)
+    int     Flx_is_smooth(GEN g, long r, ulong p)
+    GEN     Flx_mod_Xn1(GEN T, ulong n, ulong p)
+    GEN     Flx_mod_Xnm1(GEN T, ulong n, ulong p)
     GEN     Flx_mul(GEN x, GEN y, ulong p)
     GEN     Flx_neg(GEN x, ulong p)
     GEN     Flx_neg_inplace(GEN x, ulong p)
@@ -431,380 +554,1409 @@ cdef extern from 'pari/pari.h':
     GEN     Flx_renormalize(GEN x, long l)
     ulong   Flx_resultant(GEN a, GEN b, ulong p)
     GEN     Flx_shift(GEN a, long n)
+    GEN     Flx_splitting(GEN p, long k)
     GEN     Flx_sqr(GEN x, ulong p)
     GEN     Flx_sub(GEN x, GEN y, ulong p)
+    GEN     Flx_to_Flv(GEN x, long N)
+    GEN     Flx_to_FlxX(GEN z, long v)
+    GEN     Flx_to_ZX(GEN z)
+    GEN     Flx_to_ZX_inplace(GEN z)
+    GEN     Flx_triple(GEN y, ulong p)
+    long    Flx_val(GEN x)
+    long    Flx_valrem(GEN x, GEN *Z)
+    GEN     FlxC_to_ZXC(GEN x)
+    GEN     FlxM_Flx_add_shallow(GEN x, GEN y, ulong p)
     GEN     FlxM_to_ZXM(GEN z)
+    GEN     FlxT_red(GEN z, ulong p)
+    GEN     FlxV_to_ZXV(GEN x)
+    GEN     FlxV_Flc_mul(GEN V, GEN W, ulong p)
+    GEN     FlxV_red(GEN z, ulong p)
     GEN     FlxV_to_Flm(GEN v, long n)
+    GEN     FlxX_Fl_mul(GEN x, ulong y, ulong p)
+    GEN     FlxX_Flx_add(GEN y, GEN x, ulong p)
+    GEN     FlxX_Flx_mul(GEN x, GEN y, ulong p)
     GEN     FlxX_add(GEN P, GEN Q, ulong p)
+    GEN     FlxX_double(GEN x, ulong p)
+    GEN     FlxX_neg(GEN x, ulong p)
+    GEN     FlxX_sub(GEN P, GEN Q, ulong p)
+    GEN     FlxX_swap(GEN x, long n, long ws)
+    GEN     FlxX_renormalize(GEN x, long lx)
     GEN     FlxX_shift(GEN a, long n)
     GEN     FlxX_to_Flm(GEN v, long n)
     GEN     FlxX_to_ZXX(GEN B)
-    GEN     FlxYqQ_pow(GEN x, GEN n, GEN S, GEN T, ulong p)
-    GEN     Flxq_inv(GEN x,GEN T,ulong p)
+    GEN     FlxX_triple(GEN x, ulong p)
+    GEN     FlxY_Flxq_evalx(GEN P, GEN x, GEN T, ulong p)
+    GEN     FlxY_Flx_div(GEN x, GEN y, ulong p)
+    GEN     FlxY_evalx(GEN Q, ulong x, ulong p)
+    GEN     FlxYqq_pow(GEN x, GEN n, GEN S, GEN T, ulong p)
+    GEN     Flxq_autpow(GEN x, ulong n, GEN T, ulong p)
+    GEN     Flxq_autsum(GEN x, ulong n, GEN T, ulong p)
+    GEN     Flxq_charpoly(GEN x, GEN T, ulong p)
+    GEN     Flxq_conjvec(GEN x, GEN T, ulong p)
+    GEN     Flxq_div(GEN x, GEN y, GEN T, ulong p)
+    GEN     Flxq_inv(GEN x, GEN T, ulong p)
     GEN     Flxq_invsafe(GEN x, GEN T, ulong p)
-    GEN     Flxq_mul(GEN y,GEN x,GEN T,ulong p)
+    int     Flxq_issquare(GEN x, GEN T, ulong p)
+    int     Flxq_is2npower(GEN x, long n, GEN T, ulong p)
+    GEN     Flxq_log(GEN a, GEN g, GEN ord, GEN T, ulong p)
+    GEN     Flxq_lroot(GEN a, GEN T, long p)
+    GEN     Flxq_lroot_fast(GEN a, GEN sqx, GEN T, long p)
+    GEN     Flxq_matrix_pow(GEN y, long n, long m, GEN P, ulong l)
+    GEN     Flxq_minpoly(GEN x, GEN T, ulong p)
+    GEN     Flxq_mul(GEN x, GEN y, GEN T, ulong p)
+    ulong   Flxq_norm(GEN x, GEN T, ulong p)
+    GEN     Flxq_order(GEN a, GEN ord, GEN T, ulong p)
     GEN     Flxq_pow(GEN x, GEN n, GEN T, ulong p)
+    GEN     Flxq_powu(GEN x, ulong n, GEN T, ulong p)
     GEN     Flxq_powers(GEN x, long l, GEN T, ulong p)
-    GEN     Flxq_sqr(GEN y,GEN T,ulong p)
-    GEN     FlxqX_normalize(GEN z, GEN T, ulong p)
+    GEN     Flxq_sqr(GEN y, GEN T, ulong p)
+    GEN     Flxq_sqrt(GEN a, GEN T, ulong p)
+    GEN     Flxq_sqrtn(GEN a, GEN n, GEN T, ulong p, GEN *zetan)
+    ulong   Flxq_trace(GEN x, GEN T, ulong p)
+    GEN     FlxqV_dotproduct(GEN x, GEN y, GEN T, ulong p)
+    GEN     FlxqV_roots_to_pol(GEN V, GEN T, ulong p, long v)
+    GEN     FlxqX_FlxqXQ_eval(GEN Q, GEN x, GEN S, GEN T, ulong p)
+    GEN     FlxqX_FlxqXQV_eval(GEN P, GEN V, GEN S, GEN T, ulong p)
     GEN     FlxqX_Flxq_mul(GEN P, GEN U, GEN T, ulong p)
-    GEN     FlxqX_red(GEN z, GEN T, ulong p)
+    GEN     FlxqX_Flxq_mul_to_monic(GEN P, GEN U, GEN T, ulong p)
+    GEN     FlxqX_divrem(GEN x, GEN y, GEN T, ulong p, GEN *pr)
+    GEN     FlxqX_extgcd(GEN a, GEN b, GEN T, ulong p, GEN *ptu, GEN *ptv)
+    GEN     FlxqX_gcd(GEN P, GEN Q, GEN T, ulong p)
+    GEN     FlxqX_invBarrett(GEN T, GEN Q, ulong p)
     GEN     FlxqX_mul(GEN x, GEN y, GEN T, ulong p)
+    GEN     FlxqX_normalize(GEN z, GEN T, ulong p)
+    GEN     FlxqX_pow(GEN V, long n, GEN T, ulong p)
+    GEN     FlxqX_red(GEN z, GEN T, ulong p)
+    GEN     FlxqX_rem_Barrett(GEN x, GEN mg, GEN T, GEN Q, ulong p)
     GEN     FlxqX_safegcd(GEN P, GEN Q, GEN T, ulong p)
     GEN     FlxqX_sqr(GEN x, GEN T, ulong p)
-    GEN     FlxqX_divrem(GEN x, GEN y, GEN T, ulong p, GEN *pr)
+    GEN     FlxqXQ_div(GEN x, GEN y, GEN S, GEN T, ulong p)
+    GEN     FlxqXQ_inv(GEN x, GEN S, GEN T, ulong p)
+    GEN     FlxqXQ_invsafe(GEN x, GEN S, GEN T, ulong p)
+    GEN     FlxqXQ_matrix_pow(GEN x, long n, long m, GEN S, GEN T, ulong p)
+    GEN     FlxqXQ_mul(GEN x, GEN y, GEN S, GEN T, ulong p)
     GEN     FlxqXQ_pow(GEN x, GEN n, GEN S, GEN T, ulong p)
+    GEN     FlxqXQ_powers(GEN x, long n, GEN S, GEN T, ulong p)
+    GEN     FlxqXQ_sqr(GEN x, GEN S, GEN T, ulong p)
+    GEN     FlxqXQV_autpow(GEN x, long n, GEN S, GEN T, ulong p)
+    GEN     FlxqXV_prod(GEN V, GEN T, ulong p)
+    GEN     Kronecker_to_FlxqX(GEN z, GEN T, ulong p)
+    ulong   Rg_to_F2(GEN x)
+    ulong   Rg_to_Fl(GEN x, ulong p)
+    GEN     Rg_to_Flxq(GEN x, GEN T, ulong p)
+    GEN     RgX_to_Flx(GEN x, ulong p)
     GEN     Z_to_Flx(GEN x, ulong p, long v)
-    GEN     ZM_to_Flm(GEN x, ulong p)
-    GEN     ZV_to_Flv(GEN x, ulong p)
     GEN     ZX_to_Flx(GEN x, ulong p)
     GEN     ZXV_to_FlxV(GEN v, ulong p)
     GEN     ZXX_to_FlxX(GEN B, ulong p, long v)
-    GEN     polx_Flx(long sv)
-    GEN     zero_Flx(long sv)
+    GEN     ZXXV_to_FlxXV(GEN V, ulong p, long v)
+    GEN     gener_Flxq(GEN T, ulong p, GEN *o)
+    long    get_Flx_degree(GEN T)
+    GEN     get_Flx_mod(GEN T)
+    long    get_Flx_var(GEN T)
+    bb_field *get_Flxq_field(void **E, GEN T, ulong p)
+    GEN     pol1_FlxX(long v, long sv)
+    GEN     random_Flx(long d1, long v, ulong p)
+    GEN     zxX_to_Kronecker(GEN P, GEN Q)
+
+    # FlxqE.c
+
+    GEN     Flxq_ellcard(GEN a4, GEN a6, GEN T, ulong p)
+    GEN     Flxq_ellgens(GEN a4, GEN a6, GEN ch, GEN D, GEN m, GEN T, ulong p)
+    GEN     Flxq_ellgroup(GEN a4, GEN a6, GEN N, GEN T, ulong p, GEN *pt_m)
+    GEN     Flxq_ellj(GEN a4, GEN a6, GEN T, ulong p)
+    GEN     FlxqE_add(GEN P, GEN Q, GEN a4, GEN T, ulong p)
+    GEN     FlxqE_changepoint(GEN x, GEN ch, GEN T, ulong p)
+    GEN     FlxqE_changepointinv(GEN x, GEN ch, GEN T, ulong p)
+    GEN     FlxqE_dbl(GEN P, GEN a4, GEN T, ulong p)
+    GEN     FlxqE_log(GEN a, GEN b, GEN o, GEN a4, GEN T, ulong p)
+    GEN     FlxqE_mul(GEN P, GEN n, GEN a4, GEN T, ulong p)
+    GEN     FlxqE_neg(GEN P, GEN T, ulong p)
+    GEN     FlxqE_order(GEN z, GEN o, GEN a4, GEN T, ulong p)
+    GEN     FlxqE_sub(GEN P, GEN Q, GEN a4, GEN T, ulong p)
+    GEN     FlxqE_tatepairing(GEN t, GEN s, GEN m, GEN a4, GEN T, ulong p)
+    GEN     FlxqE_weilpairing(GEN t, GEN s, GEN m, GEN a4, GEN T, ulong p)
+    bb_group * get_FlxqE_group(void **E, GEN a4, GEN a6, GEN T, ulong p)
+    GEN     RgE_to_FlxqE(GEN x, GEN T, ulong p)
+    GEN     random_FlxqE(GEN a4, GEN a6, GEN T, ulong p)
+
+    # FpE.c
+
+    long    Fl_elltrace(ulong a4, ulong a6, ulong p)
+    GEN     Fle_add(GEN P, GEN Q, ulong a4, ulong p)
+    GEN     Fle_dbl(GEN P, ulong a4, ulong p)
+    GEN     Fle_mul(GEN P, GEN n, ulong a4, ulong p)
+    GEN     Fle_mulu(GEN P, ulong n, ulong a4, ulong p)
+    GEN     Fle_order(GEN z, GEN o, ulong a4, ulong p)
+    GEN     Fle_sub(GEN P, GEN Q, ulong a4, ulong p)
+    GEN     Fp_ellcard(GEN a4, GEN a6, GEN p)
+    GEN     Fp_elldivpol(GEN a4, GEN a6, long n, GEN p)
+    GEN     Fp_ellgens(GEN a4, GEN a6, GEN ch, GEN D, GEN m, GEN p)
+    GEN     Fp_ellgroup(GEN a4, GEN a6, GEN N, GEN p, GEN *pt_m)
+    GEN     Fp_ellj(GEN a4, GEN a6, GEN p)
+    GEN     Fp_ffellcard(GEN a4, GEN a6, GEN q, long n, GEN p)
+    GEN     FpE_add(GEN P, GEN Q, GEN a4, GEN p)
+    GEN     FpE_changepoint(GEN x, GEN ch, GEN p)
+    GEN     FpE_changepointinv(GEN x, GEN ch, GEN p)
+    GEN     FpE_dbl(GEN P, GEN a4, GEN p)
+    GEN     FpE_log(GEN a, GEN b, GEN o, GEN a4, GEN p)
+    GEN     FpE_mul(GEN P, GEN n, GEN a4, GEN p)
+    GEN     FpE_neg(GEN P, GEN p)
+    GEN     FpE_order(GEN z, GEN o, GEN a4, GEN p)
+    GEN     FpE_sub(GEN P, GEN Q, GEN a4, GEN p)
+    GEN     FpE_to_mod(GEN P, GEN p)
+    GEN     FpE_tatepairing(GEN t, GEN s, GEN m, GEN a4, GEN p)
+    GEN     FpE_weilpairing(GEN t, GEN s, GEN m, GEN a4, GEN p)
+    GEN     FpXQ_ellcard(GEN a4, GEN a6, GEN T, GEN p)
+    GEN     FpXQ_elldivpol(GEN a4, GEN a6, long n, GEN T, GEN p)
+    GEN     FpXQ_ellgens(GEN a4, GEN a6, GEN ch, GEN D, GEN m, GEN T, GEN p)
+    GEN     FpXQ_ellgroup(GEN a4, GEN a6, GEN N, GEN T, GEN p, GEN *pt_m)
+    GEN     FpXQ_ellj(GEN a4, GEN a6, GEN T, GEN p)
+    GEN     FpXQE_add(GEN P, GEN Q, GEN a4, GEN T, GEN p)
+    GEN     FpXQE_changepoint(GEN x, GEN ch, GEN T, GEN p)
+    GEN     FpXQE_changepointinv(GEN x, GEN ch, GEN T, GEN p)
+    GEN     FpXQE_dbl(GEN P, GEN a4, GEN T, GEN p)
+    GEN     FpXQE_log(GEN a, GEN b, GEN o, GEN a4, GEN T, GEN p)
+    GEN     FpXQE_mul(GEN P, GEN n, GEN a4, GEN T, GEN p)
+    GEN     FpXQE_neg(GEN P, GEN T, GEN p)
+    GEN     FpXQE_order(GEN z, GEN o, GEN a4, GEN T, GEN p)
+    GEN     FpXQE_sub(GEN P, GEN Q, GEN a4, GEN T, GEN p)
+    GEN     FpXQE_tatepairing(GEN t, GEN s, GEN m, GEN a4, GEN T, GEN p)
+    GEN     FpXQE_weilpairing(GEN t, GEN s, GEN m, GEN a4, GEN T, GEN p)
+    GEN     Fq_elldivpolmod(GEN a4, GEN a6, long n, GEN h, GEN T, GEN p)
+    GEN     RgE_to_FpE(GEN x, GEN p)
+    GEN     RgE_to_FpXQE(GEN x, GEN T, GEN p)
+    bb_group * get_FpE_group(void **E, GEN a4, GEN a6, GEN p)
+    bb_group * get_FpXQE_group(void **E, GEN a4, GEN a6, GEN T, GEN p)
+    GEN     elltrace_extension(GEN t, long n, GEN p)
+    GEN     random_Fle(ulong a4, ulong a6, ulong p)
+    GEN     random_FpE(GEN a4, GEN a6, GEN p)
+    GEN     random_FpXQE(GEN a4, GEN a6, GEN T, GEN p)
+
+    # FpX.c
+
+    int     Fp_issquare(GEN x, GEN p)
+    GEN     Fp_FpX_sub(GEN x, GEN y, GEN p)
+    GEN     Fp_FpXQ_log(GEN a, GEN g, GEN ord, GEN T, GEN p)
+    GEN     FpV_inv(GEN x, GEN p)
+    GEN     FpV_roots_to_pol(GEN V, GEN p, long v)
+    GEN     FpX_Fp_add(GEN x, GEN y, GEN p)
+    GEN     FpX_Fp_add_shallow(GEN y, GEN x, GEN p)
+    GEN     FpX_Fp_mul(GEN x, GEN y, GEN p)
+    GEN     FpX_Fp_mul_to_monic(GEN y, GEN x, GEN p)
+    GEN     FpX_Fp_mulspec(GEN y, GEN x, GEN p, long ly)
+    GEN     FpX_Fp_sub(GEN x, GEN y, GEN p)
+    GEN     FpX_Fp_sub_shallow(GEN y, GEN x, GEN p)
+    GEN     FpX_FpXQ_eval(GEN f, GEN x, GEN T, GEN p)
+    GEN     FpX_FpXQV_eval(GEN f, GEN x, GEN T, GEN p)
+    GEN     FpX_add(GEN x, GEN y, GEN p)
+    GEN     FpX_center(GEN x, GEN p, GEN pov2)
+    GEN     FpX_chinese_coprime(GEN x, GEN y, GEN Tx, GEN Ty, GEN Tz, GEN p)
+    GEN     FpX_deriv(GEN x, GEN p)
+    GEN     FpX_disc(GEN x, GEN p)
+    GEN     FpX_div_by_X_x(GEN a, GEN x, GEN p, GEN *r)
+    GEN     FpX_divrem(GEN x, GEN y, GEN p, GEN *pr)
+    GEN     FpX_eval(GEN x, GEN y, GEN p)
+    GEN     FpX_extgcd(GEN x, GEN y, GEN p, GEN *ptu, GEN *ptv)
+    GEN     FpX_gcd(GEN x, GEN y, GEN p)
+    GEN     FpX_get_red(GEN T, GEN p)
+    GEN     FpX_halfgcd(GEN x, GEN y, GEN p)
+    GEN     FpX_invBarrett(GEN T, GEN p)
+    int     FpX_is_squarefree(GEN f, GEN p)
+    GEN     FpX_mul(GEN x, GEN y, GEN p)
+    GEN     FpX_mulspec(GEN a, GEN b, GEN p, long na, long nb)
+    GEN     FpX_mulu(GEN x, ulong y, GEN p)
+    GEN     FpX_neg(GEN x, GEN p)
+    GEN     FpX_normalize(GEN z, GEN p)
+    GEN     FpX_red(GEN z, GEN p)
+    GEN     FpX_rem(GEN x, GEN y, GEN p)
+    GEN     FpX_rescale(GEN P, GEN h, GEN p)
+    GEN     FpX_resultant(GEN a, GEN b, GEN p)
+    GEN     FpX_sqr(GEN x, GEN p)
+    GEN     FpX_sub(GEN x, GEN y, GEN p)
+    long    FpX_valrem(GEN x0, GEN t, GEN p, GEN *py)
+    GEN     FpXQ_autpow(GEN x, ulong n, GEN T, GEN p)
+    GEN     FpXQ_autpowers(GEN aut, long f, GEN T, GEN p)
+    GEN     FpXQ_autsum(GEN x, ulong n, GEN T, GEN p)
+    GEN     FpXQ_charpoly(GEN x, GEN T, GEN p)
+    GEN     FpXQ_conjvec(GEN x, GEN T, GEN p)
+    GEN     FpXQ_div(GEN x, GEN y, GEN T, GEN p)
+    GEN     FpXQ_inv(GEN x, GEN T, GEN p)
+    GEN     FpXQ_invsafe(GEN x, GEN T, GEN p)
+    int     FpXQ_issquare(GEN x, GEN T, GEN p)
+    GEN     FpXQ_log(GEN a, GEN g, GEN ord, GEN T, GEN p)
+    GEN     FpXQ_matrix_pow(GEN y, long n, long m, GEN P, GEN l)
+    GEN     FpXQ_minpoly(GEN x, GEN T, GEN p)
+    GEN     FpXQ_mul(GEN y, GEN x, GEN T, GEN p)
+    GEN     FpXQ_norm(GEN x, GEN T, GEN p)
+    GEN     FpXQ_order(GEN a, GEN ord, GEN T, GEN p)
+    GEN     FpXQ_pow(GEN x, GEN n, GEN T, GEN p)
+    GEN     FpXQ_powu(GEN x, ulong n, GEN T, GEN p)
+    GEN     FpXQ_powers(GEN x, long l, GEN T, GEN p)
+    GEN     FpXQ_red(GEN x, GEN T, GEN p)
+    GEN     FpXQ_sqr(GEN y, GEN T, GEN p)
+    GEN     FpXQ_sqrt(GEN a, GEN T, GEN p)
+    GEN     FpXQ_sqrtn(GEN a, GEN n, GEN T, GEN p, GEN *zetan)
+    GEN     FpXQ_trace(GEN x, GEN T, GEN p)
+    GEN     FpXQC_to_mod(GEN z, GEN T, GEN p)
+    GEN     FpXT_red(GEN z, GEN p)
+    GEN     FpXV_prod(GEN V, GEN p)
+    GEN     FpXV_red(GEN z, GEN p)
+    int     Fq_issquare(GEN x, GEN T, GEN p)
+    GEN     FqV_inv(GEN x, GEN T, GEN p)
+    GEN     Z_to_FpX(GEN a, GEN p, long v)
+    GEN     gener_FpXQ(GEN T, GEN p, GEN *o)
+    GEN     gener_FpXQ_local(GEN T, GEN p, GEN L)
+    long    get_FpX_degree(GEN T)
+    GEN     get_FpX_mod(GEN T)
+    long    get_FpX_var(GEN T)
+    bb_group *get_FpXQ_star(void **E, GEN T, GEN p)
+    GEN     random_FpX(long d, long v, GEN p)
 
-     # alglin1.c
+    # FpX_factor.c
 
+    GEN     F2x_factor(GEN f)
+    int     F2x_is_irred(GEN f)
+    void    F2xV_to_FlxV_inplace(GEN v)
+    void    F2xV_to_ZXV_inplace(GEN v)
+    int     Flx_is_irred(GEN f, ulong p)
+    GEN     Flx_degfact(GEN f, ulong p)
+    GEN     Flx_factor(GEN f, ulong p)
+    long    Flx_nbfact(GEN z, ulong p)
+    GEN     Flx_nbfact_by_degree(GEN z, long *nb, ulong p)
+    long    Flx_nbroots(GEN f, ulong p)
+    ulong   Flx_oneroot(GEN f, ulong p)
+    GEN     Flx_roots(GEN f, ulong p)
+    GEN     FlxqX_Frobenius(GEN S, GEN T, ulong p)
+    GEN     FlxqXQ_halfFrobenius(GEN a, GEN S, GEN T, ulong p)
+    long    FlxqX_nbroots(GEN f, GEN T, ulong p)
+    void    FlxV_to_ZXV_inplace(GEN v)
+    GEN     FpX_degfact(GEN f, GEN p)
+    int     FpX_is_irred(GEN f, GEN p)
+    int     FpX_is_totally_split(GEN f, GEN p)
+    GEN     FpX_factor(GEN f, GEN p)
+    GEN     FpX_factorff(GEN P, GEN T, GEN p)
+    long    FpX_nbfact(GEN f, GEN p)
+    long    FpX_nbroots(GEN f, GEN p)
+    GEN     FpX_oneroot(GEN f, GEN p)
+    GEN     FpX_roots(GEN f, GEN p)
+    GEN     FpX_rootsff(GEN P, GEN T, GEN p)
+    GEN     FpXQX_Frobenius(GEN S, GEN T, GEN p)
+    long    FpXQX_nbfact(GEN u, GEN T, GEN p)
+    long    FpXQX_nbroots(GEN f, GEN T, GEN p)
+    GEN     FpXQXQ_halfFrobenius(GEN a, GEN S, GEN T, GEN p)
+    GEN     FqX_deriv(GEN f, GEN T, GEN p)
+    GEN     FqX_factor(GEN x, GEN T, GEN p)
+    long    FqX_is_squarefree(GEN P, GEN T, GEN p)
+    long    FqX_nbfact(GEN u, GEN T, GEN p)
+    long    FqX_nbroots(GEN f, GEN T, GEN p)
+    GEN     FqX_roots(GEN f, GEN T, GEN p)
+    GEN     factcantor(GEN x, GEN p)
+    GEN     factorff(GEN f, GEN p, GEN a)
+    GEN     factormod0(GEN f, GEN p, long flag)
+    GEN     polrootsff(GEN f, GEN p, GEN T)
+    GEN     rootmod0(GEN f, GEN p, long flag)
+
+    # FpXX.c
+
+    GEN     FpXQX_FpXQ_mul(GEN P, GEN U, GEN T, GEN p)
+    GEN     FpXQX_FpXQXQV_eval(GEN P, GEN V, GEN S, GEN T, GEN p)
+    GEN     FpXQX_FpXQXQ_eval(GEN P, GEN x, GEN S, GEN T, GEN p)
+    GEN     FpXQX_divrem(GEN x, GEN y, GEN T, GEN p, GEN *pr)
+    GEN     FpXQX_divrem_Barrett(GEN x, GEN B, GEN S, GEN T, GEN p, GEN *pr)
+    GEN     FpXQX_extgcd(GEN x, GEN y, GEN T, GEN p, GEN *ptu, GEN *ptv)
+    GEN     FpXQX_gcd(GEN P, GEN Q, GEN T, GEN p)
+    GEN     FpXQX_invBarrett(GEN S, GEN T, GEN p)
+    GEN     FpXQX_mul(GEN x, GEN y, GEN T, GEN p)
+    GEN     FpXQX_red(GEN z, GEN T, GEN p)
+    GEN     FpXQX_rem(GEN x, GEN S, GEN T, GEN p)
+    GEN     FpXQX_rem_Barrett(GEN x, GEN mg, GEN S, GEN T, GEN p)
+    GEN     FpXQX_sqr(GEN x, GEN T, GEN p)
+    GEN     FpXQXQ_div(GEN x, GEN y, GEN S, GEN T, GEN p)
+    GEN     FpXQXQ_inv(GEN x, GEN S, GEN T, GEN p)
+    GEN     FpXQXQ_invsafe(GEN x, GEN S, GEN T, GEN p)
+    GEN     FpXQXQ_matrix_pow(GEN y, long n, long m, GEN S, GEN T, GEN p)
+    GEN     FpXQXQ_mul(GEN x, GEN y, GEN S, GEN T, GEN p)
+    GEN     FpXQXQ_pow(GEN x, GEN n, GEN S, GEN T, GEN p)
+    GEN     FpXQXQ_powers(GEN x, long n, GEN S, GEN T, GEN p)
+    GEN     FpXQXQ_sqr(GEN x, GEN S, GEN T, GEN p)
+    GEN     FpXQXQV_autpow(GEN aut, long n, GEN S, GEN T, GEN p)
+    GEN     FpXQXQV_autsum(GEN aut, long n, GEN S, GEN T, GEN p)
+    GEN     FpXQXV_prod(GEN V, GEN Tp, GEN p)
+    GEN     FpXX_Fp_mul(GEN x, GEN y, GEN p)
+    GEN     FpXX_FpX_mul(GEN x, GEN y, GEN p)
+    GEN     FpXX_add(GEN x, GEN y, GEN p)
+    GEN     FpXX_mulu(GEN P, ulong u, GEN p)
+    GEN     FpXX_neg(GEN x, GEN p)
+    GEN     FpXX_red(GEN z, GEN p)
+    GEN     FpXX_sub(GEN x, GEN y, GEN p)
+    GEN     FpXY_FpXQ_evalx(GEN P, GEN x, GEN T, GEN p)
+    GEN     FpXY_eval(GEN Q, GEN y, GEN x, GEN p)
+    GEN     FpXY_evalx(GEN Q, GEN x, GEN p)
+    GEN     FpXY_evaly(GEN Q, GEN y, GEN p, long vy)
+    GEN     FpXYQQ_pow(GEN x, GEN n, GEN S, GEN T, GEN p)
+    GEN     Kronecker_to_FpXQX(GEN z, GEN pol, GEN p)
+    GEN     Kronecker_to_ZXX(GEN z, long N, long v)
+    GEN     ZXX_mul_Kronecker(GEN x, GEN y, long n)
+
+    # FpV.c
+
+    GEN     F2m_F2c_mul(GEN x, GEN y)
+    GEN     F2m_mul(GEN x, GEN y)
+    GEN     F2m_powu(GEN x, ulong n)
+    GEN     Flc_Fl_div(GEN x, ulong y, ulong p)
+    void    Flc_Fl_div_inplace(GEN x, ulong y, ulong p)
+    GEN     Flc_Fl_mul(GEN x, ulong y, ulong p)
+    void    Flc_Fl_mul_inplace(GEN x, ulong y, ulong p)
+    void    Flc_Fl_mul_part_inplace(GEN x, ulong y, ulong p, long l)
+    GEN     Flc_to_mod(GEN z, ulong pp)
+    GEN     Flm_Fl_add(GEN x, ulong y, ulong p)
+    GEN     Flm_Fl_mul(GEN y, ulong x, ulong p)
+    void    Flm_Fl_mul_inplace(GEN y, ulong x, ulong p)
+    GEN     Flm_Flc_mul(GEN x, GEN y, ulong p)
+    GEN     Flm_center(GEN z, ulong p, ulong ps2)
+    GEN     Flm_mul(GEN x, GEN y, ulong p)
+    GEN     Flm_neg(GEN y, ulong p)
+    GEN     Flm_powu(GEN x, ulong n, ulong p)
+    GEN     Flm_to_mod(GEN z, ulong pp)
+    GEN     Flm_transpose(GEN x)
+    GEN     Flv_add(GEN x, GEN y, ulong p)
+    void    Flv_add_inplace(GEN x, GEN y, ulong p)
+    ulong   Flv_dotproduct(GEN x, GEN y, ulong p)
+    GEN     Flv_center(GEN z, ulong p, ulong ps2)
+    GEN     Flv_sub(GEN x, GEN y, ulong p)
+    void    Flv_sub_inplace(GEN x, GEN y, ulong p)
+    ulong   Flv_sum(GEN x, ulong p)
+    GEN     Fp_to_mod(GEN z, GEN p)
+    GEN     FpC_FpV_mul(GEN x, GEN y, GEN p)
+    GEN     FpC_Fp_mul(GEN x, GEN y, GEN p)
+    GEN     FpC_center(GEN z, GEN p, GEN pov2)
+    GEN     FpC_red(GEN z, GEN p)
+    GEN     FpC_to_mod(GEN z, GEN p)
+    GEN     FpM_FpC_mul(GEN x, GEN y, GEN p)
+    GEN     FpM_FpC_mul_FpX(GEN x, GEN y, GEN p, long v)
+    GEN     FpM_center(GEN z, GEN p, GEN pov2)
+    GEN     FpM_mul(GEN x, GEN y, GEN p)
+    GEN     FpM_powu(GEN x, ulong n, GEN p)
+    GEN     FpM_red(GEN z, GEN p)
+    GEN     FpM_to_mod(GEN z, GEN p)
+    GEN     FpMs_FpC_mul(GEN M, GEN B, GEN p)
+    GEN     FpMs_FpCs_solve(GEN M, GEN B, long nbrow, GEN p)
+    GEN     FpMs_FpCs_solve_safe(GEN M, GEN A, long nbrow, GEN p)
+    GEN     FpMs_leftkernel_elt(GEN M, long nbrow, GEN p)
+    GEN     FpC_add(GEN x, GEN y, GEN p)
+    GEN     FpC_sub(GEN x, GEN y, GEN p)
+    GEN     FpV_FpMs_mul(GEN B, GEN M, GEN p)
+    GEN     FpV_add(GEN x, GEN y, GEN p)
+    GEN     FpV_sub(GEN x, GEN y, GEN p)
+    GEN     FpV_dotproduct(GEN x, GEN y, GEN p)
+    GEN     FpV_dotsquare(GEN x, GEN p)
+    GEN     FpV_red(GEN z, GEN p)
+    GEN     FpV_to_mod(GEN z, GEN p)
+    GEN     FpVV_to_mod(GEN z, GEN p)
+    GEN     FpX_to_mod(GEN z, GEN p)
+    GEN     ZV_zMs_mul(GEN B, GEN M)
+    GEN     ZpMs_ZpCs_solve(GEN M, GEN B, long nbrow, GEN p, long e)
+    GEN     gen_FpM_Wiedemann(void *E, GEN (*f)(void*, GEN), GEN B, GEN p)
+    GEN     gen_ZpM_Dixon(void *E, GEN (*f)(void*, GEN), GEN B, GEN p, long e)
+    GEN     gen_matid(long n, void *E, bb_field *S)
+    GEN     matid_F2m(long n)
+    GEN     matid_Flm(long n)
+    GEN     matid_F2xqM(long n, GEN T)
+    GEN     matid_FlxqM(long n, GEN T, ulong p)
+    GEN     scalar_Flm(long s, long n)
+    GEN     zCs_to_ZC(GEN C, long nbrow)
+    GEN     zMs_to_ZM(GEN M, long nbrow)
+    GEN     zMs_ZC_mul(GEN M, GEN B)
+
+    # Hensel.c
+
+    GEN     Zp_sqrtlift(GEN b, GEN a, GEN p, long e)
+    GEN     Zp_sqrtnlift(GEN b, GEN n, GEN a, GEN p, long e)
+    GEN     ZpX_liftfact(GEN pol, GEN Q, GEN T, GEN p, long e, GEN pe)
+    GEN     ZpX_liftroot(GEN f, GEN a, GEN p, long e)
+    GEN     ZpX_liftroots(GEN f, GEN S, GEN q, long e)
+    GEN     ZpXQ_inv(GEN a, GEN T, GEN p, long e)
+    GEN     ZpXQ_invlift(GEN b, GEN a, GEN T, GEN p, long e)
+    GEN     ZpXQ_log(GEN a, GEN T, GEN p, long N)
+    GEN     ZpXQ_sqrtnlift(GEN b, GEN n, GEN a, GEN T, GEN p, long e)
+    GEN     ZpXQX_liftroot(GEN f, GEN a, GEN T, GEN p, long e)
+    GEN     ZpXQX_liftroot_vald(GEN f, GEN a, long v, GEN T, GEN p, long e)
+    GEN     gen_ZpX_Dixon(GEN F, GEN V, GEN q, GEN p, long N, void *E,
+                                 GEN lin(void *E, GEN F, GEN d, GEN q),
+                                 GEN invl(void *E, GEN d))
+    GEN     gen_ZpX_Newton(GEN x, GEN p, long n, void *E,
+                                  GEN eval(void *E, GEN f, GEN q),
+                                  GEN invd(void *E, GEN V, GEN v, GEN q, long M))
+    GEN     polhensellift(GEN pol, GEN fct, GEN p, long exp)
+    ulong   quadratic_prec_mask(long n)
+
+    # QX_factor.c
+
+    GEN     QX_factor(GEN x)
+    GEN     ZX_factor(GEN x)
+    long    ZX_is_irred(GEN x)
+    GEN     ZX_squff(GEN f, GEN *ex)
+    GEN     polcyclofactors(GEN f)
+    long    poliscyclo(GEN f)
+    long    poliscycloprod(GEN f)
+
+    # RgV.c
+
+    GEN     RgC_Rg_add(GEN x, GEN y)
+    GEN     RgC_Rg_div(GEN x, GEN y)
+    GEN     RgC_Rg_mul(GEN x, GEN y)
+    GEN     RgC_RgM_mul(GEN x, GEN y)
+    GEN     RgC_RgV_mul(GEN x, GEN y)
+    GEN     RgC_add(GEN x, GEN y)
+    GEN     RgC_neg(GEN x)
+    GEN     RgC_sub(GEN x, GEN y)
+    GEN     RgM_Rg_add(GEN x, GEN y)
+    GEN     RgM_Rg_add_shallow(GEN x, GEN y)
+    GEN     RgM_Rg_div(GEN x, GEN y)
+    GEN     RgM_Rg_mul(GEN x, GEN y)
+    GEN     RgM_Rg_sub(GEN x, GEN y)
+    GEN     RgM_Rg_sub_shallow(GEN x, GEN y)
+    GEN     RgM_RgC_mul(GEN x, GEN y)
+    GEN     RgM_RgV_mul(GEN x, GEN y)
+    GEN     RgM_add(GEN x, GEN y)
+    GEN     RgM_det_triangular(GEN x)
+    int     RgM_is_ZM(GEN x)
+    int     RgM_isdiagonal(GEN x)
+    int     RgM_isidentity(GEN x)
+    int     RgM_isscalar(GEN x, GEN s)
+    GEN     RgM_mul(GEN x, GEN y)
+    GEN     RgM_multosym(GEN x, GEN y)
+    GEN     RgM_neg(GEN x)
+    GEN     RgM_powers(GEN x, long l)
+    GEN     RgM_sqr(GEN x)
+    GEN     RgM_sub(GEN x, GEN y)
+    GEN     RgM_transmul(GEN x, GEN y)
+    GEN     RgM_transmultosym(GEN x, GEN y)
+    GEN     RgM_zc_mul(GEN x, GEN y)
+    GEN     RgM_zm_mul(GEN x, GEN y)
+    GEN     RgMrow_RgC_mul(GEN x, GEN y, long i)
+    GEN     RgV_RgM_mul(GEN x, GEN y)
+    GEN     RgV_RgC_mul(GEN x, GEN y)
+    GEN     RgV_Rg_mul(GEN x, GEN y)
+    GEN     RgV_add(GEN x, GEN y)
+    GEN     RgV_dotproduct(GEN x, GEN y)
+    GEN     RgV_dotsquare(GEN x)
+    int     RgV_is_ZMV(GEN V)
+    long    RgV_isin(GEN v, GEN x)
+    GEN     RgV_neg(GEN x)
+    GEN     RgV_sub(GEN x, GEN y)
+    GEN     RgV_sum(GEN v)
+    GEN     RgV_sumpart(GEN v, long n)
+    GEN     RgV_sumpart2(GEN v, long m, long n)
+    GEN     RgV_zc_mul(GEN x, GEN y)
+    GEN     RgV_zm_mul(GEN x, GEN y)
+    GEN     RgX_RgM_eval(GEN x, GEN y)
+    GEN     RgX_RgMV_eval(GEN x, GEN y)
+    int     isdiagonal(GEN x)
+    GEN     matid(long n)
+    GEN     scalarcol(GEN x, long n)
+    GEN     scalarcol_shallow(GEN x, long n)
+    GEN     scalarmat(GEN x, long n)
+    GEN     scalarmat_shallow(GEN x, long n)
+    GEN     scalarmat_s(long x, long n)
+
+    # RgX.c
+
+    GEN     Kronecker_to_mod(GEN z, GEN pol)
+    GEN     QX_ZXQV_eval(GEN P, GEN V, GEN dV)
+    GEN     QXQ_powers(GEN a, long n, GEN T)
+    GEN     QXQX_to_mod_shallow(GEN z, GEN T)
+    GEN     QXQV_to_mod(GEN V, GEN T)
+    GEN     QXQXV_to_mod(GEN V, GEN T)
+    GEN     QXV_QXQ_eval(GEN v, GEN a, GEN T)
+    GEN     QXX_QXQ_eval(GEN v, GEN a, GEN T)
+    GEN     Rg_to_RgV(GEN x, long N)
+    GEN     RgM_to_RgXV(GEN x, long v)
+    GEN     RgM_to_RgXX(GEN x, long v, long w)
+    GEN     RgV_to_RgX(GEN x, long v)
+    GEN     RgV_to_RgX_reverse(GEN x, long v)
+    GEN     RgXQC_red(GEN P, GEN T)
+    GEN     RgXQV_red(GEN P, GEN T)
+    GEN     RgXQX_RgXQ_mul(GEN x, GEN y, GEN T)
+    GEN     RgXQX_divrem(GEN x, GEN y, GEN T, GEN *r)
+    GEN     RgXQX_mul(GEN x, GEN y, GEN T)
+    GEN     RgXQX_pseudodivrem(GEN x, GEN y, GEN T, GEN *ptr)
+    GEN     RgXQX_pseudorem(GEN x, GEN y, GEN T)
+    GEN     RgXQX_red(GEN P, GEN T)
+    GEN     RgXQX_sqr(GEN x, GEN T)
+    GEN     RgXQX_translate(GEN P, GEN c, GEN T)
+    GEN     RgXQ_matrix_pow(GEN y, long n, long m, GEN P)
+    GEN     RgXQ_norm(GEN x, GEN T)
+    GEN     RgXQ_pow(GEN x, GEN n, GEN T)
+    GEN     RgXQ_powu(GEN x, ulong n, GEN T)
+    GEN     RgXQ_powers(GEN x, long l, GEN T)
+    GEN     RgXV_to_RgM(GEN v, long n)
+    GEN     RgXV_unscale(GEN v, GEN h)
+    GEN     RgXX_to_RgM(GEN v, long n)
+    GEN     RgXY_swap(GEN x, long n, long w)
+    GEN     RgXY_swapspec(GEN x, long n, long w, long nx)
+    GEN     RgX_RgXQ_eval(GEN f, GEN x, GEN T)
+    GEN     RgX_RgXQV_eval(GEN P, GEN V, GEN T)
+    GEN     RgX_Rg_add(GEN y, GEN x)
+    GEN     RgX_Rg_add_shallow(GEN y, GEN x)
+    GEN     RgX_Rg_div(GEN y, GEN x)
+    GEN     RgX_Rg_divexact(GEN x, GEN y)
+    GEN     RgX_Rg_mul(GEN y, GEN x)
+    GEN     RgX_Rg_sub(GEN y, GEN x)
+    GEN     RgX_add(GEN x, GEN y)
+    GEN     RgX_blocks(GEN P, long n, long m)
+    GEN     RgX_deflate(GEN x0, long d)
+    GEN     RgX_deriv(GEN x)
+    GEN     RgX_div_by_X_x(GEN a, GEN x, GEN *r)
+    GEN     RgX_divrem(GEN x, GEN y, GEN *r)
+    GEN     RgX_divs(GEN y, long x)
+    long    RgX_equal(GEN x, GEN y)
+    void    RgX_even_odd(GEN p, GEN *pe, GEN *po)
+    GEN     RgX_get_0(GEN x)
+    GEN     RgX_get_1(GEN x)
+    GEN     RgX_inflate(GEN x0, long d)
+    GEN     RgX_modXn_shallow(GEN a, long n)
+    GEN     RgX_modXn_eval(GEN Q, GEN x, long n)
+    GEN     RgX_mul(GEN x, GEN y)
+    GEN     RgX_mul_normalized(GEN A, long a, GEN B, long b)
+    GEN     RgX_mulXn(GEN x, long d)
+    GEN     RgX_mullow(GEN f, GEN g, long n)
+    GEN     RgX_muls(GEN y, long x)
+    GEN     RgX_mulspec(GEN a, GEN b, long na, long nb)
+    GEN     RgX_neg(GEN x)
+    GEN     RgX_pseudodivrem(GEN x, GEN y, GEN *ptr)
+    GEN     RgX_pseudorem(GEN x, GEN y)
+    GEN     RgX_recip(GEN x)
+    GEN     RgX_recip_shallow(GEN x)
+    GEN     RgX_renormalize_lg(GEN x, long lx)
+    GEN     RgX_rescale(GEN P, GEN h)
+    GEN     RgX_rotate_shallow(GEN P, long k, long p)
+    GEN     RgX_shift(GEN a, long n)
+    GEN     RgX_shift_shallow(GEN x, long n)
+    GEN     RgX_splitting(GEN p, long k)
+    GEN     RgX_sqr(GEN x)
+    GEN     RgX_sqrlow(GEN f, long n)
+    GEN     RgX_sqrspec(GEN a, long na)
+    GEN     RgX_sub(GEN x, GEN y)
+    GEN     RgX_to_RgV(GEN x, long N)
+    GEN     RgX_translate(GEN P, GEN c)
+    GEN     RgX_unscale(GEN P, GEN h)
+    GEN     Rg_RgX_sub(GEN x, GEN y)
+    GEN     ZX_translate(GEN P, GEN c)
+    GEN     ZX_unscale(GEN P, GEN h)
+    GEN     ZX_unscale_div(GEN P, GEN h)
+    int     ZXQX_dvd(GEN x, GEN y, GEN T)
+    long    brent_kung_optpow(long d, long n, long m)
+    GEN     gen_bkeval(GEN Q, long d, GEN x, int use_sqr, void *E,
+              bb_algebra *ff, GEN cmul(void *E, GEN P, long a, GEN x))
+    GEN     gen_bkeval_powers(GEN P, long d, GEN V, void *E,
+              bb_algebra *ff, GEN cmul(void *E, GEN P, long a, GEN x))
+
+    # ZV.c
+
+    void    Flc_lincomb1_inplace(GEN X, GEN Y, ulong v, ulong q)
+    void    RgM_check_ZM(GEN A, const char *s)
+    void    RgV_check_ZV(GEN A, const char *s)
+    GEN     ZC_ZV_mul(GEN x, GEN y)
+    GEN     ZC_Z_add(GEN x, GEN y)
+    GEN     ZC_Z_divexact(GEN X, GEN c)
+    GEN     ZC_Z_mul(GEN X, GEN c)
+    GEN     ZC_Z_sub(GEN x, GEN y)
+    GEN     ZC_add(GEN x, GEN y)
+    GEN     ZC_copy(GEN x)
+    GEN     ZC_hnfremdiv(GEN x, GEN y, GEN *Q)
+    GEN     ZC_lincomb(GEN u, GEN v, GEN X, GEN Y)
+    void    ZC_lincomb1_inplace(GEN X, GEN Y, GEN v)
+    GEN     ZC_neg(GEN M)
+    GEN     ZC_reducemodlll(GEN x, GEN y)
+    GEN     ZC_reducemodmatrix(GEN v, GEN y)
+    GEN     ZC_sub(GEN x, GEN y)
+    GEN     ZC_z_mul(GEN X, long c)
+    GEN     ZM_ZC_mul(GEN x, GEN y)
+    GEN     ZM_Z_divexact(GEN X, GEN c)
+    GEN     ZM_Z_mul(GEN X, GEN c)
+    GEN     ZM_add(GEN x, GEN y)
+    GEN     ZM_copy(GEN x)
+    GEN     ZM_det_triangular(GEN mat)
+    int     ZM_equal(GEN A, GEN B)
+    GEN     ZM_hnfdivrem(GEN x, GEN y, GEN *Q)
+    int     ZM_ishnf(GEN x)
+    int     ZM_isidentity(GEN x)
+    long    ZM_max_lg(GEN x)
+    GEN     ZM_mul(GEN x, GEN y)
+    GEN     ZM_multosym(GEN x, GEN y)
+    GEN     ZM_neg(GEN x)
+    GEN     ZM_nm_mul(GEN x, GEN y)
+    GEN     ZM_pow(GEN x, GEN n)
+    GEN     ZM_powu(GEN x, ulong n)
+    GEN     ZM_reducemodlll(GEN x, GEN y)
+    GEN     ZM_reducemodmatrix(GEN v, GEN y)
+    GEN     ZM_sub(GEN x, GEN y)
+    GEN     ZM_supnorm(GEN x)
+    GEN     ZM_to_Flm(GEN x, ulong p)
+    GEN     ZM_to_zm(GEN z)
+    GEN     ZM_transmultosym(GEN x, GEN y)
+    GEN     ZMV_to_zmV(GEN z)
+    void    ZM_togglesign(GEN M)
+    GEN     ZM_zc_mul(GEN x, GEN y)
+    GEN     ZM_zm_mul(GEN x, GEN y)
+    GEN     ZMrow_ZC_mul(GEN x, GEN y, long i)
+    GEN     ZV_ZM_mul(GEN x, GEN y)
+    int     ZV_abscmp(GEN x, GEN y)
+    int     ZV_cmp(GEN x, GEN y)
+    GEN     ZV_content(GEN x)
+    GEN     ZV_dotproduct(GEN x, GEN y)
+    GEN     ZV_dotsquare(GEN x)
+    int     ZV_equal(GEN V, GEN W)
+    int     ZV_equal0(GEN V)
+    long    ZV_max_lg(GEN x)
+    void    ZV_neg_inplace(GEN M)
+    GEN     ZV_prod(GEN v)
+    GEN     ZV_sum(GEN v)
+    GEN     ZV_to_Flv(GEN x, ulong p)
+    GEN     ZV_to_nv(GEN z)
+    void    ZV_togglesign(GEN M)
+    GEN     gram_matrix(GEN M)
+    GEN     nm_Z_mul(GEN X, GEN c)
+    GEN     zm_mul(GEN x, GEN y)
+    GEN     zm_to_Flm(GEN z, ulong p)
+    GEN     zm_to_ZM(GEN z)
+    GEN     zm_zc_mul(GEN x, GEN y)
+    GEN     zmV_to_ZMV(GEN z)
+    long    zv_content(GEN x)
+    long    zv_dotproduct(GEN x, GEN y)
+    int     zv_equal(GEN V, GEN W)
+    int     zv_equal0(GEN V)
+    GEN     zv_neg(GEN x)
+    GEN     zv_neg_inplace(GEN M)
+    long    zv_prod(GEN v)
+    GEN     zv_prod_Z(GEN v)
+    long    zv_sum(GEN v)
+    GEN     zv_to_Flv(GEN z, ulong p)
+    GEN     zv_z_mul(GEN v, long n)
+    int     zvV_equal(GEN V, GEN W)
+
+    # ZX.c
+
+    void    RgX_check_QX(GEN x, const char *s)
+    void    RgX_check_ZX(GEN x, const char *s)
+    void    RgX_check_ZXX(GEN x, const char *s)
+    GEN     Z_ZX_sub(GEN x, GEN y)
+    GEN     ZX_Z_add(GEN y, GEN x)
+    GEN     ZX_Z_add_shallow(GEN y, GEN x)
+    GEN     ZX_Z_divexact(GEN y, GEN x)
+    GEN     ZX_Z_mul(GEN y, GEN x)
+    GEN     ZX_Z_sub(GEN y, GEN x)
+    GEN     ZX_add(GEN x, GEN y)
+    GEN     ZX_copy(GEN x)
+    GEN     ZX_deriv(GEN x)
+    int     ZX_equal(GEN V, GEN W)
+    GEN     ZX_eval1(GEN x)
+    long    ZX_max_lg(GEN x)
+    GEN     ZX_mod_Xnm1(GEN T, ulong n)
+    GEN     ZX_mul(GEN x, GEN y)
+    GEN     ZX_mulspec(GEN a, GEN b, long na, long nb)
+    GEN     ZX_mulu(GEN y, ulong x)
+    GEN     ZX_neg(GEN x)
+    GEN     ZX_rem(GEN x, GEN y)
+    GEN     ZX_remi2n(GEN y, long n)
+    GEN     ZX_rescale(GEN P, GEN h)
+    GEN     ZX_rescale_lt(GEN P)
+    GEN     ZX_shifti(GEN x, long n)
+    GEN     ZX_sqr(GEN x)
+    GEN     ZX_sqrspec(GEN a, long na)
+    GEN     ZX_sub(GEN x, GEN y)
+    long    ZX_val(GEN x)
+    long    ZX_valrem(GEN x, GEN *Z)
+    GEN     ZXT_remi2n(GEN z, long n)
+    GEN     ZXV_Z_mul(GEN y, GEN x)
+    GEN     ZXV_dotproduct(GEN V, GEN W)
+    int     ZXV_equal(GEN V, GEN W)
+    GEN     ZXV_remi2n(GEN x, long n)
+    GEN     ZXX_Z_divexact(GEN y, GEN x)
+    long    ZXX_max_lg(GEN x)
+    GEN     ZXX_renormalize(GEN x, long lx)
+    GEN     ZXX_to_Kronecker(GEN P, long n)
+    GEN     ZXX_to_Kronecker_spec(GEN P, long lP, long n)
+    GEN     scalar_ZX(GEN x, long v)
+    GEN     scalar_ZX_shallow(GEN x, long v)
+    GEN     zx_to_ZX(GEN z)
+
+    # alglin1.c
+
+    GEN     F2m_F2c_gauss(GEN a, GEN b)
+    GEN     F2m_F2c_invimage(GEN A, GEN y)
+    GEN     F2m_deplin(GEN x)
+    ulong   F2m_det(GEN x)
+    ulong   F2m_det_sp(GEN x)
+    GEN     F2m_gauss(GEN a, GEN b)
+    GEN     F2m_image(GEN x)
+    GEN     F2m_indexrank(GEN x)
+    GEN     F2m_inv(GEN x)
+    GEN     F2m_invimage(GEN A, GEN B)
+    GEN     F2m_ker(GEN x)
+    GEN     F2m_ker_sp(GEN x, long deplin)
+    long    F2m_rank(GEN x)
+    GEN     F2m_suppl(GEN x)
+    GEN     F2xqM_F2xqC_mul(GEN a, GEN b, GEN T)
+    GEN     F2xqM_det(GEN a, GEN T)
+    GEN     F2xqM_ker(GEN x, GEN T)
+    GEN     F2xqM_image(GEN x, GEN T)
+    GEN     F2xqM_inv(GEN a, GEN T)
+    GEN     F2xqM_mul(GEN a, GEN b, GEN T)
+    long    F2xqM_rank(GEN x, GEN T)
+    GEN     Flm_Flc_gauss(GEN a, GEN b, ulong p)
+    GEN     Flm_Flc_invimage(GEN mat, GEN y, ulong p)
     GEN     Flm_deplin(GEN x, ulong p)
+    ulong   Flm_det(GEN x, ulong p)
+    ulong   Flm_det_sp(GEN x, ulong p)
+    GEN     Flm_gauss(GEN a, GEN b, ulong p)
+    GEN     Flm_image(GEN x, ulong p)
+    GEN     Flm_invimage(GEN m, GEN v, ulong p)
     GEN     Flm_indexrank(GEN x, ulong p)
     GEN     Flm_inv(GEN x, ulong p)
     GEN     Flm_ker(GEN x, ulong p)
     GEN     Flm_ker_sp(GEN x, ulong p, long deplin)
-    GEN     Flm_mul(GEN x, GEN y, ulong p)
+    long    Flm_rank(GEN x, ulong p)
+    GEN     Flm_suppl(GEN x, ulong p)
+    GEN     FlxqM_FlxqC_gauss(GEN a, GEN b, GEN T, ulong p)
+    GEN     FlxqM_FlxqC_mul(GEN a, GEN b, GEN T, ulong p)
+    GEN     FlxqM_det(GEN a, GEN T, ulong p)
+    GEN     FlxqM_gauss(GEN a, GEN b, GEN T, ulong p)
     GEN     FlxqM_ker(GEN x, GEN T, ulong p)
-    GEN     FpC_FpV_mul(GEN x, GEN y, GEN p)
+    GEN     FlxqM_image(GEN x, GEN T, ulong p)
+    GEN     FlxqM_inv(GEN x, GEN T, ulong p)
+    GEN     FlxqM_mul(GEN a, GEN b, GEN T, ulong p)
+    long    FlxqM_rank(GEN x, GEN T, ulong p)
+    GEN     FpM_FpC_gauss(GEN a, GEN b, GEN p)
+    GEN     FpM_FpC_invimage(GEN m, GEN v, GEN p)
     GEN     FpM_deplin(GEN x, GEN p)
+    GEN     FpM_det(GEN x, GEN p)
+    GEN     FpM_gauss(GEN a, GEN b, GEN p)
     GEN     FpM_image(GEN x, GEN p)
+    GEN     FpM_indexrank(GEN x, GEN p)
     GEN     FpM_intersect(GEN x, GEN y, GEN p)
     GEN     FpM_inv(GEN x, GEN p)
     GEN     FpM_invimage(GEN m, GEN v, GEN p)
     GEN     FpM_ker(GEN x, GEN p)
-    GEN     FpM_mul(GEN x, GEN y, GEN p)
     long    FpM_rank(GEN x, GEN p)
-    GEN     FpM_indexrank(GEN x, GEN p)
     GEN     FpM_suppl(GEN x, GEN p)
+    GEN     FqM_FqC_gauss(GEN a, GEN b, GEN T, GEN p)
+    GEN     FqM_FqC_mul(GEN a, GEN b, GEN T, GEN p)
+    GEN     FqM_deplin(GEN x, GEN T, GEN p)
+    GEN     FqM_det(GEN x, GEN T, GEN p)
     GEN     FqM_gauss(GEN a, GEN b, GEN T, GEN p)
     GEN     FqM_ker(GEN x, GEN T, GEN p)
+    GEN     FqM_image(GEN x, GEN T, GEN p)
+    GEN     FqM_inv(GEN x, GEN T, GEN p)
+    GEN     FqM_mul(GEN a, GEN b, GEN T, GEN p)
+    long    FqM_rank(GEN a, GEN T, GEN p)
     GEN     FqM_suppl(GEN x, GEN T, GEN p)
     GEN     QM_inv(GEN M, GEN dM)
+    GEN     RgM_Fp_init(GEN a, GEN p, ulong *pp)
+    GEN     RgM_RgC_invimage(GEN A, GEN B)
+    GEN     RgM_diagonal(GEN m)
+    GEN     RgM_diagonal_shallow(GEN m)
+    GEN     RgM_Hadamard(GEN a)
+    GEN     RgM_inv_upper(GEN a)
+    GEN     RgM_invimage(GEN A, GEN B)
+    GEN     RgM_solve(GEN a, GEN b)
+    GEN     RgM_solve_realimag(GEN x, GEN y)
+    void    RgMs_structelim(GEN M, long N, GEN A, GEN *p_col, GEN *p_lin)
+    GEN     ZM_det(GEN a)
+    GEN     ZM_detmult(GEN A)
+    GEN     ZM_gauss(GEN a, GEN b)
+    GEN     ZM_imagecompl(GEN x)
+    GEN     ZM_indeximage(GEN x)
     GEN     ZM_inv(GEN M, GEN dM)
-    GEN     concat(GEN x, GEN y)
+    long    ZM_rank(GEN x)
+    GEN     ZlM_gauss(GEN a, GEN b, ulong p, long e, GEN C)
+    GEN     closemodinvertible(GEN x, GEN y)
     GEN     deplin(GEN x)
     GEN     det(GEN a)
-    GEN     det0(GEN a,long flag)
+    GEN     det0(GEN a, long flag)
     GEN     det2(GEN a)
     GEN     detint(GEN x)
-    GEN     diagonal(GEN x)
     GEN     eigen(GEN x, long prec)
-    GEN     shallowextract(GEN x, GEN l)
-    GEN     extract0(GEN x, GEN l1, GEN l2)
     GEN     gauss(GEN a, GEN b)
     GEN     gaussmodulo(GEN M, GEN D, GEN Y)
     GEN     gaussmodulo2(GEN M, GEN D, GEN Y)
-    GEN     scalarmat_s(long x, long n)
-    GEN     gtomat(GEN x)
-    GEN     gtrans(GEN x)
-    int     hnfdivide(GEN A, GEN B)
-    GEN     matid(long n)
+    GEN     gen_Gauss(GEN a, GEN b, void *E, bb_field *ff)
+    GEN     gen_Gauss_pivot(GEN x, long *rr, void *E, bb_field *ff)
+    GEN     gen_det(GEN a, void *E, bb_field *ff)
+    GEN     gen_ker(GEN x, long deplin, void *E, bb_field *ff)
+    GEN     gen_matcolmul(GEN a, GEN b, void *E, bb_field *ff)
+    GEN     gen_matmul(GEN a, GEN b, void *E, bb_field *ff)
     GEN     image(GEN x)
     GEN     image2(GEN x)
     GEN     imagecompl(GEN x)
     GEN     indexrank(GEN x)
     GEN     inverseimage(GEN mat, GEN y)
-    long    isdiagonal(GEN x)
     GEN     ker(GEN x)
     GEN     keri(GEN x)
-    GEN     matimage0(GEN x,long flag)
+    GEN     mateigen(GEN x, long flag, long prec)
+    GEN     matimage0(GEN x, long flag)
     GEN     matker0(GEN x, long flag)
-    GEN     matmuldiagonal(GEN x, GEN d)
-    GEN     matmultodiagonal(GEN x, GEN y)
-    GEN     matsolvemod0(GEN M, GEN D, GEN Y,long flag)
+    GEN     matsolvemod0(GEN M, GEN D, GEN Y, long flag)
     long    rank(GEN x)
-    GEN     indexrank(GEN x)
-    # we rename sum to pari_sum to avoid conflicts with
-    # python's sum function
-    GEN     pari_sum "sum"(GEN v, long a, long b)
+    GEN     reducemodinvertible(GEN x, GEN y)
+    GEN     reducemodlll(GEN x, GEN y)
+    GEN     split_realimag(GEN x, long r1, long r2)
     GEN     suppl(GEN x)
-    GEN     vconcat(GEN A, GEN B)
 
     # alglin2.c
 
-    GEN     ZM_to_zm(GEN z)
+    GEN     FpM_charpoly(GEN x, GEN p)
+    GEN     FpM_hess(GEN x, GEN p)
+    GEN     Flm_charpoly(GEN x, long p)
+    GEN     Flm_hess(GEN x, ulong p)
+    GEN     QM_minors_coprime(GEN x, GEN pp)
+    GEN     QM_ImZ_hnf(GEN x)
+    GEN     QM_ImQ_hnf(GEN x)
+    GEN     gnorml1_fake(GEN x)
+    GEN     ZM_charpoly(GEN x)
     GEN     adj(GEN x)
-    GEN     caract(GEN x, int v)
+    GEN     adjsafe(GEN x)
+    GEN     caract(GEN x, long v)
     GEN     caradj(GEN x, long v, GEN *py)
+    GEN     carberkowitz(GEN x, long v)
     GEN     carhess(GEN x, long v)
-    GEN     charpoly0(GEN x, int v,long flag)
-    GEN     conjvec(GEN x,long prec)
-    GEN     gconj(GEN x)
+    GEN     charpoly(GEN x, long v)
+    GEN     charpoly0(GEN x, long v, long flag)
     GEN     gnorm(GEN x)
-    GEN     gnorml1(GEN x,long prec)
+    GEN     gnorml1(GEN x, long prec)
+    GEN     gnormlp(GEN x, GEN p, long prec)
     GEN     gnorml2(GEN x)
+    GEN     gsupnorm(GEN x, long prec)
+    void    gsupnorm_aux(GEN x, GEN *m, GEN *msq, long prec)
     GEN     gtrace(GEN x)
     GEN     hess(GEN x)
-    GEN     hnf(GEN x)
-    GEN     hnfall(GEN x)
-    GEN     hnflll(GEN x)
-    GEN     hnfmod(GEN x, GEN detmat)
-    GEN     hnfmodid(GEN x,GEN p)
-    GEN     hnfperm(GEN x)
     GEN     intersect(GEN x, GEN y)
     GEN     jacobi(GEN a, long prec)
-    GEN     matfrobenius(GEN M, long flag, long v)
-    GEN     matrixqz(GEN x, GEN pp)
+    GEN     matadjoint0(GEN x, long flag)
+    GEN     matcompanion(GEN x)
     GEN     matrixqz0(GEN x, GEN pp)
-    GEN     qfsign(GEN a)
-    GEN     smith(GEN x)
-    GEN     smithall(GEN x)
-    GEN     smithclean(GEN z)
+    GEN     minpoly(GEN x, long v)
     GEN     qfgaussred(GEN a)
-    GEN     zm_to_ZM(GEN z)
-    GEN     zx_to_ZX(GEN z)
+    GEN     qfgaussred_positive(GEN a)
+    GEN     qfsign(GEN a)
+
+    # alglin3.c
+
+    GEN     apply0(GEN f, GEN A)
+    GEN     diagonal(GEN x)
+    GEN     diagonal_shallow(GEN x)
+    GEN     extract0(GEN x, GEN l1, GEN l2)
+    GEN     genapply(void *E, GEN (*f)(void *E, GEN x), GEN A)
+    GEN     genindexselect(void *E, long (*f)(void *E, GEN x), GEN A)
+    GEN     genselect(void *E, long (*f)(void *E, GEN x), GEN A)
+    GEN     gtomat(GEN x)
+    GEN     gtrans(GEN x)
+    GEN     matmuldiagonal(GEN x, GEN d)
+    GEN     matmultodiagonal(GEN x, GEN y)
+    GEN     matslice0(GEN A, long x1, long x2, long y1, long y2)
+    GEN     parapply(GEN V, GEN C)
+    GEN     parselect(GEN C, GEN D, long flag)
+    GEN     select0(GEN A, GEN f, long flag)
+    GEN     shallowextract(GEN x, GEN L)
+    GEN     shallowtrans(GEN x)
+    GEN     vecapply(void *E, GEN (*f)(void* E, GEN x), GEN x)
+    GEN     veccatapply(void *E, GEN (*f)(void* E, GEN x), GEN x)
+    GEN     veccatselapply(void *Epred, long (*pred)(void* E, GEN x), void *Efun,
+                                GEN (*fun)(void* E, GEN x), GEN A)
+    GEN     vecrange(GEN a, GEN b)
+    GEN     vecrangess(long a, long b)
+    GEN     vecselapply(void *Epred, long (*pred)(void* E, GEN x), void *Efun,
+                                GEN (*fun)(void* E, GEN x), GEN A)
+    GEN     vecselect(void *E, long (*f)(void* E, GEN x), GEN A)
+    GEN     vecslice0(GEN A, long y1, long y2)
+    GEN     vecsum(GEN v)
 
     # anal.c
 
-    void    addhelp(char *e, char *s)
+    void    addhelp(const char *e, char *s)
+    void    alias0(const char *s, const char *old)
+    GEN     compile_str(const char *s)
+    GEN     chartoGENstr(char c)
     long    delete_var()
-    long    fetch_user_var(char *s)
+    entree* fetch_named_var(const char *s)
+    long    fetch_user_var(const char *s)
     long    fetch_var()
-    GEN     gp_read_str(char *s)
-    void    kill0(char *e)
-    void    name_var(long n, char *s)
+    GEN     fetch_var_value(long vx, GEN t)
+    GEN     gp_read_str(const char *t)
+    entree* install(void *f, const char *name, const char *code)
+    entree* is_entry(const char *s)
+    void    kill0(const char *e)
+    long    manage_var(long n, entree *ep)
+    void    pari_var_init()
+    long    pari_var_next()
+    long    pari_var_next_temp()
+    void    pari_var_create(entree *ep)
+    void    name_var(long n, const char *s)
     GEN     readseq(char *t)
-    GEN     strtoGENstr(char *s)
+    GEN*    safegel(GEN x, long l)
+    long*   safeel(GEN x, long l)
+    GEN*    safelistel(GEN x, long l)
+    GEN*    safegcoeff(GEN x, long a, long b)
+    GEN     strntoGENstr(const char *s, long n0)
+    GEN     strtoGENstr(const char *s)
+    GEN     strtoi(const char *s)
+    GEN     strtor(const char *s, long prec)
     GEN     type0(GEN x)
 
+    # aprcl.c
+
+    long    isprimeAPRCL(GEN N)
+
+    # Qfb.c
+
+    GEN     Qfb0(GEN x, GEN y, GEN z, GEN d, long prec)
+    void    check_quaddisc(GEN x, long *s, long *r, const char *f)
+    void    check_quaddisc_imag(GEN x, long *r, const char *f)
+    void    check_quaddisc_real(GEN x, long *r, const char *f)
+    long    cornacchia(GEN d, GEN p, GEN *px, GEN *py)
+    long    cornacchia2(GEN d, GEN p, GEN *px, GEN *py)
+    GEN     nucomp(GEN x, GEN y, GEN l)
+    GEN     nudupl(GEN x, GEN l)
+    GEN     nupow(GEN x, GEN n)
+    GEN     primeform(GEN x, GEN p, long prec)
+    GEN     primeform_u(GEN x, ulong p)
+    GEN     qfbcompraw(GEN x, GEN y)
+    GEN     qfbpowraw(GEN x, long n)
+    GEN     qfbred0(GEN x, long flag, GEN D, GEN isqrtD, GEN sqrtD)
+    GEN     qfbsolve(GEN Q, GEN n)
+    GEN     qfi(GEN x, GEN y, GEN z)
+    GEN     qfi_1(GEN x)
+    GEN     qficomp(GEN x, GEN y)
+    GEN     qficompraw(GEN x, GEN y)
+    GEN     qfipowraw(GEN x, long n)
+    GEN     qfisolvep(GEN Q, GEN p)
+    GEN     qfisqr(GEN x)
+    GEN     qfisqrraw(GEN x)
+    GEN     qfr(GEN x, GEN y, GEN z, GEN d)
+    GEN     qfr3_comp(GEN x, GEN y, qfr_data *S)
+    GEN     qfr3_pow(GEN x, GEN n, qfr_data *S)
+    GEN     qfr3_red(GEN x, qfr_data *S)
+    GEN     qfr3_rho(GEN x, qfr_data *S)
+    GEN     qfr3_to_qfr(GEN x, GEN z)
+    GEN     qfr5_comp(GEN x, GEN y, qfr_data *S)
+    GEN     qfr5_dist(GEN e, GEN d, long prec)
+    GEN     qfr5_pow(GEN x, GEN n, qfr_data *S)
+    GEN     qfr5_red(GEN x, qfr_data *S)
+    GEN     qfr5_rho(GEN x, qfr_data *S)
+    GEN     qfr5_to_qfr(GEN x, GEN d0)
+    GEN     qfr_1(GEN x)
+    void    qfr_data_init(GEN D, long prec, qfr_data *S)
+    GEN     qfr_to_qfr5(GEN x, long prec)
+    GEN     qfrcomp(GEN x, GEN y)
+    GEN     qfrcompraw(GEN x, GEN y)
+    GEN     qfrpow(GEN x, GEN n)
+    GEN     qfrpowraw(GEN x, long n)
+    GEN     qfrsolvep(GEN Q, GEN p)
+    GEN     qfrsqr(GEN x)
+    GEN     qfrsqrraw(GEN x)
+    GEN     quadgen(GEN x)
+    GEN     quadpoly(GEN x)
+    GEN     quadpoly0(GEN x, long v)
+    GEN     redimag(GEN x)
+    GEN     redreal(GEN x)
+    GEN     redrealnod(GEN x, GEN isqrtD)
+    GEN     rhoreal(GEN x)
+    GEN     rhorealnod(GEN x, GEN isqrtD)
+
     # arith1.c
 
-    GEN     bestappr0(GEN x, GEN a, GEN b)
+    ulong   Fl_order(ulong a, ulong o, ulong p)
+    ulong   Fl_powu(ulong x, ulong n, ulong p)
+    ulong   Fl_sqrt(ulong a, ulong p)
+    GEN     Fp_factored_order(GEN a, GEN o, GEN p)
+    int     Fp_ispower(GEN x, GEN K, GEN p)
+    GEN     Fp_log(GEN a, GEN g, GEN ord, GEN p)
+    GEN     Fp_order(GEN a, GEN o, GEN p)
+    GEN     Fp_pow(GEN a, GEN n, GEN m)
+    GEN     Fp_pows(GEN A, long k, GEN N)
+    GEN     Fp_powu(GEN x, ulong k, GEN p)
+    GEN     Fp_sqrt(GEN a, GEN p)
+    GEN     Fp_sqrtn(GEN a, GEN n, GEN p, GEN *zetan)
+    GEN     Z_chinese(GEN a, GEN b, GEN A, GEN B)
+    GEN     Z_chinese_all(GEN a, GEN b, GEN A, GEN B, GEN *pC)
+    GEN     Z_chinese_coprime(GEN a, GEN b, GEN A, GEN B, GEN C)
+    GEN     Z_chinese_post(GEN a, GEN b, GEN C, GEN U, GEN d)
+    void    Z_chinese_pre(GEN A, GEN B, GEN *pC, GEN *pU, GEN *pd)
+    GEN     Z_factor_listP(GEN N, GEN L)
+    long    Z_isanypower(GEN x, GEN *y)
+    long    Z_isfundamental(GEN x)
+    long    Z_ispow2(GEN x)
+    long    Z_ispowerall(GEN x, ulong k, GEN *pt)
+    long    Z_issquareall(GEN x, GEN *pt)
+    long    Zp_issquare(GEN a, GEN p)
     GEN     bestappr(GEN x, GEN k)
-    long    cgcd(long a,long b)
-    void    check_quaddisc(GEN x, long *s, long *r, char *f)
+    GEN     bestapprPade(GEN x, long B)
+    long    cgcd(long a, long b)
     GEN     chinese(GEN x, GEN y)
-    GEN     classno2(GEN x)
+    GEN     chinese1(GEN x)
+    GEN     chinese1_coprime_Z(GEN x)
     GEN     classno(GEN x)
-    long    clcm(long a,long b)
+    GEN     classno2(GEN x)
+    long    clcm(long a, long b)
     GEN     contfrac0(GEN x, GEN b, long flag)
+    GEN     contfracpnqn(GEN x, long n)
     GEN     fibo(long n)
     GEN     gboundcf(GEN x, long k)
-    GEN     gissquareall(GEN x, GEN *pt)
-    GEN     gissquare(GEN x)
-    GEN     gcf2(GEN b, GEN x)
     GEN     gcf(GEN x)
-    GEN     quadunit(GEN x)
+    GEN     gcf2(GEN b, GEN x)
+    bb_field *get_Fp_field(void **E, GEN p)
+    ulong   pgener_Fl(ulong p)
+    ulong   pgener_Fl_local(ulong p, GEN L)
+    GEN     pgener_Fp(GEN p)
+    GEN     pgener_Fp_local(GEN p, GEN L)
+    ulong   pgener_Zl(ulong p)
+    GEN     pgener_Zp(GEN p)
     long    gisanypower(GEN x, GEN *pty)
-    GEN     gisprime(GEN x, long flag)
-    GEN     gispseudoprime(GEN x, long flag)
-    GEN     gkronecker(GEN x, GEN y)
-    GEN     gnextprime(GEN n)
-    GEN     gprecprime(GEN n)
-    GEN     quadregulator(GEN x, long prec)
+    GEN     gissquare(GEN x)
+    GEN     gissquareall(GEN x, GEN *pt)
     GEN     hclassno(GEN x)
-    long    hilbert0 "hilbert"(GEN x, GEN y, GEN p)
-    long    Z_isfundamental(GEN x)
+    long    hilbert(GEN x, GEN y, GEN p)
+    long    hilbertii(GEN x, GEN y, GEN p)
+    long    isfundamental(GEN x)
+    long    ispolygonal(GEN x, GEN S, GEN *N)
     long    ispower(GEN x, GEN k, GEN *pty)
-    long    isprimeAPRCL(GEN N)
-    long    isprime(GEN x)
-    long    ispseudoprime(GEN x, long flag)
+    long    isprimepower(GEN x, GEN *pty)
+    long    issquare(GEN x)
+    long    issquareall(GEN x, GEN *pt)
     long    krois(GEN x, long y)
+    long    kroiu(GEN x, ulong y)
     long    kronecker(GEN x, GEN y)
     long    krosi(long s, GEN x)
     long    kross(long x, long y)
     long    krouu(ulong x, ulong y)
     GEN     lcmii(GEN a, GEN b)
+    long    logint(GEN B, GEN y, GEN *ptq)
+    long    logint0(GEN B, GEN y, GEN *ptq)
     GEN     mpfact(long n)
-    GEN     mpfactr(long n, long prec)
-    GEN     Fp_pow(GEN a, GEN n, GEN m)
-    GEN     Fp_sqrt(GEN a, GEN p)
-    GEN     Fp_sqrtn(GEN a, GEN n, GEN p, GEN *zetan)
-    GEN     nucomp(GEN x, GEN y, GEN l)
-    GEN     nudupl(GEN x, GEN l)
-    GEN     nupow(GEN x, GEN n)
+    GEN     mulu_interval(ulong a, ulong b)
+    GEN     odd_prime_divisors(GEN q)
     GEN     order(GEN x)
     GEN     pnqn(GEN x)
-    GEN     primeform(GEN x, GEN p, long prec)
-    GEN     Qfb0(GEN x, GEN y, GEN z, GEN d, long prec)
-    GEN     qfbclassno0(GEN x,long flag)
-    GEN     qfbred0(GEN x, long flag, GEN D, GEN isqrtD, GEN sqrtD)
-    GEN     qfbsolve(GEN Q, GEN n)
-    GEN     qfi(GEN x, GEN y, GEN z)
-    GEN     qfr(GEN x, GEN y, GEN z, GEN d)
+    GEN     qfbclassno0(GEN x, long flag)
     GEN     quaddisc(GEN x)
-    GEN     redimag(GEN x)
-    GEN     redreal(GEN x)
-    GEN     redrealnod(GEN x, GEN isqrtD)
-    GEN     rhoreal(GEN x)
-    GEN     rhorealnod(GEN x, GEN isqrtD)
-    ulong   Fl_sqrt(ulong a, ulong p)
-    GEN     znprimroot0(GEN m)
+    GEN     quadregulator(GEN x, long prec)
+    GEN     quadunit(GEN x)
+    ulong   rootsof1_Fl(ulong n, ulong p)
+    GEN     rootsof1_Fp(GEN n, GEN p)
+    GEN     rootsof1u_Fp(ulong n, GEN p)
+    GEN     sqrtint(GEN a)
+    ulong   ugcd(ulong a, ulong b)
+    long    uisprimepower(ulong n, ulong *p)
+    long    uissquare(ulong A)
+    long    uissquareall(ulong A, ulong *sqrtA)
+    long    unegisfundamental(ulong x)
+    long    uposisfundamental(ulong x)
+    GEN     znlog(GEN x, GEN g, GEN o)
+    GEN     znorder(GEN x, GEN o)
+    GEN     znprimroot(GEN m)
     GEN     znstar(GEN x)
 
     # arith2.c
 
-    GEN     addprimes(GEN primes)
-    long    bigomega(GEN n)
-    GEN     binaire(GEN x)
-    long    bittest(GEN x, long n)
-    GEN     boundfact(GEN n, long lim)
-    GEN     core(GEN n)
+    GEN     Z_smoothen(GEN N, GEN L, GEN *pP, GEN *pe)
+    GEN     boundfact(GEN n, ulong lim)
+    GEN     check_arith_pos(GEN n, char *f)
+    GEN     check_arith_non0(GEN n, char *f)
+    GEN     check_arith_all(GEN n, char *f)
+    GEN     clean_Z_factor(GEN f)
     GEN     corepartial(GEN n, long l)
-    GEN     core0(GEN n,long flag)
+    GEN     core0(GEN n, long flag)
     GEN     core2(GEN n)
     GEN     core2partial(GEN n, long l)
     GEN     coredisc(GEN n)
-    GEN     coredisc0(GEN n,long flag)
+    GEN     coredisc0(GEN n, long flag)
     GEN     coredisc2(GEN n)
-    GEN     Z_factor(GEN n)
+    GEN     digits(GEN N, GEN B)
     GEN     divisors(GEN n)
-    GEN     factorint(GEN n, long flag)
-    GEN     gbigomega(GEN n)
-    GEN     gbitand(GEN x, GEN y)
-    GEN     gbitneg(GEN x, long n)
-    GEN     gbitnegimply(GEN x, GEN y)
-    GEN     gbitor(GEN x, GEN y)
-    GEN     gbittest(GEN x, GEN n)
-    GEN     gbitxor(GEN x, GEN y)
-    GEN     gissquarefree(GEN x)
-    GEN     gmoebius(GEN n)
-    GEN     gnumbdiv(GEN n)
-    GEN     gomega(GEN n)
-    GEN     gsumdiv(GEN n)
-    GEN     gsumdivk(GEN n,long k)
-    char*   initprimes(ulong maxnum)
-    long    issquarefree(GEN x)
+    GEN     divisorsu(ulong n)
+    GEN     factor_pn_1(GEN p, ulong n)
+    GEN     factor_pn_1_limit(GEN p, long n, ulong lim)
+    GEN     factoru_pow(ulong n)
+    byteptr initprimes(ulong maxnum, long *lenp, ulong *lastp)
+    void    initprimetable(ulong maxnum)
+    ulong   init_primepointer_geq(ulong a, byteptr *pd)
+    ulong   init_primepointer_gt(ulong a, byteptr *pd)
+    ulong   init_primepointer_leq(ulong a, byteptr *pd)
+    ulong   init_primepointer_lt(ulong a, byteptr *pd)
+    int     is_Z_factor(GEN f)
+    int     is_Z_factornon0(GEN f)
+    int     is_Z_factorpos(GEN f)
     ulong   maxprime()
     void    maxprime_check(ulong c)
-    GEN     numbdiv(GEN n)
-    long    omega(GEN n)
-    GEN     geulerphi(GEN n)
-    GEN     prime(long n)
-    GEN     primepi(GEN x)
-    GEN     primes(long n)
-    GEN     removeprimes(GEN primes)
-    GEN     sumdiv(GEN n)
-    GEN     sumdivk(GEN n,long k)
+    GEN     sumdigits(GEN n)
+    ulong   sumdigitsu(ulong n)
+
+    # DedekZeta.c
+
+    GEN     glambdak(GEN nfz, GEN s, long prec)
+    GEN     gzetak(GEN nfz, GEN s, long prec)
+    GEN     gzetakall(GEN nfz, GEN s, long flag, long prec)
+    GEN     initzeta(GEN pol, long prec)
+    GEN     dirzetak(GEN nf, GEN b)
 
     # base1.c
 
-    GEN     bnfnewprec(GEN nf, long prec)
-    GEN     bnrnewprec(GEN bnr, long prec)
+    GEN     FpX_FpC_nfpoleval(GEN nf, GEN pol, GEN a, GEN p)
+    GEN     embed_T2(GEN x, long r1)
+    GEN     embednorm_T2(GEN x, long r1)
+    GEN     embed_norm(GEN x, long r1)
+    void    check_ZKmodule(GEN x, char *s)
     void    checkbid(GEN bid)
     GEN     checkbnf(GEN bnf)
     void    checkbnr(GEN bnr)
     void    checkbnrgen(GEN bnr)
+    void    checkabgrp(GEN v)
+    void    checksqmat(GEN x, long N)
     GEN     checknf(GEN nf)
     GEN     checknfelt_mod(GEN nf, GEN x, char *s)
+    void    checkprid(GEN bid)
     void    checkrnf(GEN rnf)
+    GEN     factoredpolred(GEN x, GEN fa)
+    GEN     factoredpolred2(GEN x, GEN fa)
     GEN     galoisapply(GEN nf, GEN aut, GEN x)
-    GEN     polgalois(GEN x, long prec)
     GEN     get_bnf(GEN x, long *t)
     GEN     get_bnfpol(GEN x, GEN *bnf, GEN *nf)
     GEN     get_nf(GEN x, long *t)
     GEN     get_nfpol(GEN x, GEN *nf)
-    GEN     glambdak(GEN nfz, GEN s, long prec)
-    GEN     gsmith(GEN x)
-    GEN     gsmithall(GEN x)
-    GEN     gzetak(GEN nfz, GEN s, long prec)
-    GEN     gzetakall(GEN nfz, GEN s, long flag, long prec)
-    GEN     mathnf0(GEN x,long flag)
-    GEN     matsnf0(GEN x,long flag)
+    GEN     get_prid(GEN x)
+    GEN     idealfrobenius(GEN nf, GEN gal, GEN pr)
+    GEN     idealramgroups(GEN nf, GEN gal, GEN pr)
+    GEN     nf_get_allroots(GEN nf)
+    long    nf_get_prec(GEN x)
+    GEN     nfcertify(GEN x)
+    GEN     nfgaloismatrix(GEN nf, GEN s)
+    GEN     nfinit(GEN x, long prec)
     GEN     nfinit0(GEN x, long flag, long prec)
+    GEN     nfinitall(GEN x, long flag, long prec)
+    GEN     nfinitred(GEN x, long prec)
+    GEN     nfinitred2(GEN x, long prec)
+    GEN     nfisincl(GEN a, GEN b)
+    GEN     nfisisom(GEN a, GEN b)
     GEN     nfnewprec(GEN nf, long prec)
-    GEN     rootsof1(GEN x)
+    GEN     nfnewprec_shallow(GEN nf, long prec)
+    GEN     nfpoleval(GEN nf, GEN pol, GEN a)
+    long    nftyp(GEN x)
+    GEN     polredord(GEN x)
+    GEN     polgalois(GEN x, long prec)
+    GEN     polred(GEN x)
+    GEN     polred0(GEN x, long flag, GEN p)
+    GEN     polred2(GEN x)
+    GEN     polredabs(GEN x)
+    GEN     polredabs0(GEN x, long flag)
+    GEN     polredabs2(GEN x)
+    GEN     polredabsall(GEN x, long flun)
+    GEN     polredbest(GEN x, long flag)
+    GEN     rnfpolredabs(GEN nf, GEN pol, long flag)
+    GEN     rnfpolredbest(GEN nf, GEN relpol, long flag)
+    GEN     smallpolred(GEN x)
+    GEN     smallpolred2(GEN x)
     GEN     tschirnhaus(GEN x)
+    GEN     ZX_Q_normalize(GEN pol, GEN *ptlc)
+    GEN     ZX_Z_normalize(GEN pol, GEN *ptk)
+    GEN     ZX_to_monic(GEN pol, GEN *lead)
+    GEN     ZX_primitive_to_monic(GEN pol, GEN *lead)
 
     # base2.c
 
-    GEN     base(GEN x, GEN *y)
-    GEN     base2(GEN x, GEN *y)
+    GEN     Fq_to_nf(GEN x, GEN modpr)
+    GEN     FqM_to_nfM(GEN z, GEN modpr)
+    GEN     FqV_to_nfV(GEN z, GEN modpr)
+    GEN     FqX_to_nfX(GEN x, GEN modpr)
+    GEN     Rg_nffix(const char *f, GEN T, GEN c, int lift)
+    GEN     RgV_nffix(const char *f, GEN T, GEN P, int lift)
+    GEN     RgX_nffix(const char *s, GEN nf, GEN x, int lift)
+    long    ZpX_disc_val(GEN f, GEN p)
+    GEN     ZpX_gcd(GEN f1, GEN f2, GEN p, GEN pm)
+    GEN     ZpX_reduced_resultant(GEN x, GEN y, GEN p, GEN pm)
+    GEN     ZpX_reduced_resultant_fast(GEN f, GEN g, GEN p, long M)
+    long    ZpX_resultant_val(GEN f, GEN g, GEN p, long M)
     void    checkmodpr(GEN modpr)
-    GEN     compositum(GEN pol1, GEN pol2)
-    GEN     compositum2(GEN pol1, GEN pol2)
-    GEN     discf(GEN x)
-    long    idealval(GEN nf,GEN ix,GEN vp)
-    GEN     idealprodprime(GEN nf, GEN L)
+    GEN     ZX_compositum_disjoint(GEN A, GEN B)
+    GEN     compositum(GEN P, GEN Q)
+    GEN     compositum2(GEN P, GEN Q)
+    GEN     nfdisc(GEN x)
     GEN     indexpartial(GEN P, GEN DP)
-    GEN     nfbasis(GEN x, GEN *y,long flag,GEN p)
-    GEN     nfbasis0(GEN x,long flag,GEN p)
-    GEN     nfdisc0(GEN x,long flag, GEN p)
+    GEN     modpr_genFq(GEN modpr)
+    GEN     nf_to_Fq_init(GEN nf, GEN *pr, GEN *T, GEN *p)
+    GEN     nf_to_Fq(GEN nf, GEN x, GEN modpr)
+    GEN     nfM_to_FqM(GEN z, GEN nf, GEN modpr)
+    GEN     nfV_to_FqV(GEN z, GEN nf, GEN modpr)
+    GEN     nfX_to_FqX(GEN x, GEN nf, GEN modpr)
+    GEN     nfbasis(GEN x, GEN *y, GEN p)
+    GEN     nfbasis0(GEN x, long flag, GEN p)
+    GEN     nfdisc0(GEN x, long flag, GEN p)
+    void    nfmaxord(nfmaxord_t *S, GEN T, long flag)
+    GEN     nfmodprinit(GEN nf, GEN pr)
     GEN     nfreducemodpr(GEN nf, GEN x, GEN modpr)
-    GEN     polcompositum0(GEN pol1, GEN pol2,long flag)
-    GEN     idealprimedec(GEN nf,GEN p)
+    GEN     polcompositum0(GEN P, GEN Q, long flag)
+    GEN     idealprimedec(GEN nf, GEN p)
     GEN     rnfbasis(GEN bnf, GEN order)
+    GEN     rnfdedekind(GEN nf, GEN T, GEN pr, long flag)
     GEN     rnfdet(GEN nf, GEN order)
     GEN     rnfdiscf(GEN nf, GEN pol)
-    GEN     rnfequation(GEN nf, GEN pol2)
-    GEN     rnfequation0(GEN nf, GEN pol2, long flall)
+    GEN     rnfequation(GEN nf, GEN pol)
+    GEN     rnfequation0(GEN nf, GEN pol, long flall)
     GEN     rnfequation2(GEN nf, GEN pol)
+    GEN     nf_rnfeq(GEN nf, GEN relpol)
+    GEN     nf_rnfeqsimple(GEN nf, GEN relpol)
+    GEN     rnfequationall(GEN A, GEN B, long *pk, GEN *pLPRS)
     GEN     rnfhnfbasis(GEN bnf, GEN order)
     long    rnfisfree(GEN bnf, GEN order)
-    GEN     rnflllgram(GEN nf, GEN pol, GEN order,long prec)
+    GEN     rnflllgram(GEN nf, GEN pol, GEN order, long prec)
     GEN     rnfpolred(GEN nf, GEN pol, long prec)
-    GEN     rnfpolredabs(GEN nf, GEN pol, long flag)
     GEN     rnfpseudobasis(GEN nf, GEN pol)
     GEN     rnfsimplifybasis(GEN bnf, GEN order)
+    GEN     rnfsteinitz(GEN nf, GEN order)
+    long    factorial_lval(ulong n, ulong p)
+    GEN     zk_to_Fq_init(GEN nf, GEN *pr, GEN *T, GEN *p)
+    GEN     zk_to_Fq(GEN x, GEN modpr)
+    GEN     zkmodprinit(GEN nf, GEN pr)
 
     # base3.c
 
+    GEN     Idealstar(GEN nf, GEN x, long flun)
+    GEN     RgC_to_nfC(GEN nf, GEN x)
+    GEN     RgM_to_nfM(GEN nf, GEN x)
+    GEN     RgX_to_nfX(GEN nf, GEN pol)
     GEN     algtobasis(GEN nf, GEN x)
     GEN     basistoalg(GEN nf, GEN x)
-    long    nfval(GEN nf, GEN x, GEN vp)
-    GEN     ideallist(GEN nf,long bound)
-    GEN     ideallist0(GEN nf,long bound, long flag)
+    GEN     ideallist(GEN nf, long bound)
+    GEN     ideallist0(GEN nf, long bound, long flag)
     GEN     ideallistarch(GEN nf, GEN list, GEN arch)
-    GEN     idealstar0(GEN nf, GEN x,long flag)
+    GEN     idealprincipalunits(GEN nf, GEN pr, long e)
+    GEN     idealstar0(GEN nf, GEN x, long flag)
+    GEN     indices_to_vec01(GEN archp, long r)
+    GEN     matalgtobasis(GEN nf, GEN x)
+    GEN     matbasistoalg(GEN nf, GEN x)
+    GEN     nf_to_scalar_or_alg(GEN nf, GEN x)
+    GEN     nf_to_scalar_or_basis(GEN nf, GEN x)
+    GEN     nfadd(GEN nf, GEN x, GEN y)
+    GEN     nfarchstar(GEN nf, GEN x, GEN arch)
+    GEN     nfdiv(GEN nf, GEN x, GEN y)
     GEN     nfdiveuc(GEN nf, GEN a, GEN b)
     GEN     nfdivrem(GEN nf, GEN a, GEN b)
+    GEN     nfinv(GEN nf, GEN x)
+    GEN     nfinvmodideal(GEN nf, GEN x, GEN ideal)
     GEN     nfmod(GEN nf, GEN a, GEN b)
-    GEN     reducemodinvertible(GEN x, GEN y)
+    GEN     nfmul(GEN nf, GEN x, GEN y)
+    GEN     nfmuli(GEN nf, GEN x, GEN y)
+    GEN     nfnorm(GEN nf, GEN x)
+    GEN     nfpow(GEN nf, GEN x, GEN k)
+    GEN     nfpow_u(GEN nf, GEN z, ulong n)
+    GEN     nfpowmodideal(GEN nf, GEN x, GEN k, GEN ideal)
+    GEN     nfsign(GEN nf, GEN alpha)
+    GEN     nfsign_arch(GEN nf, GEN alpha, GEN arch)
+    GEN     nfsign_from_logarch(GEN Larch, GEN invpi, GEN archp)
+    GEN     nfsqr(GEN nf, GEN x)
+    GEN     nfsqri(GEN nf, GEN x)
+    GEN     nftrace(GEN nf, GEN x)
+    long    nfval(GEN nf, GEN x, GEN vp)
+    GEN     polmod_nffix(const char *f, GEN rnf, GEN x, int lift)
+    GEN     polmod_nffix2(const char *f, GEN T, GEN relpol, GEN x, int lift)
+    int     pr_equal(GEN nf, GEN P, GEN Q)
+    GEN     rnfalgtobasis(GEN rnf, GEN x)
+    GEN     rnfbasistoalg(GEN rnf, GEN x)
+    GEN     rnfeltnorm(GEN rnf, GEN x)
+    GEN     rnfelttrace(GEN rnf, GEN x)
+    GEN     set_sign_mod_divisor(GEN nf, GEN x, GEN y, GEN idele, GEN sarch)
+    GEN     vec01_to_indices(GEN arch)
     GEN     vecmodii(GEN a, GEN b)
-    GEN     ideallog(GEN nf,GEN x,GEN bigideal)
-    GEN     zidealstar(GEN nf, GEN x)
-    GEN     znlog(GEN x, GEN g)
+    GEN     ideallog(GEN nf, GEN x, GEN bigideal)
+
+    GEN     multable(GEN nf, GEN x)
+    GEN     tablemul(GEN TAB, GEN x, GEN y)
+    GEN     tablemul_ei(GEN M, GEN x, long i)
+    GEN     tablemul_ei_ej(GEN M, long i, long j)
+    GEN     tablemulvec(GEN M, GEN x, GEN v)
+    GEN     tablesqr(GEN tab, GEN x)
+    GEN     ei_multable(GEN nf, long i)
+    long    ZC_nfval(GEN nf, GEN x, GEN P)
+    long    ZC_nfvalrem(GEN nf, GEN x, GEN P, GEN *t)
+    GEN     zk_multable(GEN nf, GEN x)
+    GEN     zk_scalar_or_multable(GEN, GEN x)
+    int     ZC_prdvd(GEN nf, GEN x, GEN P)
 
     # base4.c
 
-    GEN     nfreduce(GEN nf, GEN x, GEN ideal)
+    GEN     RM_round_maxrank(GEN G)
+    GEN     ZM_famat_limit(GEN fa, GEN limit)
+    GEN     famat_inv(GEN f)
+    GEN     famat_inv_shallow(GEN f)
+    GEN     famat_makecoprime(GEN nf, GEN g, GEN e, GEN pr, GEN prk, GEN EX)
+    GEN     famat_mul(GEN f, GEN g)
+    GEN     famat_pow(GEN f, GEN n)
+    GEN     famat_sqr(GEN f)
+    GEN     famat_reduce(GEN fa)
+    GEN     famat_to_nf(GEN nf, GEN f)
+    GEN     famat_to_nf_modideal_coprime(GEN nf, GEN g, GEN e, GEN id, GEN EX)
+    GEN     famat_to_nf_moddivisor(GEN nf, GEN g, GEN e, GEN bid)
+    GEN     famatsmall_reduce(GEN fa)
     GEN     idealtwoelt(GEN nf, GEN ix)
     GEN     idealtwoelt0(GEN nf, GEN ix, GEN a)
     GEN     idealtwoelt2(GEN nf, GEN x, GEN a)
     GEN     idealadd(GEN nf, GEN x, GEN y)
     GEN     idealaddmultoone(GEN nf, GEN list)
     GEN     idealaddtoone(GEN nf, GEN x, GEN y)
+    GEN     idealaddtoone_i(GEN nf, GEN x, GEN y)
     GEN     idealaddtoone0(GEN nf, GEN x, GEN y)
     GEN     idealappr(GEN nf, GEN x)
     GEN     idealappr0(GEN nf, GEN x, long fl)
     GEN     idealapprfact(GEN nf, GEN x)
     GEN     idealchinese(GEN nf, GEN x, GEN y)
     GEN     idealcoprime(GEN nf, GEN x, GEN y)
+    GEN     idealcoprimefact(GEN nf, GEN x, GEN fy)
     GEN     idealdiv(GEN nf, GEN x, GEN y)
-    GEN     idealdiv0(GEN nf, GEN x, GEN y,long flag)
+    GEN     idealdiv0(GEN nf, GEN x, GEN y, long flag)
     GEN     idealdivexact(GEN nf, GEN x, GEN y)
     GEN     idealdivpowprime(GEN nf, GEN x, GEN vp, GEN n)
     GEN     idealmulpowprime(GEN nf, GEN x, GEN vp, GEN n)
     GEN     idealfactor(GEN nf, GEN x)
     GEN     idealhnf(GEN nf, GEN x)
+    GEN     idealhnf_principal(GEN nf, GEN x)
+    GEN     idealhnf_shallow(GEN nf, GEN x)
+    GEN     idealhnf_two(GEN nf, GEN vp)
     GEN     idealhnf0(GEN nf, GEN a, GEN b)
     GEN     idealintersect(GEN nf, GEN x, GEN y)
     GEN     idealinv(GEN nf, GEN ix)
-    GEN     idealred0(GEN nf, GEN ix, GEN vdir)
+    GEN     idealred0(GEN nf, GEN I, GEN vdir)
     GEN     idealmul(GEN nf, GEN ix, GEN iy)
-    GEN     idealmul0(GEN nf, GEN ix, GEN iy, long flag, long prec)
+    GEN     idealmul0(GEN nf, GEN ix, GEN iy, long flag)
+    GEN     idealmul_HNF(GEN nf, GEN ix, GEN iy)
     GEN     idealmulred(GEN nf, GEN ix, GEN iy)
     GEN     idealnorm(GEN nf, GEN x)
+    GEN     idealnumden(GEN nf, GEN x)
     GEN     idealpow(GEN nf, GEN ix, GEN n)
-    GEN     idealpow0(GEN nf, GEN ix, GEN n, long flag, long prec)
-    GEN     idealpowred(GEN nf, GEN ix, GEN n,long prec)
+    GEN     idealpow0(GEN nf, GEN ix, GEN n, long flag)
+    GEN     idealpowred(GEN nf, GEN ix, GEN n)
     GEN     idealpows(GEN nf, GEN ideal, long iexp)
+    GEN     idealprodprime(GEN nf, GEN L)
+    GEN     idealsqr(GEN nf, GEN x)
     long    idealtyp(GEN *ideal, GEN *arch)
-    long    isideal(GEN nf,GEN x)
-    GEN     minideal(GEN nf,GEN ix,GEN vdir,long prec)
-    GEN     mul_content(GEN cx, GEN cy)
-    GEN     nfdetint(GEN nf,GEN pseudo)
+    long    idealval(GEN nf, GEN ix, GEN vp)
+    long    isideal(GEN nf, GEN x)
+    GEN     idealmin(GEN nf, GEN ix, GEN vdir)
+    GEN     nf_get_Gtwist(GEN nf, GEN vdir)
+    GEN     nf_get_Gtwist1(GEN nf, long i)
+    GEN     nfC_nf_mul(GEN nf, GEN v, GEN x)
+    GEN     nfdetint(GEN nf, GEN pseudo)
+    GEN     nfdivmodpr(GEN nf, GEN x, GEN y, GEN modpr)
     GEN     nfhnf(GEN nf, GEN x)
+    GEN     nfhnfmod(GEN nf, GEN x, GEN d)
     GEN     nfkermodpr(GEN nf, GEN x, GEN modpr)
+    GEN     nfmulmodpr(GEN nf, GEN x, GEN y, GEN modpr)
+    GEN     nfpowmodpr(GEN nf, GEN x, GEN k, GEN modpr)
+    GEN     nfreduce(GEN nf, GEN x, GEN ideal)
     GEN     nfsnf(GEN nf, GEN x)
     GEN     nfsolvemodpr(GEN nf, GEN a, GEN b, GEN modpr)
+    GEN     to_famat(GEN x, GEN y)
+    GEN     to_famat_shallow(GEN x, GEN y)
     GEN     vecdiv(GEN x, GEN y)
     GEN     vecinv(GEN x)
     GEN     vecmul(GEN x, GEN y)
@@ -812,169 +1964,225 @@ cdef extern from 'pari/pari.h':
 
     # base5.c
 
-    GEN     matalgtobasis(GEN nf, GEN x)
-    GEN     matbasistoalg(GEN nf, GEN x)
-    GEN     rnfalgtobasis(GEN rnf, GEN x)
-    GEN     rnfbasistoalg(GEN rnf, GEN x)
-    GEN     rnfelementabstorel(GEN rnf, GEN x)
-    GEN     rnfelementdown(GEN rnf, GEN x)
-    GEN     rnfelementreltoabs(GEN rnf, GEN x)
-    GEN     rnfelementup(GEN rnf, GEN x)
+    GEN     eltreltoabs(GEN rnfeq, GEN x)
+    GEN     eltabstorel(GEN eq, GEN P)
+    GEN     eltabstorel_lift(GEN rnfeq, GEN P)
+    void    nf_nfzk(GEN nf, GEN rnfeq, GEN *zknf, GEN *czknf)
+    GEN     nfeltup(GEN nf, GEN x, GEN zknf, GEN czknf)
+    GEN     rnfeltabstorel(GEN rnf, GEN x)
+    GEN     rnfeltdown(GEN rnf, GEN x)
+    GEN     rnfeltreltoabs(GEN rnf, GEN x)
+    GEN     rnfeltup(GEN rnf, GEN x)
     GEN     rnfidealabstorel(GEN rnf, GEN x)
     GEN     rnfidealdown(GEN rnf, GEN x)
-    GEN     rnfidealhermite(GEN rnf, GEN x)
-    GEN     rnfidealmul(GEN rnf,GEN x,GEN y)
+    GEN     rnfidealhnf(GEN rnf, GEN x)
+    GEN     rnfidealmul(GEN rnf, GEN x, GEN y)
     GEN     rnfidealnormabs(GEN rnf, GEN x)
     GEN     rnfidealnormrel(GEN rnf, GEN x)
     GEN     rnfidealreltoabs(GEN rnf, GEN x)
-    GEN     rnfidealtwoelement(GEN rnf,GEN x)
+    GEN     rnfidealtwoelement(GEN rnf, GEN x)
     GEN     rnfidealup(GEN rnf, GEN x)
     GEN     rnfinit(GEN nf, GEN pol)
 
+    # bb_group.c
+
+    GEN dlog_get_ordfa(GEN o)
+    GEN dlog_get_ord(GEN o)
+    GEN gen_PH_log(GEN a, GEN g, GEN ord, void *E, bb_group *grp)
+    GEN gen_Shanks_sqrtn(GEN a, GEN n, GEN q, GEN *zetan, void *E, bb_group *grp)
+    GEN gen_gener(GEN o, void *E, bb_group *grp)
+    GEN gen_ellgens(GEN d1, GEN d2, GEN m, void *E, bb_group *grp,
+                     GEN pairorder(void *E, GEN P, GEN Q, GEN m, GEN F))
+    GEN gen_ellgroup(GEN N, GEN F, GEN *pt_m, void *E, bb_group *grp,
+                     GEN pairorder(void *E, GEN P, GEN Q, GEN m, GEN F))
+    GEN gen_factored_order(GEN a, GEN o, void *E, bb_group *grp)
+    GEN gen_order(GEN x, GEN o, void *E, bb_group *grp)
+    GEN gen_select_order(GEN o, void *E, bb_group *grp)
+
+    GEN gen_plog(GEN x, GEN g0, GEN q, void *E, bb_group *grp)
+    GEN gen_pow(GEN x, GEN n, void *E, GEN (*sqr)(void*, GEN), GEN (*mul)(void*, GEN, GEN))
+    GEN gen_pow_i(GEN x, GEN n, void *E, GEN (*sqr)(void*, GEN), GEN (*mul)(void*, GEN, GEN))
+    GEN gen_pow_fold(GEN x, GEN n, void *E, GEN (*sqr)(void*, GEN), GEN (*msqr)(void*, GEN))
+    GEN gen_pow_fold_i(GEN x, GEN n, void *E, GEN (*sqr)(void*, GEN), GEN (*msqr)(void*, GEN))
+    GEN gen_powers(GEN x, long l, int use_sqr, void *E, GEN (*sqr)(void*, GEN), GEN (*mul)(void*, GEN, GEN), GEN (*one)(void*))
+    GEN gen_powu(GEN x, ulong n, void *E, GEN (*sqr)(void*, GEN), GEN (*mul)(void*, GEN, GEN))
+    GEN gen_powu_i(GEN x, ulong n, void *E, GEN (*sqr)(void*, GEN), GEN (*mul)(void*, GEN, GEN))
+    GEN gen_powu_fold(GEN x, ulong n, void *E, GEN (*sqr)(void*, GEN), GEN (*msqr)(void*, GEN))
+    GEN gen_powu_fold_i(GEN x, ulong n, void *E, GEN  (*sqr)(void*, GEN), GEN (*msqr)(void*, GEN))
+
     # bibli1.c
 
-    GEN     ZM_zc_mul(GEN x, GEN y)
-    GEN     ZM_zm_mul(GEN x, GEN y)
-    GEN     T2_from_embed(GEN x, long r1)
+    int     QR_init(GEN x, GEN *pB, GEN *pQ, GEN *pL, long prec)
+    GEN     R_from_QR(GEN x, long prec)
+    int     RgM_QR_init(GEN x, GEN *pB, GEN *pQ, GEN *pL, long prec)
+    GEN     Xadic_lindep(GEN x)
     GEN     algdep(GEN x, long n)
     GEN     algdep0(GEN x, long n, long bit)
-    GEN     factoredpolred(GEN x, GEN p)
-    GEN     factoredpolred2(GEN x, GEN p)
-    GEN     kerint(GEN x)
-    GEN     lindep(GEN x)
+    void    forqfvec0(GEN a, GEN BORNE, GEN code)
+    GEN     gaussred_from_QR(GEN x, long prec)
     GEN     lindep0(GEN x, long flag)
+    GEN     lindep(GEN x)
     GEN     lindep2(GEN x, long bit)
-    GEN     lll(GEN x, long prec)
-    GEN     lllgen(GEN x)
-    GEN     lllgram(GEN x, long prec)
-    GEN     lllgramgen(GEN x)
-    GEN     lllgramint(GEN x)
-    GEN     lllgramkerim(GEN x)
-    GEN     lllgramkerimgen(GEN x)
-    GEN     lllint(GEN x)
-    GEN     lllintpartial(GEN mat)
-    GEN     lllkerim(GEN x)
-    GEN     lllkerimgen(GEN x)
-    GEN     matkerint0(GEN x,long flag)
+    GEN     mathouseholder(GEN Q, GEN v)
+    GEN     matqr(GEN x, long flag, long prec)
     GEN     minim(GEN a, GEN borne, GEN stockmax)
-    GEN     qfrep0(GEN a, GEN borne, long flag)
-    GEN     qfminim0(GEN a, GEN borne, GEN stockmax,long flag, long prec)
+    GEN     minim_raw(GEN a, GEN borne, GEN stockmax)
     GEN     minim2(GEN a, GEN borne, GEN stockmax)
-    GEN     ordred(GEN x)
+    GEN     padic_lindep(GEN x)
     GEN     perf(GEN a)
-    GEN     polred(GEN x)
-    GEN     polred0(GEN x, long flag, GEN p)
-    GEN     polred2(GEN x)
-    GEN     polredabs(GEN x)
-    GEN     polredabs0(GEN x, long flag)
-    GEN     polredabs2(GEN x)
-    GEN     polredabsall(GEN x, long flun)
-    GEN     polredbest(GEN x, long flag)
-    GEN     qflll0(GEN x, long flag)
-    GEN     qflllgram0(GEN x, long flag)
-    GEN     smallpolred(GEN x)
-    GEN     smallpolred2(GEN x)
-    char    *stackmalloc(size_t N)
-    GEN     zncoppersmith(GEN P0, GEN N, GEN X, GEN B)
+    GEN     qfrep0(GEN a, GEN borne, long flag)
+    GEN     qfminim0(GEN a, GEN borne, GEN stockmax, long flag, long prec)
+    GEN     seralgdep(GEN s, long p, long r)
+    GEN     zncoppersmith(GEN P0, GEN N, GEN X, GEN B) 
 
     # bibli2.c
 
+    GEN     QXQ_reverse(GEN a, GEN T)
+    GEN     RgV_polint(GEN X, GEN Y, long v)
+    GEN     RgXQ_reverse(GEN a, GEN T)
+    GEN     ZV_indexsort(GEN L)
+    long    ZV_search(GEN x, GEN y)
+    GEN     ZV_sort(GEN L)
+    GEN     ZV_sort_uniq(GEN L)
+    GEN     ZV_union_shallow(GEN x, GEN y)
     GEN     binomial(GEN x, long k)
+    GEN     binomialuu(ulong n, ulong k)
+    int     cmp_nodata(void *data, GEN x, GEN y)
     int     cmp_prime_ideal(GEN x, GEN y)
     int     cmp_prime_over_p(GEN x, GEN y)
+    int     cmp_RgX(GEN x, GEN y)
+    int     cmp_universal(GEN x, GEN y)
     GEN     convol(GEN x, GEN y)
+    int     gen_cmp_RgX(void *data, GEN x, GEN y)
     GEN     polcyclo(long n, long v)
-    GEN     polcyclo_eval(long n, GEN v)
+    GEN     polcyclo_eval(long n, GEN x)
     GEN     dirdiv(GEN x, GEN y)
     GEN     dirmul(GEN x, GEN y)
-    GEN     dirzetak(GEN nf, GEN b)
-    long    gen_search(GEN x, GEN y, int flag, int (*cmp)(GEN,GEN))
-    GEN     gen_setminus(GEN set1, GEN set2, int (*cmp)(GEN,GEN))
-    GEN     gen_sort(GEN x, int flag, int (*cmp)(GEN,GEN))
-    GEN     genrand(GEN N)
-    GEN     getheap()
-    GEN     getrand()
+    GEN     gen_indexsort(GEN x, void *E, int (*cmp)(void*, GEN, GEN))
+    GEN     gen_indexsort_uniq(GEN x, void *E, int (*cmp)(void*, GEN, GEN))
+    long    gen_search(GEN x, GEN y, long flag, void *data, int (*cmp)(void*, GEN, GEN))
+    GEN     gen_setminus(GEN set1, GEN set2, int (*cmp)(GEN, GEN))
+    GEN     gen_sort(GEN x, void *E, int (*cmp)(void*, GEN, GEN))
+    void    gen_sort_inplace(GEN x, void *E, int (*cmp)(void*, GEN, GEN), GEN *perm)
+    GEN     gen_sort_uniq(GEN x, void *E, int (*cmp)(void*, GEN, GEN))
     long    getstack()
     long    gettime()
+    long    getabstime()
     GEN     gprec(GEN x, long l)
+    GEN     gprec_wtrunc(GEN x, long pr)
     GEN     gprec_w(GEN x, long pr)
-    GEN     ggrando(GEN x, long n)
     GEN     gtoset(GEN x)
     GEN     indexlexsort(GEN x)
     GEN     indexsort(GEN x)
+    GEN     indexvecsort(GEN x, GEN k)
     GEN     laplace(GEN x)
-    GEN     pollegendre(long n, long v)
     GEN     lexsort(GEN x)
     GEN     mathilbert(long n)
     GEN     matqpascal(long n, GEN q)
+    GEN     merge_factor(GEN fx, GEN fy, void *data, int (*cmp)(void *, GEN, GEN))
+    GEN     merge_sort_uniq(GEN x, GEN y, void *data, int (*cmp)(void *, GEN, GEN))
+    GEN     modreverse(GEN x)
     GEN     numtoperm(long n, GEN x)
     GEN     permtonum(GEN x)
+    GEN     polhermite(long n, long v)
+    GEN     polhermite_eval(long n, GEN x)
+    GEN     pollegendre(long n, long v)
+    GEN     pollegendre_eval(long n, GEN x)
     GEN     polint(GEN xa, GEN ya, GEN x, GEN *dy)
+    GEN     polchebyshev(long n, long kind, long v)
+    GEN     polchebyshev_eval(long n, long kind, GEN x)
+    GEN     polchebyshev1(long n, long v)
+    GEN     polchebyshev2(long n, long v)
     GEN     polrecip(GEN x)
-    GEN     modreverse(GEN x)
-    GEN     roots_to_pol(GEN a, long v)
+    GEN     setbinop(GEN f, GEN x, GEN y)
     GEN     setintersect(GEN x, GEN y)
     long    setisset(GEN x)
     GEN     setminus(GEN x, GEN y)
-    void    setrand(GEN seed)
     long    setsearch(GEN x, GEN y, long flag)
     GEN     setunion(GEN x, GEN y)
-    GEN     indexlexsort(GEN x)
-    GEN     indexsort(GEN x)
     GEN     sort(GEN x)
-    long    tablesearch(GEN T, GEN x, int (*cmp)(GEN,GEN))
-    GEN     tayl(GEN x, long v, long precdl)
-    GEN     polchebyshev1(long n, long v)
+    GEN     sort_factor(GEN y, void *data, int (*cmp)(void*, GEN, GEN))
+    GEN     stirling(long n, long m, long flag)
+    GEN     stirling1(ulong n, ulong m)
+    GEN     stirling2(ulong n, ulong m)
+    long    tablesearch(GEN T, GEN x, int (*cmp)(GEN, GEN))
+    GEN     vecbinome(long n)
+    long    vecsearch(GEN v, GEN x, GEN k)
     GEN     vecsort(GEN x, GEN k)
     GEN     vecsort0(GEN x, GEN k, long flag)
+    long    zv_search(GEN x, long y)
+
+    # bit.c
+
+    GEN     binaire(GEN x)
+    long    bittest(GEN x, long n)
+    GEN     gbitand(GEN x, GEN y)
+    GEN     gbitneg(GEN x, long n)
+    GEN     gbitnegimply(GEN x, GEN y)
+    GEN     gbitor(GEN x, GEN y)
+    GEN     gbittest(GEN x, long n)
+    GEN     gbitxor(GEN x, GEN y)
+    long    hammingweight(GEN n)
+    GEN     ibitand(GEN x, GEN y)
+    GEN     ibitnegimply(GEN x, GEN y)
+    GEN     ibitor(GEN x, GEN y)
+    GEN     ibitxor(GEN x, GEN y)
 
     # buch1.c
 
-    GEN     buchimag(GEN D, GEN gcbach, GEN gcbach2, GEN gCO)
-    GEN     buchreal(GEN D, GEN gsens, GEN gcbach, GEN gcbach2, GEN gRELSUP, long prec)
-    GEN     cgetalloc(long t, size_t l)
-    GEN     quadclassunit0(GEN x, long flag,GEN data, long prec)
+    GEN     Buchquad(GEN D, double c1, double c2, long prec)
+    GEN     quadclassunit0(GEN x, long flag, GEN data, long prec)
     GEN     quadhilbert(GEN D, long prec)
-    GEN     quadray(GEN bnf, GEN f, GEN flag, long prec)
+    GEN     quadray(GEN bnf, GEN f, long prec)
 
     # buch2.c
 
-    GEN     bnfinit0(GEN P,long flag,GEN data,long prec)
-    GEN     check_and_build_obj(GEN S, int tag, GEN (*build)(GEN))
-    GEN     isprincipal(GEN bignf, GEN x)
-    GEN     bnfisprincipal0(GEN bignf, GEN x,long flall)
-    GEN     isprincipalfact(GEN bnf,GEN P, GEN e, GEN C, long flag)
-    GEN     isprincipalforce(GEN bignf,GEN x)
-    GEN     isprincipalgen(GEN bignf, GEN x)
-    GEN     isprincipalgenforce(GEN bignf,GEN x)
+    GEN     bnfcompress(GEN bnf)
+    GEN     bnfinit0(GEN P, long flag, GEN data, long prec)
+    GEN     bnfnewprec(GEN nf, long prec)
+    GEN     bnfnewprec_shallow(GEN nf, long prec)
+    GEN     bnrnewprec(GEN bnr, long prec)
+    GEN     bnrnewprec_shallow(GEN bnr, long prec)
+    GEN     Buchall(GEN P, long flag, long prec)
+    GEN     Buchall_param(GEN P, double bach, double bach2, long nbrelpid, long flun, long prec)
+    GEN     isprincipal(GEN bnf, GEN x)
+    GEN     bnfisprincipal0(GEN bnf, GEN x, long flall)
+    GEN     isprincipalfact(GEN bnf, GEN C, GEN L, GEN f, long flag)
+    GEN     isprincipalfact_or_fail(GEN bnf, GEN C, GEN P, GEN e)
     GEN     bnfisunit(GEN bignf, GEN x)
-    GEN     regulator(GEN P,GEN data,long prec)
     GEN     signunits(GEN bignf)
+    GEN     nfsign_units(GEN bnf, GEN archp, int add_zu)
 
     # buch3.c
 
-    GEN     bnrconductor(GEN arg0,GEN arg1,GEN arg2,GEN flag)
-    GEN     bnrconductorofchar(GEN bnr,GEN chi)
-    GEN     bnrdisc0(GEN arg0, GEN arg1, GEN arg2, long flag)
-    GEN     bnrdisclist0(GEN bnf,GEN borne, GEN arch, long all)
-    long    bnrisconductor(GEN arg0,GEN arg1,GEN arg2)
+    GEN     ABC_to_bnr(GEN A, GEN B, GEN C, GEN *H, int gen)
+    GEN     Buchray(GEN bnf, GEN module, long flag)
+    GEN     bnrclassno(GEN bignf, GEN ideal)
+    GEN     bnrclassno0(GEN A, GEN B, GEN C)
+    GEN     bnrclassnolist(GEN bnf, GEN listes)
+    GEN     bnrconductor0(GEN A, GEN B, GEN C, long flag)
+    GEN     bnrconductor(GEN bnr, GEN H0, long flag)
+    GEN     bnrconductorofchar(GEN bnr, GEN chi)
+    GEN     bnrdisc0(GEN A, GEN B, GEN C, long flag)
+    GEN     bnrdisc(GEN bnr, GEN H, long flag)
+    GEN     bnrdisclist0(GEN bnf, GEN borne, GEN arch)
+    GEN     bnrinit0(GEN bignf, GEN ideal, long flag)
+    long    bnrisconductor0(GEN A, GEN B, GEN C)
+    long    bnrisconductor(GEN bnr, GEN H)
+    GEN     bnrisprincipal(GEN bnf, GEN x, long flag)
+    GEN     bnrsurjection(GEN bnr1, GEN bnr2)
     GEN     buchnarrow(GEN bignf)
     long    bnfcertify(GEN bnf)
-    GEN     conductor(GEN bnr,GEN subgroup,long all)
+    long    bnfcertify0(GEN bnf, long flag)
     GEN     decodemodule(GEN nf, GEN fa)
-    GEN     discrayabs(GEN bnr,GEN subgroup)
-    GEN     discrayabscond(GEN bnr,GEN subgroup)
-    GEN     discrayabslist(GEN bnf,GEN listes)
-    GEN     discrayabslistarch(GEN bnf, GEN arch, long bound)
-    GEN     discrayabslistlong(GEN bnf, long bound)
-    GEN     discrayrel(GEN bnr,GEN subgroup)
-    GEN     discrayrelcond(GEN bnr,GEN subgroup)
-    GEN     isprincipalray(GEN bignf, GEN x)
-    GEN     bnrisprincipal(GEN bignf, GEN x,long flall)
-    GEN     isprincipalraygen(GEN bignf, GEN x)
-    GEN     bnrclassno(GEN bignf,GEN ideal)
-    GEN     bnrclassnolist(GEN bnf,GEN listes)
-    GEN     rnfconductor(GEN bnf, GEN polrel, long flag)
+    GEN     discrayabslist(GEN bnf, GEN listes)
+    GEN     discrayabslistarch(GEN bnf, GEN arch, ulong bound)
+    GEN     discrayabslistlong(GEN bnf, ulong bound)
+    GEN     idealmoddivisor(GEN bnr, GEN x)
+    GEN     isprincipalray(GEN bnf, GEN x)
+    GEN     isprincipalraygen(GEN bnf, GEN x)
+    GEN     rnfconductor(GEN bnf, GEN polrel)
+    long    rnfisabelian(GEN nf, GEN pol)
     GEN     rnfnormgroup(GEN bnr, GEN polrel)
     GEN     subgrouplist0(GEN bnr, GEN indexbound, long all)
 
@@ -982,146 +2190,312 @@ cdef extern from 'pari/pari.h':
 
     GEN     bnfisnorm(GEN bnf, GEN x, long flag)
     GEN     rnfisnorm(GEN S, GEN x, long flag)
-    GEN     rnfisnorminit(GEN T, GEN relpol, int galois)
-    GEN     bnfissunit(GEN bnf,GEN suni,GEN x)
-    GEN     bnfsunit(GEN bnf,GEN s,long PREC)
-    long    nfhilbert(GEN bnf,GEN a,GEN b)
-    long    nfhilbert0(GEN bnf,GEN a,GEN b,GEN p)
+    GEN     rnfisnorminit(GEN bnf, GEN relpol, int galois)
+    GEN     bnfissunit(GEN bnf, GEN suni, GEN x)
+    GEN     bnfsunit(GEN bnf, GEN s, long PREC)
+    long    nfhilbert(GEN bnf, GEN a, GEN b)
+    long    nfhilbert0(GEN bnf, GEN a, GEN b, GEN p)
+    long    hyperell_locally_soluble(GEN pol, GEN p)
+    long    nf_hyperell_locally_soluble(GEN nf, GEN pol, GEN p)
 
     # compile.c
 
+    GEN     closure_deriv(GEN G)
+    long    localvars_find(GEN pack, entree *ep)
+    GEN     localvars_read_str(const char *str, GEN pack)
+    GEN     snm_closure(entree *ep, GEN data)
+    GEN     strtoclosure(const char *s, long n, ...)
     GEN     strtofunction(const char *s)
 
+    # concat.c
+
+    GEN     concat(GEN x, GEN y)
+    GEN     concat1(GEN x)
+    GEN     matconcat(GEN v)
+    GEN     shallowconcat(GEN x, GEN y)
+    GEN     shallowconcat1(GEN x)
+    GEN     shallowmatconcat(GEN v)
+    GEN     vconcat(GEN A, GEN B)
+
     # default.c
 
     extern int d_SILENT, d_ACKNOWLEDGE, d_INITRC, d_RETURN
-    GEN     default0(char *a, char *b)
-    long    getrealprecision()
-    GEN     sd_TeXstyle(char *v, long flag)
-    GEN     sd_breakloop(char *v, long flag)
-    GEN     sd_colors(char *v, long flag)
-    GEN     sd_compatible(char *v, long flag)
-    GEN     sd_datadir(char *v, long flag)
-    GEN     sd_debug(char *v, long flag)
-    GEN     sd_debugfiles(char *v, long flag)
-    GEN     sd_debugmem(char *v, long flag)
-    GEN     sd_echo(char *v, long flag)
-    GEN     sd_factor_add_primes(char *v, long flag)
-    GEN     sd_factor_proven(char *v, long flag)
-    GEN     sd_format(char *v, long flag)
-    GEN     sd_graphcolormap(char *v, long flag)
-    GEN     sd_graphcolors(char *v, long flag)
-    GEN     sd_help(char *v, long flag)
-    GEN     sd_histsize(char *v, long flag)
-    GEN     sd_lines(char *v, long flag)
-    GEN     sd_log(char *v, long flag)
-    GEN     sd_logfile(char *v, long flag)
-    GEN     sd_new_galois_format(char *v, long flag)
-    GEN     sd_output(char *v, long flag)
-    GEN     sd_parisize(char *v, long flag)
-    GEN     sd_path(char *v, long flag)
-    GEN     sd_prettyprinter(char *v, long flag)
-    GEN     sd_primelimit(char *v, long flag)
-    GEN     sd_prompt(char *v, long flag)
-    GEN     sd_prompt_cont(char *v, long flag)
-    GEN     sd_psfile(char *v, long flag)
-    GEN     sd_realprecision(char *v, long flag)
-    GEN     sd_recover(char *v, long flag)
-    GEN     sd_rl(char *v, long flag)
-    GEN     sd_secure(char *v, long flag)
-    GEN     sd_seriesprecision(char *v, long flag)
-    GEN     sd_simplify(char *v, long flag)
-    GEN     sd_strictmatch(char *v, long flag)
-    GEN     sd_timer(char *v, long flag)
-    long    setrealprecision(long n, long *prec)
+
+    GEN default0(const char *a, char *b)
+    long getrealprecision()
+    int pari_is_default(const char *s)
+    GEN sd_TeXstyle(const char *v, long flag)
+    GEN sd_colors(const char *v, long flag)
+    GEN sd_compatible(const char *v, long flag)
+    GEN sd_datadir(const char *v, long flag)
+    GEN sd_debug(const char *v, long flag)
+    GEN sd_debugfiles(const char *v, long flag)
+    GEN sd_debugmem(const char *v, long flag)
+    GEN sd_factor_add_primes(const char *v, long flag)
+    GEN sd_factor_proven(const char *v, long flag)
+    GEN sd_format(const char *v, long flag)
+    GEN sd_histsize(const char *v, long flag)
+    GEN sd_log(const char *v, long flag)
+    GEN sd_logfile(const char *v, long flag)
+    GEN sd_nbthreads(const char *v, long flag)
+    GEN sd_new_galois_format(const char *v, long flag)
+    GEN sd_output(const char *v, long flag)
+    GEN sd_parisize(const char *v, long flag)
+    GEN sd_path(const char *v, long flag)
+    GEN sd_prettyprinter(const char *v, long flag)
+    GEN sd_primelimit(const char *v, long flag)
+    GEN sd_realprecision(const char *v, long flag)
+    GEN sd_secure(const char *v, long flag)
+    GEN sd_seriesprecision(const char *v, long flag)
+    GEN sd_simplify(const char *v, long flag)
+    GEN sd_sopath(char *v, int flag)
+    GEN sd_strictargs(const char *v, long flag)
+    GEN sd_strictmatch(const char *v, long flag)
+    GEN sd_string(const char *v, long flag, char *s, char **f)
+    GEN sd_threadsize(const char *v, long flag)
+    GEN sd_toggle(const char *v, long flag, char *s, int *ptn)
+    GEN sd_ulong(const char *v, long flag, char *s, ulong *ptn, ulong Min, ulong Max, char **msg)
+    GEN setdefault(const char *s, char *v, long flag)
+    long setrealprecision(long n, long *prec)
 
     # ellanal.c
 
     GEN     ellanalyticrank(GEN e, GEN eps, long prec)
     GEN     ellL1(GEN e, long r, long prec)
 
+    # elldata.c
+
+    GEN     ellconvertname(GEN s)
+    GEN     elldatagenerators(GEN E)
+    GEN     ellidentify(GEN E)
+    GEN     ellsearch(GEN A)
+    GEN     ellsearchcurve(GEN name)
+    void    forell(void *E, long call(void*, GEN), long a, long b)
+
     # elliptic.c
 
-    GEN     addell(GEN e, GEN z1, GEN z2)
+    extern int t_ELL_Rg, t_ELL_Q, t_ELL_Qp, t_ELL_Fp, t_ELL_Fq
     GEN     akell(GEN e, GEN n)
     GEN     anell(GEN e, long n)
-    GEN     ellap(GEN e, GEN p)
+    GEN     anellsmall(GEN e, long n)
     GEN     bilhell(GEN e, GEN z1, GEN z2, long prec)
+    void    checkell(GEN e)
+    void    checkell_Fq(GEN e)
+    void    checkell_Q(GEN e)
+    void    checkell_Qp(GEN e)
+    void    checkellpt(GEN z)
+    void    checkell5(GEN e)
+    GEN     ellanal_globalred(GEN e, GEN *gr)
+    GEN     ellQ_get_N(GEN e)
+    void    ellQ_get_Nfa(GEN e, GEN *N, GEN *faN)
+    GEN     ellQp_Tate_uniformization(GEN E, long prec)
+    GEN     ellQp_u(GEN E, long prec)
+    GEN     ellQp_u2(GEN E, long prec)
+    GEN     ellQp_q(GEN E, long prec)
+    GEN     ellQp_ab(GEN E, long prec)
+    GEN     ellQp_root(GEN E, long prec)
+    GEN     ellR_ab(GEN E, long prec)
+    GEN     ellR_eta(GEN E, long prec)
+    GEN     ellR_omega(GEN x, long prec)
+    GEN     ellR_roots(GEN E, long prec)
+    GEN     elladd(GEN e, GEN z1, GEN z2)
+    GEN     ellap(GEN e, GEN p)
+    GEN     ellcard(GEN E, GEN p)
     GEN     ellchangecurve(GEN e, GEN ch)
-    GEN     ellap0(GEN e, GEN p, long flag)
+    GEN     elldivpol(GEN e, long n, long v)
     GEN     elleisnum(GEN om, long k, long flag, long prec)
     GEN     elleta(GEN om, long prec)
-    GEN     ellheight0(GEN e, GEN a, long flag,long prec)
-    GEN     ellinit0(GEN x,long flag,long prec)
+    GEN     ellff_get_card(GEN E)
+    GEN     ellff_get_gens(GEN E)
+    GEN     ellff_get_group(GEN E)
+    GEN     ellff_get_o(GEN x)
+    GEN     ellff_get_p(GEN E)
+    GEN     ellfromj(GEN j)
+    GEN     ellgenerators(GEN E)
+    GEN     ellglobalred(GEN e1)
+    GEN     ellgroup(GEN E, GEN p)
+    GEN     ellgroup0(GEN E, GEN p, long flag)
+    GEN     ellheight0(GEN e, GEN a, long flag, long prec)
+    GEN     ellheegner(GEN e)
+    GEN     ellinit(GEN x, GEN p, long prec)
+    GEN     ellisoncurve(GEN e, GEN z)
+    GEN     elllseries(GEN e, GEN s, GEN A, long prec)
+    GEN     elllocalred(GEN e, GEN p1)
+    GEN     elllog(GEN e, GEN a, GEN g, GEN o)
     GEN     ellminimalmodel(GEN E, GEN *ptv)
+    GEN     ellmul(GEN e, GEN z, GEN n)
+    GEN     ellneg(GEN e, GEN z)
+    GEN     ellorder(GEN e, GEN p, GEN o)
+    GEN     ellordinate(GEN e, GEN x, long prec)
+    GEN     ellperiods(GEN w, long flag, long prec)
+    GEN     ellrandom(GEN e)
     long    ellrootno(GEN e, GEN p)
+    long    ellrootno_global(GEN e)
     GEN     ellsigma(GEN om, GEN z, long flag, long prec)
+    GEN     ellsub(GEN e, GEN z1, GEN z2)
+    GEN     elltaniyama(GEN e, long prec)
+    GEN     elltatepairing(GEN E, GEN t, GEN s, GEN m)
     GEN     elltors0(GEN e, long flag)
-    GEN     ellwp0(GEN e, GEN z, long flag, long precdl, long prec)
+    GEN     ellweilpairing(GEN E, GEN t, GEN s, GEN m)
+    GEN     ellwp(GEN w, GEN z, long prec)
+    GEN     ellwp0(GEN w, GEN z, long flag, long prec)
+    GEN     ellwpseries(GEN e, long v, long PRECDL)
     GEN     ellzeta(GEN om, GEN z, long prec)
+    GEN     ellchangeinvert(GEN w)
+    GEN     ellchangepoint(GEN x, GEN ch)
+    GEN     ellchangepointinv(GEN x, GEN ch)
+    GEN     elltors(GEN e)
+    GEN     expIxy(GEN x, GEN y, long prec)
+    GEN     genus2red(GEN Q, GEN P, GEN p)
     GEN     ghell(GEN e, GEN a, long prec)
-    GEN     ellglobalred(GEN e1)
-    GEN     elllocalred(GEN e, GEN p1)
-    GEN     elllseries(GEN e, GEN s, GEN A, long prec)
     GEN     mathell(GEN e, GEN x, long prec)
     int     oncurve(GEN e, GEN z)
-    GEN     ellordinate(GEN e, GEN x, long prec)
     GEN     orderell(GEN e, GEN p)
-    GEN     ellchangepoint(GEN x, GEN ch)
     GEN     pointell(GEN e, GEN z, long prec)
-    GEN     powell(GEN e, GEN z, GEN n)
-    GEN     subell(GEN e, GEN z1, GEN z2)
-    GEN     taniyama(GEN e)
-    GEN     weipell(GEN e, long precdl)
     GEN     zell(GEN e, GEN z, long prec)
 
+    # ellsea.c
+
+    GEN     Fp_ellcard_SEA(GEN a4, GEN a6, GEN p, long early_abort)
+    GEN     Fq_ellcard_SEA(GEN a4, GEN a6, GEN q, GEN T, GEN p, long early_abort)
+    GEN     ellmodulareqn(long l, long vx, long vy)
+    GEN     ellsea(GEN E, GEN p, long early_abort)
+
     # es.c
 
+    GEN     GENtoGENstr_nospace(GEN x)
     GEN     GENtoGENstr(GEN x)
     char*   GENtoTeXstr(GEN x)
     char*   GENtostr(GEN x)
+    char*   GENtostr_unquoted(GEN x)
     GEN     Str(GEN g)
     GEN     Strchr(GEN g)
     GEN     Strexpand(GEN g)
     GEN     Strtex(GEN g)
     void    brute(GEN g, char format, long dec)
     void    dbgGEN(GEN x, long nb)
+    void    error0(GEN g)
+    void    dbg_pari_heap()
     int     file_is_binary(FILE *f)
-    void    gpwritebin(char *filename, GEN x)
-    GEN     gp_read_file(char *filename)
-    GEN     gp_read_str(char *s)
-    void    killallfiles(int check)
+    void    err_flush()
+    void    err_printf(const char* pat, ...)
+    GEN     gp_getenv(const char *s)
+    GEN     gp_read_file(char *s)
     GEN     gp_read_stream(FILE *f)
+    GEN     gp_readvec_file(char *s)
+    GEN     gp_readvec_stream(FILE *f)
+    void    gpinstall(const char *s, char *code,
+                      char *gpname, char *lib)
+    GEN     gsprintf(const char *fmt, ...)
+    GEN     gvsprintf(const char *fmt, va_list ap)
+    char*   itostr(GEN x)
     void    matbrute(GEN g, char format, long dec)
-    char*   os_getenv(char *s)
+    char*   os_getenv(const char *s)
     void    (*os_signal(int sig, void (*f)(int)))(int)
     void    outmat(GEN x)
     void    output(GEN x)
-    char*   pari_strdup(char *s)
-    char*   pari_strndup(char *s, long n)
-    char*   pari_unique_filename(char *s)
-    void    pari_unlink(char *s)
+    char*   RgV_to_str(GEN g, long flag)
+    void    pari_add_hist(GEN z, long t)
+    void    pari_ask_confirm(const char *s)
+    void    pari_fclose(pariFILE *f)
     void    pari_flush()
-    void    pari_putc(char c)
-    void    pari_puts(char *s)
+    pariFILE* pari_fopen(const char *s, char *mode)
+    pariFILE* pari_fopen_or_fail(const char *s, char *mode)
+    pariFILE* pari_fopengz(const char *s)
+    void    pari_fprintf(FILE *file, char *fmt, ...)
+    void    pari_fread_chars(void *b, size_t n, FILE *f)
+    GEN     pari_get_hist(long p)
+    long    pari_get_histtime(long p)
+    char*   pari_get_homedir(const char *user)
+    int     pari_is_dir(const char *name)
+    int     pari_is_file(const char *name)
     int     pari_last_was_newline()
     void    pari_set_last_newline(int last)
-    #void    print(GEN g)   # syntax error
+    ulong   pari_nb_hist()
+    void    pari_printf(const char *fmt, ...)
+    void    pari_putc(char c)
+    void    pari_puts(const char *s)
+    pariFILE* pari_safefopen(const char *s, char *mode)
+    char*   pari_sprintf(const char *fmt, ...)
+    int     pari_stdin_isatty()
+    char*   pari_strdup(const char *s)
+    char*   pari_strndup(const char *s, long n)
+    char*   pari_unique_dir(const char *s)
+    char*   pari_unique_filename(const char *s)
+    void    pari_unlink(const char *s)
+    void    pari_vfprintf(FILE *file, char *fmt, va_list ap)
+    void    pari_vprintf(const char *fmt, va_list ap)
+    char*   pari_vsprintf(const char *fmt, va_list ap)
+    char*   path_expand(const char *s)
+    void    out_print0(PariOUT *out, char *sep, GEN g, long flag)
+    void    out_printf(PariOUT *out, char *fmt, ...)
+    void    out_putc(PariOUT *out, char c)
+    void    out_puts(PariOUT *out, char *s)
+    void    out_term_color(PariOUT *out, long c)
+    void    out_vprintf(PariOUT *out, char *fmt, va_list ap)
+    char*   pari_sprint0(const char *msg, GEN g, long flag)
+    #void    print(GEN g)
+    extern int f_RAW, f_PRETTYMAT, f_PRETTY, f_TEX
+    void    print0(GEN g, long flag)
     void    print1(GEN g)
+    void    printf0(const char *fmt, GEN args)
+    void    printsep(const char *s, GEN g, long flag)
+    void    printsep1(const char *s, GEN g, long flag)
     void    printtex(GEN g)
-    GEN     readbin(char *name, FILE *f)
-    void    switchin(char *name)
-    void    switchout(char *name)
+    char*   stack_sprintf(const char *fmt, ...)
+    char*   stack_strcat(const char *s, char *t)
+    char*   stack_strdup(const char *s)
+    void    strftime_expand(const char *s, char *buf, long max)
+    GEN     Strprintf(const char *fmt, GEN args)
+    FILE*   switchin(const char *name)
+    void    switchout(const char *name)
+    void    term_color(long c)
+    char*   term_get_color(char *s, long c)
     void    texe(GEN g, char format, long dec)
-    char*   type_name(long t)
-    void    write0(char *s, GEN g)
-    void    write1(char *s, GEN g)
-    void    writetex(char *s, GEN g)
+    char* type_name(long t)
+    void    warning0(GEN g)
+    void    write0(const char *s, GEN g)
+    void    write1(const char *s, GEN g)
+    void    writebin(const char *name, GEN x)
+    void    writetex(const char *s, GEN g)
 
     # eval.c
 
+    extern int br_NONE, br_BREAK, br_NEXT, br_MULTINEXT, br_RETURN
+    void    bincopy_relink(GEN C, GEN vi)
+    GEN     break0(long n)
     GEN     closure_callgen1(GEN C, GEN x)
+    GEN     closure_callgen2(GEN C, GEN x, GEN y)
+    GEN     closure_callgenall(GEN C, long n, ...)
     GEN     closure_callgenvec(GEN C, GEN args)
+    void    closure_callvoid1(GEN C, GEN x)
+    long    closure_context(long start, long level)
+    void    closure_disassemble(GEN n)
+    void    closure_err(long level)
+    GEN     closure_evalbrk(GEN C, long *status)
+    GEN     closure_evalgen(GEN C)
+    GEN     closure_evalnobrk(GEN C)
+    GEN     closure_evalres(GEN C)
+    void    closure_evalvoid(GEN C)
+    GEN     closure_trapgen(GEN C, long numerr)
+    GEN     copybin_unlink(GEN C)
+    GEN     get_lex(long vn)
+    GEN     gp_call(void *E, GEN x)
+    long    gp_callbool(void *E, GEN x)
+    long    gp_callvoid(void *E, GEN x)
+    GEN     gp_eval(void *E, GEN x)
+    long    gp_evalbool(void *E, GEN x)
+    GEN     gp_evalupto(void *E, GEN x)
+    long    gp_evalvoid(void *E, GEN x)
+    long    loop_break()
+    GEN     next0(long n)
+    GEN     pareval(GEN C)
+    GEN     parsum(GEN a, GEN b, GEN code, GEN x)
+    GEN     parvector(long n, GEN code)
+    void    pop_lex(long n)
+    void    push_lex(GEN a, GEN C)
+    GEN     return0(GEN x)
+    void    set_lex(long vn, GEN x)
 
     # FF.c
 
@@ -1132,12 +2506,22 @@ cdef extern from 'pari/pari.h':
     GEN     FF_Z_mul(GEN a, GEN b)
     GEN     FF_add(GEN a, GEN b)
     GEN     FF_charpoly(GEN x)
-    int     FF_equal0(GEN x)
-    int     FF_equal1(GEN x)
-    int     FF_equalm1(GEN x)
     GEN     FF_conjvec(GEN x)
     GEN     FF_div(GEN a, GEN b)
+    GEN     FF_ellcard(GEN E)
+    GEN     FF_ellgens(GEN E)
+    GEN     FF_ellgroup(GEN E)
+    GEN     FF_elllog(GEN E, GEN P, GEN Q, GEN o)
+    GEN     FF_ellmul(GEN E, GEN P, GEN n)
+    GEN     FF_ellorder(GEN E, GEN P, GEN o)
+    GEN     FF_ellrandom(GEN E)
+    GEN     FF_elltatepairing(GEN E, GEN P, GEN Q, GEN m)
+    GEN     FF_ellweilpairing(GEN E, GEN P, GEN Q, GEN m)
     int     FF_equal(GEN a, GEN b)
+    int     FF_equal0(GEN x)
+    int     FF_equal1(GEN x)
+    int     FF_equalm1(GEN x)
+    long    FF_f(GEN x)
     GEN     FF_inv(GEN a)
     long    FF_issquare(GEN x)
     long    FF_issquareall(GEN x, GEN *pt)
@@ -1155,15 +2539,27 @@ cdef extern from 'pari/pari.h':
     GEN     FF_p_i(GEN x)
     GEN     FF_pow(GEN x, GEN n)
     GEN     FF_primroot(GEN x, GEN *o)
+    GEN     FF_q(GEN x)
     int     FF_samefield(GEN x, GEN y)
     GEN     FF_sqr(GEN a)
     GEN     FF_sqrt(GEN a)
     GEN     FF_sqrtn(GEN x, GEN n, GEN *zetan)
     GEN     FF_sub(GEN x, GEN y)
+    GEN     FF_to_F2xq(GEN x)
+    GEN     FF_to_F2xq_i(GEN x)
+    GEN     FF_to_Flxq(GEN x)
+    GEN     FF_to_Flxq_i(GEN x)
     GEN     FF_to_FpXQ(GEN x)
     GEN     FF_to_FpXQ_i(GEN x)
     GEN     FF_trace(GEN x)
     GEN     FF_zero(GEN a)
+    GEN     FFM_FFC_mul(GEN M, GEN C, GEN ff)
+    GEN     FFM_det(GEN M, GEN ff)
+    GEN     FFM_image(GEN M, GEN ff)
+    GEN     FFM_inv(GEN M, GEN ff)
+    GEN     FFM_ker(GEN M, GEN ff)
+    GEN     FFM_mul(GEN M, GEN N, GEN ff)
+    long    FFM_rank(GEN M, GEN ff)
     GEN     FFX_factor(GEN f, GEN x)
     GEN     FFX_roots(GEN f, GEN x)
     GEN     Z_FF_div(GEN a, GEN b)
@@ -1172,11 +2568,19 @@ cdef extern from 'pari/pari.h':
     GEN     fforder(GEN x, GEN o)
     GEN     ffprimroot(GEN x, GEN *o)
     GEN     ffrandom(GEN ff)
-    int     is_Z_factor(GEN f)
+    int     Rg_is_FF(GEN c, GEN *ff)
+    int     RgC_is_FFC(GEN x, GEN *ff)
+    int     RgM_is_FFM(GEN x, GEN *ff)
+    GEN     p_to_FF(GEN p, long v)
 
     # galconj.c
 
     GEN     checkgal(GEN gal)
+    GEN     checkgroup(GEN g, GEN *S)
+    GEN     embed_disc(GEN r, long r1, long prec)
+    GEN     embed_roots(GEN r, long r1)
+    GEN     galois_group(GEN gal)
+    GEN     galoisconj(GEN nf, GEN d)
     GEN     galoisconj0(GEN nf, long flag, GEN d, long prec)
     GEN     galoisexport(GEN gal, long format)
     GEN     galoisfixedfield(GEN gal, GEN v, long flag, long y)
@@ -1191,113 +2595,174 @@ cdef extern from 'pari/pari.h':
     GEN     vandermondeinverse(GEN L, GEN T, GEN den, GEN prep)
 
     # gen1.c
-
+    GEN     conjvec(GEN x, long prec)
     GEN     gadd(GEN x, GEN y)
     GEN     gaddsg(long x, GEN y)
+    GEN     gconj(GEN x)
     GEN     gdiv(GEN x, GEN y)
+    GEN     gdivgs(GEN x, long s)
+    GEN     ginv(GEN x)
     GEN     gmul(GEN x, GEN y)
+    GEN     gmul2n(GEN x, long n)
+    GEN     gmulsg(long s, GEN y)
     GEN     gsqr(GEN x)
     GEN     gsub(GEN x, GEN y)
+    GEN     gsubsg(long x, GEN y)
+    GEN     inv_ser(GEN b)
+    GEN     mulcxI(GEN x)
+    GEN     mulcxmI(GEN x)
+    GEN     ser_normalize(GEN x)
+
+    # galpol.c
+
+    GEN     galoisnbpol(long a)
+    GEN     galoisgetpol(long a, long b, long s)
 
     # gen2.c
 
-    GEN     ZX_mul(GEN x, GEN y)
+    GEN     gassoc_proto(GEN f(GEN, GEN), GEN, GEN)
+    GEN     map_proto_G(GEN f(GEN), GEN x)
+    GEN     map_proto_lG(long f(GEN), GEN x)
+    GEN     map_proto_lGL(long f(GEN, long), GEN x, long y)
+
+    long    Q_pval(GEN x, GEN p)
+    long    Q_pvalrem(GEN x, GEN p, GEN *y)
+    long    RgX_val(GEN x)
+    long    RgX_valrem(GEN x, GEN *z)
+    long    RgX_valrem_inexact(GEN x, GEN *Z)
+    int     ZV_Z_dvd(GEN v, GEN p)
+    long    ZV_pval(GEN x, GEN p)
+    long    ZV_pvalrem(GEN x, GEN p, GEN *px)
+    long    ZV_lval(GEN x, ulong p)
+    long    ZV_lvalrem(GEN x, ulong p, GEN *px)
+    long    ZX_lvalrem(GEN x, ulong p, GEN *px)
+    long    ZX_lval(GEN x, ulong p)
+    long    ZX_pval(GEN x, GEN p)
+    long    ZX_pvalrem(GEN x, GEN p, GEN *px)
+    long    Z_lval(GEN n, ulong p)
+    long    Z_lvalrem(GEN n, ulong p, GEN *py)
+    long    Z_lvalrem_stop(GEN *n, ulong p, int *stop)
+    long    Z_pval(GEN n, GEN p)
+    long    Z_pvalrem(GEN x, GEN p, GEN *py)
     GEN     cgetp(GEN x)
+    GEN     cvstop2(long s, GEN y)
     GEN     cvtop(GEN x, GEN p, long l)
     GEN     cvtop2(GEN x, GEN y)
     GEN     gabs(GEN x, long prec)
     void    gaffect(GEN x, GEN y)
     void    gaffsg(long s, GEN x)
-    GEN     gclone(GEN x)
     int     gcmp(GEN x, GEN y)
-    int     gcmpsg(long x, GEN y)
     int     gequal0(GEN x)
     int     gequal1(GEN x)
+    int     gequalX(GEN x)
     int     gequalm1(GEN x)
+    int     gcmpsg(long x, GEN y)
     GEN     gcvtop(GEN x, GEN p, long r)
     int     gequal(GEN x, GEN y)
     int     gequalsg(long s, GEN x)
     long    gexpo(GEN x)
-    long    ggval(GEN x, GEN p)
+    long    gvaluation(GEN x, GEN p)
+    int     gidentical(GEN x, GEN y)
     long    glength(GEN x)
     GEN     gmax(GEN x, GEN y)
+    GEN     gmaxgs(GEN x, long y)
     GEN     gmin(GEN x, GEN y)
+    GEN     gmings(GEN x, long y)
     GEN     gneg(GEN x)
     GEN     gneg_i(GEN x)
-    GEN     greffe(GEN x, long l, long use_stack)
+    GEN     RgX_to_ser(GEN x, long l)
+    GEN     RgX_to_ser_inexact(GEN x, long l)
     int     gsigne(GEN x)
-    GEN     gtofp(GEN z, long prec)
     GEN     gtolist(GEN x)
     long    gtolong(GEN x)
     int     lexcmp(GEN x, GEN y)
-    GEN     listcreate()
     GEN     listinsert(GEN list, GEN object, long index)
-    void    listkill(GEN list)
+    void    listpop(GEN L, long index)
     GEN     listput(GEN list, GEN object, long index)
-    GEN     listsort(GEN list, long flag)
+    void    listsort(GEN list, long flag)
     GEN     matsize(GEN x)
+    GEN     mklistcopy(GEN x)
     GEN     normalize(GEN x)
     GEN     normalizepol(GEN x)
+    GEN     normalizepol_approx(GEN x, long lx)
+    GEN     normalizepol_lg(GEN x, long lx)
+    ulong   padic_to_Fl(GEN x, ulong p)
+    GEN     padic_to_Fp(GEN x, GEN Y)
+    GEN     quadtofp(GEN x, long l)
+    GEN     rfrac_to_ser(GEN x, long l)
     long    sizedigit(GEN x)
     long    u_lval(ulong x, ulong p)
     long    u_lvalrem(ulong x, ulong p, ulong *py)
+    long    u_lvalrem_stop(ulong *n, ulong p, int *stop)
+    long    u_pval(ulong x, GEN p)
     long    u_pvalrem(ulong x, GEN p, ulong *py)
+    long    vecindexmax(GEN x)
+    long    vecindexmin(GEN x)
+    GEN     vecmax0(GEN x, GEN *pv)
     GEN     vecmax(GEN x)
+    GEN     vecmin0(GEN x, GEN *pv)
     GEN     vecmin(GEN x)
-    long    Z_lval(GEN n, ulong p)
-    long    Z_lvalrem(GEN n, ulong p, GEN *py)
+    long    z_lval(long s, ulong p)
+    long    z_lvalrem(long s, ulong p, long *py)
     long    z_pval(long n, GEN p)
-    long    Z_pval(GEN n, GEN p)
-    long    Z_pvalrem(GEN x, GEN p, GEN *py)
+    long    z_pvalrem(long n, GEN p, long *py)
 
     # gen3.c
 
+    GEN     padic_to_Q(GEN x)
+    GEN     padic_to_Q_shallow(GEN x)
+    GEN     QpV_to_QV(GEN v)
+    GEN     RgM_mulreal(GEN x, GEN y)
+    GEN     RgX_RgM_eval_col(GEN x, GEN M, long c)
+    GEN     RgX_deflate_max(GEN x0, long *m)
+    GEN     RgX_integ(GEN x)
     GEN     ceil_safe(GEN x)
     GEN     ceilr(GEN x)
     GEN     centerlift(GEN x)
-    GEN     centerlift0(GEN x,long v)
+    GEN     centerlift0(GEN x, long v)
     GEN     compo(GEN x, long n)
-    GEN     deg1pol(GEN x1, GEN x0,long v)
+    GEN     deg1pol(GEN x1, GEN x0, long v)
+    GEN     deg1pol_shallow(GEN x1, GEN x0, long v)
     long    degree(GEN x)
     GEN     denom(GEN x)
     GEN     deriv(GEN x, long v)
-    GEN     RgX_deriv(GEN x)
     GEN     derivser(GEN x)
+    GEN     diffop(GEN x, GEN v, GEN dv)
+    GEN     diffop0(GEN x, GEN v, GEN dv, long n)
     GEN     diviiround(GEN x, GEN y)
     GEN     divrem(GEN x, GEN y, long v)
-    GEN     gand(GEN x, GEN y)
+    GEN     floor_safe(GEN x)
     GEN     gceil(GEN x)
     GEN     gcvtoi(GEN x, long *e)
+    GEN     gdeflate(GEN x, long v, long d)
     GEN     gdivent(GEN x, GEN y)
+    GEN     gdiventgs(GEN x, long y)
+    GEN     gdiventsg(long x, GEN y)
     GEN     gdiventres(GEN x, GEN y)
-    GEN     gdivgs(GEN x, long s)
     GEN     gdivmod(GEN x, GEN y, GEN *pr)
     GEN     gdivround(GEN x, GEN y)
+    int     gdvd(GEN x, GEN y)
     GEN     geq(GEN x, GEN y)
     GEN     geval(GEN x)
     GEN     gfloor(GEN x)
+    GEN     gtrunc2n(GEN x, long s)
     GEN     gfrac(GEN x)
     GEN     gge(GEN x, GEN y)
     GEN     ggrando(GEN x, long n)
     GEN     ggt(GEN x, GEN y)
     GEN     gimag(GEN x)
-    GEN     ginv(GEN x)
     GEN     gle(GEN x, GEN y)
     GEN     glt(GEN x, GEN y)
     GEN     gmod(GEN x, GEN y)
-    GEN     gmodulo(GEN x,GEN y)
     GEN     gmodgs(GEN x, long y)
-    GEN     gmodulo(GEN x,GEN y)
+    GEN     gmodsg(long x, GEN y)
+    GEN     gmodulo(GEN x, GEN y)
     GEN     gmodulsg(long x, GEN y)
     GEN     gmodulss(long x, long y)
-    GEN     gmul2n(GEN x, long n)
-    GEN     gmulsg(long s, GEN y)
     GEN     gne(GEN x, GEN y)
     GEN     gnot(GEN x)
-    GEN     gor(GEN x, GEN y)
     GEN     gpolvar(GEN y)
     long    gprecision(GEN x)
-    GEN     gram_matrix(GEN M)
     GEN     greal(GEN x)
     GEN     grndtoi(GEN x, long *e)
     GEN     ground(GEN x)
@@ -1307,6 +2772,8 @@ cdef extern from 'pari/pari.h':
     GEN     gsubstvec(GEN x, GEN v, GEN y)
     GEN     gtocol(GEN x)
     GEN     gtocol0(GEN x, long n)
+    GEN     gtocolrev(GEN x)
+    GEN     gtocolrev0(GEN x, long n)
     GEN     gtopoly(GEN x, long v)
     GEN     gtopolyrev(GEN x, long v)
     GEN     gtoser(GEN x, long v, long precdl)
@@ -1317,106 +2784,288 @@ cdef extern from 'pari/pari.h':
     GEN     gtovecsmall(GEN x)
     GEN     gtovecsmall0(GEN x, long n)
     GEN     gtrunc(GEN x)
-    int     gvar(GEN x)
-    int     gvar2(GEN x)
+    long    gvar(GEN x)
+    long    gvar2(GEN x)
     GEN     hqfeval(GEN q, GEN x)
     GEN     imag_i(GEN x)
-    GEN     int2n(long n)
     GEN     integ(GEN x, long v)
+    GEN     integser(GEN x)
     int     iscomplex(GEN x)
     int     isexactzero(GEN g)
+    int     isrationalzeroscalar(GEN g)
     int     isinexact(GEN x)
     int     isinexactreal(GEN x)
-    long    isint(GEN n, long *ptk)
+    int     isint(GEN n, GEN *ptk)
+    int     isrationalzero(GEN g)
     int     issmall(GEN n, long *ptk)
     GEN     lift(GEN x)
-    GEN     lift0(GEN x,long v)
-    GEN     lift_intern0(GEN x,long v)
-    GEN     truncr(GEN x)
+    GEN     lift0(GEN x, long v)
+    GEN     liftall(GEN x)
+    GEN     liftall_shallow(GEN x)
+    GEN     liftint(GEN x)
+    GEN     liftint_shallow(GEN x)
+    GEN     liftpol(GEN x)
+    GEN     liftpol_shallow(GEN x)
     GEN     mkcoln(long n, ...)
     GEN     mkintn(long n, ...)
     GEN     mkpoln(long n, ...)
     GEN     mkvecn(long n, ...)
+    GEN     mkvecsmalln(long n, ...)
+    GEN     mulreal(GEN x, GEN y)
     GEN     numer(GEN x)
-    GEN     padicappr(GEN f, GEN a)
     long    padicprec(GEN x, GEN p)
-    GEN     polcoeff0(GEN x,long n,long v)
+    long    padicprec_relative(GEN x)
+    GEN     polcoeff0(GEN x, long n, long v)
     GEN     polcoeff_i(GEN x, long n, long v)
-    long    poldegree(GEN x,long v)
+    long    poldegree(GEN x, long v)
+    long    RgX_degree(GEN x, long v)
     GEN     poleval(GEN x, GEN y)
-    GEN     pollead(GEN x,long v)
+    GEN     pollead(GEN x, long v)
     long    precision(GEN x)
-    GEN     precision0(GEN x,long n)
+    GEN     precision0(GEN x, long n)
+    GEN     qf_apply_RgM(GEN q, GEN M)
+    GEN     qf_apply_ZM(GEN q, GEN M)
+    GEN     qfbil(GEN x, GEN y, GEN q)
     GEN     qfeval(GEN q, GEN x)
+    GEN     qfevalb(GEN q, GEN x, GEN y)
+    GEN     qfnorm(GEN x, GEN q)
     GEN     real_i(GEN x)
-    GEN     real2n(long n, long prec)
-    GEN     recip(GEN x)
     GEN     round0(GEN x, GEN *pte)
     GEN     roundr(GEN x)
+    GEN     roundr_safe(GEN x)
     GEN     scalarpol(GEN x, long v)
+    GEN     scalarpol_shallow(GEN x, long v)
     GEN     scalarser(GEN x, long v, long prec)
+    GEN     ser_unscale(GEN P, GEN h)
+    GEN     serreverse(GEN x)
     GEN     simplify(GEN x)
+    GEN     simplify_shallow(GEN x)
     GEN     tayl(GEN x, long v, long precdl)
     GEN     toser_i(GEN x)
     GEN     trunc0(GEN x, GEN *pte)
+    GEN     uu32toi(ulong a, ulong b)
 
     # groupid.c
 
     long    group_ident(GEN G, GEN S)
+    long    group_ident_trans(GEN G, GEN S)
 
     # hash.c
 
-    ulong   hash_GEN(GEN x)
+    hashtable *hash_create(ulong minsize, ulong (*hash)(void*), int (*eq)(void*, void*), int use_stack)
+    void hash_insert(hashtable *h, void *k, void *v)
+    hashentry *hash_search(hashtable *h, void *k)
+    hashentry *hash_remove(hashtable *h, void *k)
+    void hash_destroy(hashtable *h)
+    ulong hash_str(const char *str)
+    ulong hash_str2(const char *s)
+    ulong hash_GEN(GEN x)
+
+    # hnf_snf.c
+
+    GEN     Frobeniusform(GEN V, long n)
+    GEN     RgM_hnfall(GEN A, GEN *pB, long remove)
+    GEN     ZM_hnf(GEN x)
+    GEN     ZM_hnfall(GEN A, GEN *ptB, long remove)
+    GEN     ZM_hnfcenter(GEN M)
+    GEN     ZM_hnflll(GEN A, GEN *ptB, int remove)
+    GEN     ZV_gcdext(GEN A)
+    GEN     ZM_hnfmod(GEN x, GEN d)
+    GEN     ZM_hnfmodall(GEN x, GEN dm, long flag)
+    GEN     ZM_hnfmodid(GEN x, GEN d)
+    GEN     ZM_hnfperm(GEN A, GEN *ptU, GEN *ptperm)
+    void    ZM_snfclean(GEN d, GEN u, GEN v)
+    GEN     ZM_snf(GEN x)
+    GEN     ZM_snf_group(GEN H, GEN *newU, GEN *newUi)
+    GEN     ZM_snfall(GEN x, GEN *ptU, GEN *ptV)
+    GEN     ZM_snfall_i(GEN x, GEN *ptU, GEN *ptV, int return_vec)
+    GEN     zlm_echelon(GEN x, long early_abort, ulong p, ulong pm)
+    GEN     ZpM_echelon(GEN x, long early_abort, GEN p, GEN pm)
+    GEN     gsmith(GEN x)
+    GEN     gsmithall(GEN x)
+    GEN     hnf(GEN x)
+    GEN     hnf_divscale(GEN A, GEN B, GEN t)
+    GEN     hnf_solve(GEN A, GEN B)
+    GEN     hnf_invimage(GEN A, GEN b)
+    GEN     hnfall(GEN x)
+    int     hnfdivide(GEN A, GEN B)
+    GEN     hnflll(GEN x)
+    GEN     hnfmerge_get_1(GEN A, GEN B)
+    GEN     hnfmod(GEN x, GEN d)
+    GEN     hnfmodid(GEN x, GEN p)
+    GEN     hnfperm(GEN x)
+    GEN     matfrobenius(GEN M, long flag, long v)
+    GEN     mathnf0(GEN x, long flag)
+    GEN     matsnf0(GEN x, long flag)
+    GEN     smith(GEN x)
+    GEN     smithall(GEN x)
+    GEN     smithclean(GEN z)
 
     # ifactor1.c
 
+    GEN     Z_factor(GEN n)
+    GEN     Z_factor_limit(GEN n, ulong all)
+    GEN     Z_factor_until(GEN n, GEN limit)
+    long    Z_issmooth(GEN m, ulong lim)
+    GEN     Z_issmooth_fact(GEN m, ulong lim)
+    long    Z_issquarefree(GEN x)
+    GEN     absi_factor(GEN n)
+    GEN     absi_factor_limit(GEN n, ulong all)
+    long    bigomega(GEN n)
+    GEN     core(GEN n)
+    ulong   coreu(ulong n)
+    GEN     eulerphi(GEN n)
+    ulong   eulerphiu(ulong n)
+    ulong   eulerphiu_fact(GEN f)
+    GEN     factorint(GEN n, long flag)
+    GEN     factoru(ulong n)
+    int     ifac_isprime(GEN x)
+    int     ifac_next(GEN *part, GEN *p, long *e)
+    int     ifac_read(GEN part, GEN *p, long *e)
+    void    ifac_skip(GEN part)
+    GEN     ifac_start(GEN n, int moebius)
     int     is_357_power(GEN x, GEN *pt, ulong *mask)
-    int     is_pth_power(GEN x, GEN *pt, ulong *curexp, ulong cutoffbits)
+    int     is_pth_power(GEN x, GEN *pt, forprime_t *T, ulong cutoffbits)
+    long    ispowerful(GEN n)
+    long    issquarefree(GEN x)
+    long    istotient(GEN n, GEN *px)
+    long    moebius(GEN n)
+    long    moebiusu(ulong n)
     GEN     nextprime(GEN n)
+    GEN     numdiv(GEN n)
+    long    omega(GEN n)
     GEN     precprime(GEN n)
+    GEN     sumdiv(GEN n)
+    GEN     sumdivk(GEN n, long k)
+    ulong   tridiv_bound(GEN n)
+    int     uis_357_power(ulong x, ulong *pt, ulong *mask)
+    int     uis_357_powermod(ulong x, ulong *mask)
+    long    uissquarefree(ulong n)
+    long    uissquarefree_fact(GEN f)
+    ulong   unextprime(ulong n)
+    ulong   uprecprime(ulong n)
+    GEN     usumdivkvec(ulong n, GEN K)
 
     # init.c
 
-    long    allocatemoremem(size_t newsize)
-    GEN     changevar(GEN x, GEN y)
-    void    pari_err(long numerr, ...)
-    long    err_catch(long errnum, jmp_buf *penv)
+    void    allocatemem(ulong newsize)
+    long    timer_delay(pari_timer *T)
+    long    timer_get(pari_timer *T)
+    void    timer_start(pari_timer *T)
+    int     chk_gerepileupto(GEN x)
+    GENbin* copy_bin(GEN x)
+    GENbin* copy_bin_canon(GEN x)
+    void    dbg_gerepile(pari_sp av)
+    void    dbg_gerepileupto(GEN q)
+    GEN     errname(GEN err)
+    GEN     gclone(GEN x)
+    GEN     gcloneref(GEN x)
+    void    gclone_refc(GEN x)
     GEN     gcopy(GEN x)
     GEN     gcopy_avma(GEN x, pari_sp *AVMA)
+    GEN     gcopy_lg(GEN x, long lx)
+    GEN     gerepile(pari_sp ltop, pari_sp lbot, GEN q)
+    void    gerepileallsp(pari_sp av, pari_sp tetpil, int n, ...)
+    void    gerepilecoeffssp(pari_sp av, pari_sp tetpil, long *g, int n)
+    void    gerepilemanysp(pari_sp av, pari_sp tetpil, GEN* g[], int n)
+    GEN     getheap()
+    void    gp_context_save(gp_context* rec)
+    void    gp_context_restore(gp_context* rec)
+    long    gsizeword(GEN x)
+    long    gsizebyte(GEN x)
     void    gunclone(GEN x)
-    void    msgtimer(char *format, ...)
-    GEN     newblock(long n)
+    void    gunclone_deep(GEN x)
+    GEN     listcopy(GEN x)
+    void    timer_printf(pari_timer *T, char *format, ...)
+    void    msgtimer(const char *format, ...)
+    long    name_numerr(const char *s)
+    GEN     newblock(size_t n)
+    char * numerr_name(long errnum)
+    GEN     obj_check(GEN S, long K)
+    GEN     obj_checkbuild(GEN S, long tag, GEN (*build)(GEN))
+    GEN     obj_checkbuild_padicprec(GEN S, long tag, GEN (*build)(GEN, long), long prec)
+    GEN     obj_checkbuild_prec(GEN S, long tag, GEN (*build)(GEN, long), long prec)
+    void    obj_free(GEN S)
+    GEN     obj_init(long d, long n)
+    GEN     obj_insert(GEN S, long K, GEN O)
+    GEN     obj_insert_shallow(GEN S, long K, GEN O)
+    void    pari_add_function(entree *ep)
+    void    pari_add_module(entree *ep)
+    void    pari_add_defaults_module(entree *ep)
+    void    pari_add_oldmodule(entree *ep)
     void    pari_close()
-    void    pari_init(size_t parisize, ulong maxprime)
+    void    pari_close_opts(ulong init_opts)
+    int     pari_daemon()
+    void    pari_err(int numerr, ...)
+    GEN     pari_err_last()
+    char *  pari_err2str(GEN err)
     void    pari_init_opts(size_t parisize, ulong maxprime, ulong init_opts)
-    long    gsizebyte(GEN x)
-    long    gsizeword(GEN x)
+    void    pari_init(size_t parisize, ulong maxprime)
+    void    pari_stackcheck_init(void *pari_stack_base)
+    void    pari_sig_init(void (*f)(int))
+    void    pari_thread_alloc(pari_thread *t, size_t s, GEN arg)
+    void    pari_thread_close()
+    void    pari_thread_free(pari_thread *t)
+    void    pari_thread_init()
+    GEN     pari_thread_start(pari_thread *t)
+    GEN     pari_version()
+    void    pari_warn(int numerr, ...)
+    GEN     trap0(const char *e, GEN f, GEN r)
+    void    shiftaddress(GEN x, long dec)
+    void    shiftaddress_canon(GEN x, long dec)
     long    timer()
     long    timer2()
+    void    traverseheap( void(*f)(GEN, void *), void *data )
 
     # intnum.c
 
-    GEN     intcirc(void *E, GEN (*eval) (GEN, void *), GEN a, GEN R, GEN tab, long prec)
-    GEN     intfouriercos(void *E, GEN (*eval) (GEN, void *), GEN a, GEN b, GEN x, GEN tab, long prec)
-    GEN     intfourierexp(void *E, GEN (*eval)(GEN, void*), GEN a, GEN b, GEN x, GEN tab, long prec)
-    GEN     intfouriersin(void *E, GEN (*eval) (GEN, void *), GEN a, GEN b, GEN x, GEN tab, long prec)
-    GEN     intfuncinit(void *E, GEN (*eval) (GEN, void *), GEN a, GEN b, long m, long flag, long prec)
-    GEN     intlaplaceinv(void *E, GEN (*eval) (GEN, void *), GEN sig, GEN x, GEN tab, long prec)
-    GEN     intmellininv(void *E, GEN (*eval) (GEN, void *), GEN sig, GEN x, GEN tab, long prec)
+    GEN     intcirc(void *E, GEN (*eval) (void *, GEN), GEN a, GEN R, GEN tab, long prec)
+    GEN     intfouriercos(void *E, GEN (*eval) (void *, GEN), GEN a, GEN b, GEN x, GEN tab, long prec)
+    GEN     intfourierexp(void *E, GEN (*eval)(void *, GEN), GEN a, GEN b, GEN x, GEN tab, long prec)
+    GEN     intfouriersin(void *E, GEN (*eval) (void *, GEN), GEN a, GEN b, GEN x, GEN tab, long prec)
+    GEN     intfuncinit(void *E, GEN (*eval) (void *, GEN), GEN a, GEN b, long m, long flag, long prec)
+    GEN     intlaplaceinv(void *E, GEN (*eval) (void *, GEN), GEN sig, GEN x, GEN tab, long prec)
+    GEN     intmellininv(void *E, GEN (*eval) (void *, GEN), GEN sig, GEN x, GEN tab, long prec)
     GEN     intmellininvshort(GEN sig, GEN x, GEN tab, long prec)
-    GEN     intnum(void *E, GEN (*eval) (GEN, void *), GEN a, GEN b, GEN tab, long prec)
+    GEN     intnum(void *E, GEN (*eval) (void *, GEN), GEN a, GEN b, GEN tab, long prec)
     GEN     intnuminit(GEN a, GEN b, long m, long prec)
-    GEN     intnuminitgen(void *E, GEN (*eval) (GEN, void *), GEN a, GEN b, long m, long flext, long prec)
-    GEN     intnumromb(void *E, GEN (*eval) (GEN, void *), GEN a, GEN b, long flag, long prec)
+    GEN     intnuminitgen(void *E, GEN (*eval) (void *, GEN), GEN a, GEN b, long m, long flext, long prec)
+    GEN     intnumromb(void *E, GEN (*eval) (void *, GEN), GEN a, GEN b, long flag, long prec)
     long    intnumstep(long prec)
-    GEN     sumnum(void *E, GEN (*f) (GEN, void *), GEN a, GEN sig, GEN tab, long flag, long prec)
-    GEN     sumnumalt(void *E, GEN (*f) (GEN, void *), GEN a, GEN s, GEN tab, long flag, long prec)
+    GEN     sumnum(void *E, GEN (*f) (void *, GEN), GEN a, GEN sig, GEN tab, long flag, long prec)
+    GEN     sumnumalt(void *E, GEN (*f) (void *, GEN), GEN a, GEN s, GEN tab, long flag, long prec)
     GEN     sumnuminit(GEN sig, long m, long sgn, long prec)
 
+    # krasner.c
+
+    GEN     padicfields0(GEN p, GEN n, long flag)
+    GEN     padicfields(GEN p, long m, long d, long flag)
+
     # kummer.c
 
     GEN     rnfkummer(GEN bnr, GEN subgroup, long all, long prec)
 
+    # lll.c
+
+    GEN     ZM_lll_norms(GEN x, double D, long flag, GEN *B)
+    GEN     kerint(GEN x)
+    GEN     lll(GEN x)
+    GEN     lllfp(GEN x, double D, long flag)
+    GEN     lllgen(GEN x)
+    GEN     lllgram(GEN x)
+    GEN     lllgramgen(GEN x)
+    GEN     lllgramint(GEN x)
+    GEN     lllgramkerim(GEN x)
+    GEN     lllgramkerimgen(GEN x)
+    GEN     lllint(GEN x)
+    GEN     lllintpartial(GEN mat)
+    GEN     lllintpartial_inplace(GEN mat)
+    GEN     lllkerim(GEN x)
+    GEN     lllkerimgen(GEN x)
+    GEN     matkerint0(GEN x, long flag)
+    GEN     qflll0(GEN x, long flag)
+    GEN     qflllgram0(GEN x, long flag)
+
     # members.c
 
     GEN     member_a1(GEN x)
@@ -1429,6 +3078,7 @@ cdef extern from 'pari/pari.h':
     GEN     member_b4(GEN x)
     GEN     member_b6(GEN x)
     GEN     member_b8(GEN x)
+    GEN     member_bid(GEN x)
     GEN     member_bnf(GEN x)
     GEN     member_c4(GEN x)
     GEN     member_c6(GEN x)
@@ -1453,19 +3103,26 @@ cdef extern from 'pari/pari.h':
     GEN     member_orders(GEN x)
     GEN     member_p(GEN x)
     GEN     member_pol(GEN x)
+    GEN     member_polabs(GEN x)
     GEN     member_reg(GEN x)
+    GEN     member_r1(GEN x)
+    GEN     member_r2(GEN x)
     GEN     member_roots(GEN x)
     GEN     member_sign(GEN x)
     GEN     member_t2(GEN x)
     GEN     member_tate(GEN x)
     GEN     member_tufu(GEN x)
     GEN     member_tu(GEN x)
-    GEN     member_w(GEN x)
     GEN     member_zk(GEN x)
     GEN     member_zkst(GEN bid)
 
     # mp.c
 
+    GEN     addmulii(GEN x, GEN y, GEN z)
+    GEN     addmulii_inplace(GEN x, GEN y, GEN z)
+    ulong   Fl_inv(ulong x, ulong p)
+    ulong   Fl_invsafe(ulong x, ulong p)
+    int     Fp_ratlift(GEN x, GEN m, GEN amax, GEN bmax, GEN *a, GEN *b)
     int     absi_cmp(GEN x, GEN y)
     int     absi_equal(GEN x, GEN y)
     int     absr_cmp(GEN x, GEN y)
@@ -1473,35 +3130,44 @@ cdef extern from 'pari/pari.h':
     GEN     addir_sign(GEN x, long sx, GEN y, long sy)
     GEN     addrr_sign(GEN x, long sx, GEN y, long sy)
     GEN     addsi_sign(long x, GEN y, long sy)
+    GEN     addui_sign(ulong x, GEN y, long sy)
     GEN     addsr(long x, GEN y)
-    GEN     addss(long x, long y)
+    GEN     addumului(ulong a, ulong b, GEN Y)
     void    affir(GEN x, GEN y)
     void    affrr(GEN x, GEN y)
     GEN     bezout(GEN a, GEN b, GEN *u, GEN *v)
-    long    cbezout(long a,long b,long *uu,long *vv)
+    long    cbezout(long a, long b, long *uu, long *vv)
     int     cmpii(GEN x, GEN y)
     int     cmprr(GEN x, GEN y)
-    int     cmpsi(long x, GEN y)
-    int     cmpui(ulong x, GEN y)
+    long    dblexpo(double x)
+    ulong   dblmantissa(double x)
     GEN     dbltor(double x)
     GEN     diviiexact(GEN x, GEN y)
-    GEN     diviuexact(GEN x, ulong y)
     GEN     divir(GEN x, GEN y)
     GEN     divis(GEN y, long x)
     GEN     divis_rem(GEN x, long y, long *rem)
     GEN     diviu_rem(GEN y, ulong x, ulong *rem)
+    GEN     diviuuexact(GEN x, ulong y, ulong z)
+    GEN     diviuexact(GEN x, ulong y)
     GEN     divri(GEN x, GEN y)
     GEN     divrr(GEN x, GEN y)
     GEN     divrs(GEN x, long y)
+    GEN     divru(GEN x, ulong y)
     GEN     divsi(long x, GEN y)
     GEN     divsr(long x, GEN y)
+    GEN     divur(ulong x, GEN y)
     GEN     dvmdii(GEN x, GEN y, GEN *z)
     int     equalii(GEN x, GEN y)
+    int     equalrr(GEN x, GEN y)
     GEN     floorr(GEN x)
     GEN     gcdii(GEN x, GEN y)
+    GEN     int2n(long n)
+    GEN     int2u(ulong n)
     GEN     int_normalize(GEN x, long known_zero_words)
     int     invmod(GEN a, GEN b, GEN *res)
-    ulong   Fl_inv(ulong x, ulong p)
+    ulong   invmod2BIL(ulong b)
+    GEN     invr(GEN b)
+    GEN     mantissa_real(GEN x, long *e)
     GEN     modii(GEN x, GEN y)
     void    modiiz(GEN x, GEN y, GEN z)
     GEN     mulii(GEN x, GEN y)
@@ -1513,29 +3179,58 @@ cdef extern from 'pari/pari.h':
     GEN     mului(ulong x, GEN y)
     GEN     mulur(ulong x, GEN y)
     GEN     muluu(ulong x, ulong y)
-    GEN     randomi(GEN x)
-    int     ratlift(GEN x, GEN m, GEN *a, GEN *b, GEN amax, GEN bmax)
+    GEN     muluui(ulong x, ulong y, GEN z)
+    GEN     remi2n(GEN x, long n)
     double  rtodbl(GEN x)
     GEN     shifti(GEN x, long n)
     GEN     sqri(GEN x)
-    #define sqrti(x) sqrtremi((x),NULL)
+    GEN     sqrr(GEN x)
+    GEN     sqrs(long x)
+    GEN     sqrtr_abs(GEN x)
     GEN     sqrtremi(GEN S, GEN *R)
+    GEN     sqru(ulong x)
     GEN     subsr(long x, GEN y)
     GEN     truedvmdii(GEN x, GEN y, GEN *z)
+    GEN     truedvmdis(GEN x, long y, GEN *z)
+    GEN     truedvmdsi(long x, GEN y, GEN *z)
+    GEN     trunc2nr(GEN x, long n)
+    GEN     mantissa2nr(GEN x, long n)
+    GEN     truncr(GEN x)
     ulong   umodiu(GEN y, ulong x)
     long    vals(ulong x)
 
     # nffactor.c
 
-    GEN     nffactor(GEN nf,GEN x)
-    GEN     nffactormod(GEN nf,GEN pol,GEN pr)
-    GEN     nfroots(GEN nf,GEN pol)
-    GEN     rnfcharpoly(GEN nf,GEN T,GEN alpha,int n)
-    GEN     rnfdedekind(GEN nf,GEN T,GEN pr)
+    GEN     FpC_ratlift(GEN P, GEN mod, GEN amax, GEN bmax, GEN denom)
+    GEN     FpM_ratlift(GEN M, GEN mod, GEN amax, GEN bmax, GEN denom)
+    GEN     FpX_ratlift(GEN P, GEN mod, GEN amax, GEN bmax, GEN denom)
+    GEN     nffactor(GEN nf, GEN x)
+    GEN     nffactormod(GEN nf, GEN pol, GEN pr)
+    GEN     nfgcd(GEN P, GEN Q, GEN nf, GEN den)
+    GEN     nfgcd_all(GEN P, GEN Q, GEN T, GEN den, GEN *Pnew)
+    GEN     nfroots(GEN nf, GEN pol)
+    GEN     polfnf(GEN a, GEN t)
+    GEN     rootsof1(GEN x)
+    GEN     rootsof1_kannan(GEN nf)
+
+    # paricfg.c
+
+    extern char *paricfg_datadir
+    extern char *paricfg_version
+    extern char *paricfg_buildinfo
+    extern long  paricfg_version_code
+    extern char *paricfg_vcsversion
+    extern char *paricfg_compiledate
+    extern char *paricfg_mt_engine
 
     # part.c
 
+    void    forpart(void *E, long call(void*, GEN), long k, GEN nbound, GEN abound)
+    void    forpart_init(forpart_t *T, long k, GEN abound, GEN nbound)
+    GEN     forpart_next(forpart_t *T)
+    GEN     forpart_prev(forpart_t *T)
     GEN     numbpart(GEN x)
+    GEN     partitions(long k, GEN nbound, GEN abound)
 
     # perm.c
 
@@ -1556,234 +3251,293 @@ cdef extern from 'pari/pari.h':
     long    group_perm_normalize(GEN N, GEN g)
     GEN     group_quotient(GEN G, GEN H)
     GEN     group_rightcoset(GEN G, GEN g)
+    GEN     group_set(GEN G, long n)
+    long    group_subgroup_isnormal(GEN G, GEN H)
     GEN     group_subgroups(GEN G)
-    GEN     groupelts_center(GEN S)
     GEN     groupelts_abelian_group(GEN S)
+    GEN     groupelts_center(GEN S)
+    GEN     groupelts_set(GEN G, long n)
     int     perm_commute(GEN p, GEN q)
     GEN     perm_cycles(GEN v)
     long    perm_order(GEN perm)
     GEN     perm_pow(GEN perm, long exp)
     GEN     quotient_group(GEN C, GEN G)
     GEN     quotient_perm(GEN C, GEN p)
+    GEN     quotient_subgroup_lift(GEN C, GEN H, GEN S)
+    GEN     subgroups_tableset(GEN S, long n)
+    long    tableset_find_index(GEN tbl, GEN set)
+    GEN     trivialgroup()
     GEN     vecperm_orbits(GEN v, long n)
+    GEN     vec_insert(GEN v, long n, GEN x)
+    int     vec_is1to1(GEN v)
+    int     vec_isconst(GEN v)
+    long    vecsmall_duplicate(GEN x)
+    long    vecsmall_duplicate_sorted(GEN x)
+    GEN     vecsmall_indexsort(GEN V)
     void    vecsmall_sort(GEN V)
     GEN     vecsmall_uniq(GEN V)
+    GEN     vecsmall_uniq_sorted(GEN V)
     GEN     vecvecsmall_indexsort(GEN x)
-    GEN     vecvecsmall_sort(GEN x)
     long    vecvecsmall_search(GEN x, GEN y, long flag)
+    GEN     vecvecsmall_sort(GEN x)
+    GEN     vecvecsmall_sort_uniq(GEN x)
+
+    # mt.c
+
+    void    mt_broadcast(GEN code)
+    void    mt_sigint_block()
+    void    mt_sigint_unblock()
+    void    mt_queue_end(pari_mt *pt)
+    GEN     mt_queue_get(pari_mt *pt, long *jobid, long *pending)
+    void    mt_queue_start(pari_mt *pt, GEN worker)
+    void    mt_queue_submit(pari_mt *pt, long jobid, GEN work)
+    void    pari_mt_init()
+    void    pari_mt_close()
 
     # polarit1.c
 
-    long    Flx_nbfact(GEN z, ulong p)
-    long    Flx_nbroots(GEN f, ulong p)
-    GEN     FpX_degfact(GEN f, GEN p)
-    long    FpX_is_irred(GEN f, GEN p)
-    long    FpX_is_squarefree(GEN f, GEN p)
-    long    FpX_is_totally_split(GEN f, GEN p)
-    GEN     FpX_factor(GEN f, GEN p)
-    long    FpX_nbfact(GEN f, GEN p)
-    long    FpX_nbroots(GEN f, GEN p)
-    GEN     FpXQX_gcd(GEN P, GEN Q, GEN T, GEN p)
-    GEN     FqX_factor(GEN x, GEN T, GEN p)
-    GEN     FqX_gcd(GEN P, GEN Q, GEN T, GEN p)
-    long    FqX_is_squarefree(GEN P, GEN T, GEN p)
-    long    FqX_nbfact(GEN u, GEN T, GEN p)
-    long    FqX_nbroots(GEN f, GEN T, GEN p)
-    GEN     random_FpX(long d, long v, GEN p)
-    GEN     FpX_roots(GEN f, GEN p)
-    GEN     padicappr(GEN f, GEN a)
-    GEN     factcantor(GEN x, GEN p)
-    GEN     factmod(GEN f, GEN p)
-    GEN     factorff(GEN f, GEN p, GEN a)
-    GEN     factormod0(GEN f, GEN p, long flag)
-    GEN     factorpadic0(GEN f,GEN p,long r,long flag)
+    GEN     ZX_Zp_root(GEN f, GEN a, GEN p, long prec)
+    GEN     Zp_appr(GEN f, GEN a)
+    GEN     factorpadic0(GEN f, GEN p, long r, long flag)
     GEN     factorpadic(GEN x, GEN p, long r)
-    int     gdvd(GEN x, GEN y)
+    GEN     gdeuc(GEN x, GEN y)
+    GEN     grem(GEN x, GEN y)
+    GEN     padicappr(GEN f, GEN a)
     GEN     poldivrem(GEN x, GEN y, GEN *pr)
-    GEN     rootmod(GEN f, GEN p)
-    GEN     rootmod0(GEN f, GEN p,long flag)
-    GEN     rootmod2(GEN f, GEN p)
     GEN     rootpadic(GEN f, GEN p, long r)
     GEN     rootpadicfast(GEN f, GEN p, long e)
-    GEN     simplefactmod(GEN f, GEN p)
 
     # polarit2.c
 
     GEN     Q_content(GEN x)
     GEN     Q_denom(GEN x)
     GEN     Q_div_to_int(GEN x, GEN c)
+    GEN     Q_gcd(GEN x, GEN y)
+    GEN     Q_mul_to_int(GEN x, GEN c)
     GEN     Q_muli_to_int(GEN x, GEN d)
     GEN     Q_primitive_part(GEN x, GEN *ptc)
     GEN     Q_primpart(GEN x)
     GEN     Q_remove_denom(GEN x, GEN *ptd)
+    GEN     RgXQ_charpoly(GEN x, GEN T, long v)
+    GEN     RgXQ_inv(GEN x, GEN y)
+    GEN     RgX_disc(GEN x)
     GEN     RgX_extgcd(GEN x, GEN y, GEN *U, GEN *V)
-    GEN     ZX_squff(GEN f, GEN *ex)
+    GEN     RgX_extgcd_simple(GEN a, GEN b, GEN *pu, GEN *pv)
+    GEN     RgX_gcd(GEN x, GEN y)
+    GEN     RgX_gcd_simple(GEN x, GEN y)
+    int     RgXQ_ratlift(GEN y, GEN x, long amax, long bmax, GEN *P, GEN *Q)
+    GEN     RgX_resultant_all(GEN P, GEN Q, GEN *sol)
+    long    RgX_type(GEN x, GEN *ptp, GEN *ptpol, long *ptpa)
+    void    RgX_type_decode(long x, long *t1, long *t2)
+    int     RgX_type_is_composite(long t)
+    GEN     ZX_content(GEN x)
     GEN     centermod(GEN x, GEN p)
     GEN     centermod_i(GEN x, GEN p, GEN ps2)
     GEN     centermodii(GEN x, GEN p, GEN po2)
     GEN     content(GEN x)
     GEN     deg1_from_roots(GEN L, long v)
-    GEN     discsr(GEN x)
-    GEN     divide_conquer_prod(GEN x, GEN (*mul)(GEN,GEN))
+    GEN     divide_conquer_assoc(GEN x, void *data, GEN (*mul)(void*, GEN, GEN))
+    GEN     divide_conquer_prod(GEN x, GEN (*mul)(GEN, GEN))
     GEN     factor(GEN x)
-    GEN     factor0(GEN x,long flag)
-    GEN     factorback(GEN fa,GEN nf)
+    GEN     factor0(GEN x, long flag)
+    GEN     factorback(GEN fa)
+    GEN     factorback2(GEN fa, GEN e)
+    GEN     famat_mul_shallow(GEN f, GEN g)
     GEN     gbezout(GEN x, GEN y, GEN *u, GEN *v)
-    GEN     ggcd0(GEN x, GEN )
-    GEN     gdeflate(GEN x, long v, long d)
     GEN     gdivexact(GEN x, GEN y)
+    GEN     gen_factorback(GEN L, GEN e, GEN (*_mul)(void*, GEN, GEN), GEN (*_pow)(void*, GEN, GEN), void *data)
     GEN     ggcd(GEN x, GEN y)
+    GEN     ggcd0(GEN x, GEN y)
     GEN     ginvmod(GEN x, GEN y)
-    GEN     gisirreducible(GEN x)
     GEN     glcm(GEN x, GEN y)
     GEN     glcm0(GEN x, GEN y)
-    GEN     gen_pow(GEN,GEN,void*,GEN (*sqr)(void*,GEN),GEN (*mul)(void*,GEN,GEN))
-    GEN     gen_pow_u(GEN x, ulong n, void *data, GEN (*sqr)(void*,GEN), GEN (*mul)(void*,GEN,GEN))
-    long    logint(GEN B, GEN y, GEN *ptq)
+    GEN     gp_factor0(GEN x, GEN flag)
+    GEN     idealfactorback(GEN nf, GEN L, GEN e, int red)
+    long    isirreducible(GEN x)
     GEN     newtonpoly(GEN x, GEN p)
-    GEN     nfgcd(GEN P, GEN Q, GEN nf, GEN den)
-    GEN     nfisincl(GEN a, GEN b)
-    GEN     nfisisom(GEN a, GEN b)
+    GEN     nffactorback(GEN nf, GEN L, GEN e)
     GEN     nfrootsQ(GEN x)
     GEN     poldisc0(GEN x, long v)
-    GEN     polfnf(GEN a, GEN t)
-    GEN     polhensellift(GEN pol, GEN fct, GEN p, long exp)
-    GEN     polresultant0(GEN x, GEN y,long v,long flag)
+    GEN     polresultant0(GEN x, GEN y, long v, long flag)
     GEN     polsym(GEN x, long n)
     GEN     primitive_part(GEN x, GEN *c)
     GEN     primpart(GEN x)
-    GEN     quadgen(GEN x)
-    GEN     quadpoly(GEN x)
-    GEN     quadpoly0(GEN x, long v)
     GEN     reduceddiscsmith(GEN pol)
     GEN     resultant2(GEN x, GEN y)
+    GEN     resultant_all(GEN u, GEN v, GEN *sol)
+    GEN     rnfcharpoly(GEN nf, GEN T, GEN alpha, long v)
     GEN     roots_from_deg1(GEN x)
-    GEN     sort_factor(GEN y, int (*cmp)(GEN,GEN))
-    GEN     sort_factor_gen(GEN y, int (*cmp)(GEN,GEN))
-    GEN     sort_vecpol(GEN a, int (*cmp)(GEN,GEN))
-    GEN     srgcd(GEN x, GEN y)
+    GEN     roots_to_pol(GEN a, long v)
+    GEN     roots_to_pol_r1(GEN a, long v, long r1)
     long    sturmpart(GEN x, GEN a, GEN b)
     GEN     subresext(GEN x, GEN y, GEN *U, GEN *V)
-    GEN     sylvestermatrix(GEN x,GEN y)
-    GEN     vecbezout(GEN x, GEN y)
-    GEN     vecbezoutres(GEN x, GEN y)
+    GEN     sylvestermatrix(GEN x, GEN y)
+    GEN     trivial_fact()
+    GEN     gcdext0(GEN x, GEN y)
+    GEN     polresultantext0(GEN x, GEN y, long v)
+    GEN     polresultantext(GEN x, GEN y)
+    GEN     prime_fact(GEN x)
 
     # polarit3.c
 
-    GEN     Fp_pows(GEN A, long k, GEN N)
-    GEN     Fp_powu(GEN x, ulong k, GEN p)
-    GEN     FpM_red(GEN z, GEN p)
-    GEN     FpM_to_mod(GEN z, GEN p)
-    GEN     FpV_polint(GEN xa, GEN ya, GEN p)
-    GEN     FpV_red(GEN z, GEN p)
-    GEN     FpV_roots_to_pol(GEN V, GEN p, long v)
-    GEN     FpV_to_mod(GEN z, GEN p)
-    GEN     FpX_Fp_add(GEN y,GEN x,GEN p)
-    GEN     FpX_Fp_mul(GEN y,GEN x,GEN p)
-    GEN     FpX_add(GEN x,GEN y,GEN p)
-    GEN     FpX_center(GEN T,GEN mod)
-    GEN     FpX_chinese_coprime(GEN x,GEN y,GEN Tx,GEN Ty,GEN Tz,GEN p)
-    GEN     FpX_divrem(GEN x, GEN y, GEN p, GEN *pr)
-    GEN     FpX_eval(GEN x,GEN y,GEN p)
-    GEN     FpX_extgcd(GEN x, GEN y, GEN p, GEN *ptu, GEN *ptv)
-    GEN     FpX_factorff_irred(GEN P, GEN Q, GEN l)
-    void    FpX_ffintersect(GEN P,GEN Q,long n,GEN l,GEN *SP,GEN *SQ,GEN MA,GEN MB)
-    GEN     FpX_ffisom(GEN P,GEN Q,GEN l)
-    GEN     FpX_gcd(GEN x, GEN y, GEN p)
-    GEN     FpX_mul(GEN x,GEN y,GEN p)
-    GEN     FpX_neg(GEN x,GEN p)
-    GEN     FpX_normalize(GEN z, GEN p)
-    GEN     FpX_red(GEN z, GEN p)
-    GEN     FpX_sqr(GEN x,GEN p)
-    GEN     FpX_sub(GEN x,GEN y,GEN p)
-    GEN     FpX_to_mod(GEN z, GEN p)
-    GEN     FpXQ_charpoly(GEN x, GEN T, GEN p)
-    GEN     FpXQ_div(GEN x,GEN y,GEN T,GEN p)
-    GEN     FpXQ_ffisom_inv(GEN S,GEN Tp, GEN p)
-    GEN     FpXQ_inv(GEN x,GEN T,GEN p)
-    GEN     FpXQ_invsafe(GEN x, GEN T, GEN p)
-    GEN     FpXQ_matrix_pow(long n, long m, GEN y, GEN P, GEN l)
-    GEN     FpXQ_minpoly(GEN x, GEN T, GEN p)
-    GEN     FpXQ_mul(GEN y,GEN x,GEN T,GEN p)
-    GEN     FpXQ_pow(GEN x, GEN n, GEN T, GEN p)
-    GEN     FpXQ_powers(GEN x, long l, GEN T, GEN p)
-    GEN     FpXQ_sqr(GEN y, GEN T, GEN p)
-    GEN     FpXQ_sqrtn(GEN a, GEN n, GEN T, GEN p, GEN *zetan)
-    GEN     FpXQX_mul(GEN x, GEN y, GEN T, GEN p)
-    GEN     FpXQX_red(GEN z, GEN T, GEN p)
-    GEN     FpXQX_sqr(GEN x, GEN T, GEN p)
-    GEN     FpXQX_extgcd(GEN x, GEN y, GEN T, GEN p, GEN *ptu, GEN *ptv)
-    GEN     FpXQX_divrem(GEN x, GEN y, GEN T, GEN p, GEN *pr)
-    GEN     FpXQXV_prod(GEN V, GEN Tp, GEN p)
-    GEN     FpXV_prod(GEN V, GEN p)
-    GEN     FpXV_red(GEN z, GEN p)
-    GEN     FpXX_red(GEN z, GEN p)
-    GEN     FpX_rescale(GEN P, GEN h, GEN p)
+    GEN     Flx_FlxY_resultant(GEN a, GEN b, ulong pp)
+    GEN     Flx_factorff_irred(GEN P, GEN Q, ulong p)
+    void    Flx_ffintersect(GEN P, GEN Q, long n, ulong l, GEN *SP, GEN *SQ, GEN MA, GEN MB)
+    GEN     Flx_ffisom(GEN P, GEN Q, ulong l)
+    GEN     Flx_roots_naive(GEN f, ulong p)
+    GEN     FlxX_resultant(GEN u, GEN v, ulong p, long sx)
+    GEN     Flxq_ffisom_inv(GEN S, GEN Tp, ulong p)
+    GEN     FpV_polint(GEN xa, GEN ya, GEN p, long v)
+    GEN     FpX_FpXY_resultant(GEN a, GEN b0, GEN p)
+    GEN     FpX_factorff_irred(GEN P, GEN Q, GEN p)
+    void    FpX_ffintersect(GEN P, GEN Q, long n, GEN l, GEN *SP, GEN *SQ, GEN MA, GEN MB)
+    GEN     FpX_ffisom(GEN P, GEN Q, GEN l)
+    GEN     FpX_translate(GEN P, GEN c, GEN p)
+    GEN     FpXQ_ffisom_inv(GEN S, GEN Tp, GEN p)
+    GEN     FpXV_FpC_mul(GEN V, GEN W, GEN p)
+    GEN     FpXY_Fq_evaly(GEN Q, GEN y, GEN T, GEN p, long vx)
+    GEN     Fq_Fp_mul(GEN x, GEN y, GEN T, GEN p)
+    GEN     Fq_add(GEN x, GEN y, GEN T, GEN p)
+    GEN     Fq_div(GEN x, GEN y, GEN T, GEN p)
     GEN     Fq_inv(GEN x, GEN T, GEN p)
     GEN     Fq_invsafe(GEN x, GEN T, GEN p)
-    GEN     Fq_add(GEN x, GEN y, GEN T, GEN p)
     GEN     Fq_mul(GEN x, GEN y, GEN T, GEN p)
+    GEN     Fq_mulu(GEN x, ulong y, GEN T, GEN p)
     GEN     Fq_neg(GEN x, GEN T, GEN p)
     GEN     Fq_neg_inv(GEN x, GEN T, GEN p)
     GEN     Fq_pow(GEN x, GEN n, GEN T, GEN p)
-    GEN     Fq_red(GEN x, GEN T, GEN p)
+    GEN     Fq_powu(GEN x, ulong n, GEN pol, GEN p)
     GEN     Fq_sub(GEN x, GEN y, GEN T, GEN p)
+    GEN     Fq_sqr(GEN x, GEN T, GEN p)
+    GEN     Fq_sqrt(GEN x, GEN T, GEN p)
+    GEN     Fq_sqrtn(GEN x, GEN n, GEN T, GEN p, GEN *zeta)
+    GEN     FqC_add(GEN x, GEN y, GEN T, GEN p)
+    GEN     FqC_sub(GEN x, GEN y, GEN T, GEN p)
+    GEN     FqC_Fq_mul(GEN x, GEN y, GEN T, GEN p)
+    GEN     FqC_to_FlxC(GEN v, GEN T, GEN pp)
     GEN     FqM_to_FlxM(GEN x, GEN T, GEN pp)
     GEN     FqV_roots_to_pol(GEN V, GEN T, GEN p, long v)
     GEN     FqV_red(GEN z, GEN T, GEN p)
-    GEN     FqX_Fq_mul(GEN P, GEN U, GEN T, GEN p)
-    GEN     FqX_div(GEN x, GEN y, GEN T, GEN p)
-    GEN     FqX_divrem(GEN x, GEN y, GEN T, GEN p, GEN *z)
+    GEN     FqV_to_FlxV(GEN v, GEN T, GEN pp)
+    GEN     FqX_Fq_add(GEN y, GEN x, GEN T, GEN p)
+    GEN     FqX_Fq_mul_to_monic(GEN P, GEN U, GEN T, GEN p)
+    GEN     FqX_eval(GEN x, GEN y, GEN T, GEN p)
     GEN     FqX_normalize(GEN z, GEN T, GEN p)
-    GEN     FqX_red(GEN z, GEN T, GEN p)
-    GEN     FqX_rem(GEN x, GEN y, GEN T, GEN p)
-    GEN     FqX_mul(GEN x, GEN y, GEN T, GEN p)
-    GEN     FqX_sqr(GEN x, GEN T, GEN p)
+    GEN     FqX_translate(GEN P, GEN c, GEN T, GEN p)
+    GEN     FqXQ_powers(GEN x, long l, GEN S, GEN T, GEN p)
+    GEN     FqXQ_matrix_pow(GEN y, long n, long m, GEN S, GEN T, GEN p)
+    GEN     FqXY_eval(GEN Q, GEN y, GEN x, GEN T, GEN p)
+    GEN     FqXY_evalx(GEN Q, GEN x, GEN T, GEN p)
+    GEN     QX_disc(GEN x)
+    GEN     QX_gcd(GEN a, GEN b)
+    GEN     QX_resultant(GEN A, GEN B)
+    GEN     QXQ_intnorm(GEN A, GEN B)
     GEN     QXQ_inv(GEN A, GEN B)
+    GEN     QXQ_norm(GEN A, GEN B)
+    int     Rg_is_Fp(GEN x, GEN *p)
+    int     Rg_is_FpXQ(GEN x, GEN *pT, GEN *pp)
+    GEN     Rg_to_Fp(GEN x, GEN p)
+    GEN     Rg_to_FpXQ(GEN x, GEN T, GEN p)
+    GEN     RgC_to_Flc(GEN x, ulong p)
+    GEN     RgC_to_FpC(GEN x, GEN p)
+    int     RgM_is_FpM(GEN x, GEN *p)
+    GEN     RgM_to_Flm(GEN x, ulong p)
+    GEN     RgM_to_FpM(GEN x, GEN p)
+    int     RgV_is_FpV(GEN x, GEN *p)
+    GEN     RgV_to_FpV(GEN x, GEN p)
+    int     RgX_is_FpX(GEN x, GEN *p)
+    GEN     RgX_to_FpX(GEN x, GEN p)
+    int     RgX_is_FpXQX(GEN x, GEN *pT, GEN *pp)
+    GEN     RgX_to_FpXQX(GEN x, GEN T, GEN p)
+    GEN     RgX_to_FqX(GEN x, GEN T, GEN p)
+    GEN     ZX_ZXY_rnfequation(GEN A, GEN B, long *Lambda)
+    GEN     ZXQ_charpoly(GEN A, GEN T, long v)
     GEN     ZX_disc(GEN x)
     int     ZX_is_squarefree(GEN x)
+    GEN     ZX_gcd(GEN A, GEN B)
+    GEN     ZX_gcd_all(GEN A, GEN B, GEN *Anew)
     GEN     ZX_resultant(GEN A, GEN B)
-    long    brent_kung_optpow(long d, long n)
+    int     Z_incremental_CRT(GEN *H, ulong Hp, GEN *q, ulong p)
+    GEN     Z_init_CRT(ulong Hp, ulong p)
+    int     ZM_incremental_CRT(GEN *H, GEN Hp, GEN *q, ulong p)
+    GEN     ZM_init_CRT(GEN Hp, ulong p)
+    int     ZX_incremental_CRT(GEN *ptH, GEN Hp, GEN *q, ulong p)
+    GEN     ZX_init_CRT(GEN Hp, ulong p, long v)
+    GEN     characteristic(GEN x)
     GEN     ffinit(GEN p, long n, long v)
+    GEN     ffnbirred(GEN p, long n)
+    GEN     ffnbirred0(GEN p, long n, long flag)
+    GEN     ffsumnbirred(GEN p, long n)
+    bb_field *get_Fq_field(void **E, GEN T, GEN p)
+    GEN     init_Fq(GEN p, long n, long v)
+    GEN     pol_x_powers(long N, long v)
+    GEN     residual_characteristic(GEN x)
+
+    # prime.c
+
+    long    BPSW_isprime(GEN x)
+    long    BPSW_psp(GEN N)
+    GEN     addprimes(GEN primes)
+    GEN     gisprime(GEN x, long flag)
+    GEN     gispseudoprime(GEN x, long flag)
+    GEN     gprimepi_upper_bound(GEN x)
+    GEN     gprimepi_lower_bound(GEN x)
+    long    isprime(GEN x)
+    long    ispseudoprime(GEN x, long flag)
+    long    millerrabin(GEN n, long k)
+    GEN     prime(long n)
+    GEN     primepi(GEN x)
+    double  primepi_upper_bound(double x)
+    double  primepi_lower_bound(double x)
+    GEN     primes(long n)
+    GEN     primes_interval(GEN a, GEN b)
+    GEN     primes_interval_zv(ulong a, ulong b)
+    GEN     primes_upto_zv(ulong b)
+    GEN     primes0(GEN n)
+    GEN     primes_zv(long m)
+    GEN     randomprime(GEN N)
+    GEN     removeprimes(GEN primes)
+    int     uislucaspsp(ulong n)
+    int     uisprime(ulong n)
+    ulong   uprime(long n)
+    ulong   uprimepi(ulong n)
 
-    # RgX.c
+    # qfisom.c
 
-    int     RgX_is_rational(GEN x)
-    GEN     RgM_to_RgXV(GEN x, long v)
-    GEN     RgM_to_RgXX(GEN x, long v,long w)
-    GEN     RgM_zc_mul(GEN x, GEN y)
-    GEN     RgM_zm_mul(GEN x, GEN y)
-    GEN     RgV_to_RgX(GEN x, long v)
-    GEN     RgV_zc_mul(GEN x, GEN y)
-    GEN     RgV_zm_mul(GEN x, GEN y)
-    GEN     RgX_divrem(GEN x,GEN y,GEN *r)
-    GEN     RgX_mul(GEN x,GEN y)
-    GEN     RgX_mulspec(GEN a, GEN b, long na, long nb)
-    GEN     RgXQX_divrem(GEN x,GEN y,GEN T,GEN *r)
-    GEN     RgXQX_mul(GEN x,GEN y,GEN T)
-    GEN     RgXQX_red(GEN P, GEN T)
-    GEN     RgXQX_RgXQ_mul(GEN x, GEN y, GEN T)
-    GEN     RgX_Rg_mul(GEN y, GEN x)
-    GEN     RgX_shift(GEN x, long n)
-    GEN     RgX_sqr(GEN x)
-    GEN     RgX_sqrspec(GEN a, long na)
-    GEN     RgXV_to_RgM(GEN v, long n)
-    GEN     RgX_to_RgV(GEN x, long N)
-    GEN     RgXX_to_RgM(GEN v, long n)
-    GEN     RgXY_swap(GEN x, long n, long w)
+    GEN     qfauto(GEN g, GEN flags)
+    GEN     qfauto0(GEN g, GEN flags)
+    GEN     qfautoexport(GEN g, long flag)
+    GEN     qfisom(GEN g, GEN h, GEN flags)
+    GEN     qfisom0(GEN g, GEN h, GEN flags)
+    GEN     qfisominit(GEN g, GEN flags)
+    GEN     qfisominit0(GEN g, GEN flags)
+
+    # random.c
+
+    GEN     genrand(GEN N)
+    GEN     getrand()
+    ulong   pari_rand()
+    GEN     randomi(GEN x)
+    GEN     randomr(long prec)
+    ulong   random_Fl(ulong n)
+    void    setrand(GEN seed)
 
     # rootpol.c
 
-    GEN     cleanroots(GEN x,long l)
+    GEN     QX_complex_roots(GEN p, long l)
+    GEN     ZX_graeffe(GEN p)
+    GEN     cleanroots(GEN x, long l)
     int     isrealappr(GEN x, long l)
-    GEN     roots(GEN x,long l)
-    GEN     roots0(GEN x,long flag,long l)
+    GEN     polgraeffe(GEN p)
+    GEN     polmod_to_embed(GEN x, long prec)
+    GEN     roots(GEN x, long l)
 
     # subcyclo.c
 
+    GEN     factor_Aurifeuille(GEN p, long n)
+    GEN     factor_Aurifeuille_prime(GEN p, long n)
     GEN     galoissubcyclo(GEN N, GEN sg, long flag, long v)
     GEN     polsubcyclo(long n, long d, long v)
-    GEN     znstar_small(GEN zn)
 
     # subfield.c
 
@@ -1792,7 +3546,7 @@ cdef extern from 'pari/pari.h':
     # subgroup.c
 
     GEN     subgrouplist(GEN cyc, GEN bound)
-    void    traversesubgroups(GEN cyc, GEN B, void fun(GEN,void*), void *E)
+    void    forsubgroup(void *E, long fun(void*, GEN), GEN cyc, GEN B)
 
     # stark.c
 
@@ -1802,23 +3556,34 @@ cdef extern from 'pari/pari.h':
 
     # sumiter.c
 
-    GEN     derivnum(void *E, GEN (*eval)(GEN,void*), GEN x, long prec)
-    GEN     direuler(void *E, GEN (*eval)(GEN,void*), GEN ga, GEN gb, GEN c)
-    GEN     forvec_start(GEN x, long flag, GEN *d, GEN (**next)(GEN,GEN))
+    GEN     derivnum(void *E, GEN (*eval)(void *, GEN), GEN x, long prec)
+    GEN     derivfun(void *E, GEN (*eval)(void *, GEN), GEN x, long prec)
+    GEN     direuler(void *E, GEN (*eval)(void *, GEN), GEN ga, GEN gb, GEN c)
+    int     forcomposite_init(forcomposite_t *C, GEN a, GEN b)
+    GEN     forcomposite_next(forcomposite_t *C)
+    GEN     forprime_next(forprime_t *T)
+    int     forprime_init(forprime_t *T, GEN a, GEN b)
+    int     forvec_init(forvec_t *T, GEN x, long flag)
+    GEN     forvec_next(forvec_t *T)
     GEN     polzag(long n, long m)
-    GEN     prodeuler(void *E, GEN (*eval)(GEN,void*), GEN ga, GEN gb, long prec)
-    GEN     prodinf(void *E, GEN (*eval)(GEN,void*), GEN a, long prec)
-    GEN     prodinf1(void *E, GEN (*eval)(GEN,void*), GEN a, long prec)
-    GEN     sumalt(void *E, GEN (*eval)(GEN,void*), GEN a, long prec)
-    GEN     sumalt2(void *E, GEN (*eval)(GEN,void*), GEN a, long prec)
-    GEN     sumpos(void *E, GEN (*eval)(GEN,void*), GEN a, long prec)
-    GEN     sumpos2(void *E, GEN (*eval)(GEN,void*), GEN a, long prec)
-    GEN     suminf(void *E, GEN (*eval)(GEN,void*), GEN a, long prec)
-    GEN     zbrent(void *E, GEN (*eval)(GEN,void*), GEN a, GEN b, long prec)
+    GEN     prodeuler(void *E, GEN (*eval)(void *, GEN), GEN ga, GEN gb, long prec)
+    GEN     prodinf(void *E, GEN (*eval)(void *, GEN), GEN a, long prec)
+    GEN     prodinf1(void *E, GEN (*eval)(void *, GEN), GEN a, long prec)
+    GEN     sumalt(void *E, GEN (*eval)(void *, GEN), GEN a, long prec)
+    GEN     sumalt2(void *E, GEN (*eval)(void *, GEN), GEN a, long prec)
+    GEN     sumpos(void *E, GEN (*eval)(void *, GEN), GEN a, long prec)
+    GEN     sumpos2(void *E, GEN (*eval)(void *, GEN), GEN a, long prec)
+    GEN     suminf(void *E, GEN (*eval)(void *, GEN), GEN a, long prec)
+    ulong   u_forprime_next(forprime_t *T)
+    int     u_forprime_init(forprime_t *T, ulong a, ulong b)
+    void    u_forprime_restrict(forprime_t *T, ulong c)
+    int     u_forprime_arith_init(forprime_t *T, ulong a, ulong b, ulong c, ulong q)
+    GEN     zbrent(void *E, GEN (*eval)(void *, GEN), GEN a, GEN b, long prec)
 
     # thue.c
 
     GEN     bnfisintnorm(GEN x, GEN y)
+    GEN     bnfisintnormabs(GEN bnf, GEN a)
     GEN     thue(GEN thueres, GEN rhs, GEN ne)
     GEN     thueinit(GEN pol, long flag, long prec)
 
@@ -1827,14 +3592,26 @@ cdef extern from 'pari/pari.h':
     GEN     Pi2n(long n, long prec)
     GEN     PiI2(long prec)
     GEN     PiI2n(long n, long prec)
+    GEN     Qp_exp(GEN x)
+    GEN     Qp_log(GEN x)
+    GEN     Qp_sqrt(GEN x)
+    GEN     Qp_sqrtn(GEN x, GEN n, GEN *zetan)
+    long    Zn_ispower(GEN a, GEN q, GEN K, GEN *pt)
     long    Zn_issquare(GEN x, GEN n)
     GEN     Zn_sqrt(GEN x, GEN n)
-    void    consteuler(long prec)
-    void    constpi(long prec)
-    GEN     exp_Ir(GEN x)
+    GEN     Zp_teichmuller(GEN x, GEN p, long n, GEN q)
+    GEN     agm(GEN x, GEN y, long prec)
+    GEN     constcatalan(long prec)
+    GEN     consteuler(long prec)
+    GEN     constlog2(long prec)
+    GEN     constpi(long prec)
+    GEN     cxexpm1(GEN z, long prec)
+    GEN     expIr(GEN x)
+    GEN     exp1r_abs(GEN x)
     GEN     gcos(GEN x, long prec)
     GEN     gcotan(GEN x, long prec)
     GEN     gexp(GEN x, long prec)
+    GEN     gexpm1(GEN x, long prec)
     GEN     glog(GEN x, long prec)
     GEN     gpow(GEN x, GEN n, long prec)
     GEN     gpowgs(GEN x, long n)
@@ -1843,72 +3620,100 @@ cdef extern from 'pari/pari.h':
     GEN     gsqrt(GEN x, long prec)
     GEN     gsqrtn(GEN x, GEN n, GEN *zetan, long prec)
     GEN     gtan(GEN x, long prec)
+    GEN     logr_abs(GEN x)
     GEN     mpcos(GEN x)
     GEN     mpeuler(long prec)
+    GEN     mpcatalan(long prec)
+    void    mpsincosm1(GEN x, GEN *s, GEN *c)
     GEN     mpexp(GEN x)
-    GEN     mpexp1(GEN x)
+    GEN     mpexpm1(GEN x)
     GEN     mplog(GEN x)
     GEN     mplog2(long prec)
     GEN     mppi(long prec)
     GEN     mpsin(GEN x)
     void    mpsincos(GEN x, GEN *s, GEN *c)
+    GEN     powis(GEN x, long n)
+    GEN     powiu(GEN p, ulong k)
+    GEN     powrfrac(GEN x, long n, long d)
+    GEN     powrs(GEN x, long n)
+    GEN     powrshalf(GEN x, long s)
+    GEN     powru(GEN x, ulong n)
+    GEN     powruhalf(GEN x, ulong s)
+    GEN     powuu(ulong p, ulong k)
     GEN     powgi(GEN x, GEN n)
+    GEN     serchop0(GEN s)
+    GEN     sqrtnint(GEN a, long n)
     GEN     teich(GEN x)
+    GEN     trans_eval(const char *fun, GEN (*f) (GEN, long), GEN x, long prec)
+    ulong   upowuu(ulong p, ulong k)
+    ulong   usqrtn(ulong a, ulong n)
+    ulong   usqrt(ulong a)
 
     # trans2.c
 
+    GEN     Qp_gamma(GEN x)
     GEN     bernfrac(long n)
+    GEN     bernpol(long k, long v)
     GEN     bernreal(long n, long prec)
-    GEN     bernvec(long nomb)
-    GEN     gach(GEN x, long prec)
+    GEN     gacosh(GEN x, long prec)
     GEN     gacos(GEN x, long prec)
     GEN     garg(GEN x, long prec)
-    GEN     gash(GEN x, long prec)
+    GEN     gasinh(GEN x, long prec)
     GEN     gasin(GEN x, long prec)
     GEN     gatan(GEN x, long prec)
-    GEN     gath(GEN x, long prec)
-    GEN     gch(GEN x, long prec)
-    GEN     ggamd(GEN x, long prec)
+    GEN     gatanh(GEN x, long prec)
+    GEN     gcosh(GEN x, long prec)
+    GEN     ggammah(GEN x, long prec)
     GEN     ggamma(GEN x, long prec)
     GEN     glngamma(GEN x, long prec)
     GEN     gpsi(GEN x, long prec)
-    GEN     gsh(GEN x, long prec)
-    GEN     gth(GEN x, long prec)
+    GEN     gsinh(GEN x, long prec)
+    GEN     gtanh(GEN x, long prec)
     void    mpbern(long nomb, long prec)
+    GEN     mpfactr(long n, long prec)
+    GEN     sumformal(GEN T, long v)
 
     # trans3.c
 
-    GEN     agm(GEN x, GEN y, long prec)
     GEN     dilog(GEN x, long prec)
     GEN     eint1(GEN x, long prec)
     GEN     eta(GEN x, long prec)
-    GEN     eta0(GEN x, long flag,long prec)
+    GEN     eta0(GEN x, long flag, long prec)
     GEN     gerfc(GEN x, long prec)
     GEN     gpolylog(long m, GEN x, long prec)
     GEN     gzeta(GEN x, long prec)
     GEN     hyperu(GEN a, GEN b, GEN gx, long prec)
     GEN     incgam(GEN a, GEN x, long prec)
-    GEN     incgam0(GEN a, GEN x, GEN z,long prec)
+    GEN     incgam0(GEN a, GEN x, GEN z, long prec)
     GEN     incgamc(GEN a, GEN x, long prec)
     GEN     hbessel1(GEN n, GEN z, long prec)
     GEN     hbessel2(GEN n, GEN z, long prec)
     GEN     ibessel(GEN n, GEN z, long prec)
     GEN     jbessel(GEN n, GEN z, long prec)
     GEN     jbesselh(GEN n, GEN z, long prec)
+    GEN     mpeint1(GEN x, GEN expx)
+    GEN     mplambertW(GEN y)
+    GEN     mpveceint1(GEN C, GEN eC, long n)
+    GEN     powruvec(GEN e, ulong n)
     GEN     nbessel(GEN n, GEN z, long prec)
     GEN     jell(GEN x, long prec)
     GEN     kbessel(GEN nu, GEN gx, long prec)
-    GEN     polylog(long m, GEN x, long prec)
     GEN     polylog0(long m, GEN x, long flag, long prec)
+    GEN     sumdedekind_coprime(GEN h, GEN k)
+    GEN     sumdedekind(GEN h, GEN k)
     GEN     szeta(long x, long prec)
     GEN     theta(GEN q, GEN z, long prec)
     GEN     thetanullk(GEN q, long k, long prec)
     GEN     trueeta(GEN x, long prec)
-    GEN     veceint1(GEN C, GEN nmax, long prec)
+    GEN     u_sumdedekind_coprime(long h, long k)
+    GEN     veceint1(GEN nmax, GEN C, long prec)
     GEN     vecthetanullk(GEN q, long k, long prec)
-    GEN     weber0(GEN x, long flag,long prec)
+    GEN     vecthetanullk_tau(GEN tau, long k, long prec)
+    GEN     weber0(GEN x, long flag, long prec)
     GEN     weberf(GEN x, long prec)
+    GEN     weberf1(GEN x, long prec)
     GEN     weberf2(GEN x, long prec)
+    GEN     glambertW(GEN y, long prec)
 
     # gmp/int.h
     long*   int_MSW(GEN x)
@@ -1916,8 +3721,15 @@ cdef extern from 'pari/pari.h':
     long*   int_precW(long * xp)
     long*   int_nextW(long * xp)
 
-    # misc...
-    extern char* diffptr
+    # paristio.h
+
+    struct PariOUT:
+        void (*putch)(char)
+        void (*puts)(char*)
+        void (*flush)()
+    extern PariOUT* pariOut
+    extern PariOUT* pariErr
+    extern byteptr diffptr
 
 cdef extern from 'stdsage.h':
     GEN set_gel(GEN x, long n, GEN z)              # gel(x,n) = z
@@ -1929,15 +3741,6 @@ cdef extern from 'stdsage.h':
 include 'declinl.pxi'
 
 
-cdef extern from *:   # paristio.h
-    struct PariOUT:
-        void (*putch)(char)
-        void (*puts)(char*)
-        void (*flush)()
-    extern PariOUT* pariOut
-    extern PariOUT* pariErr
-
-
 cdef extern from 'pari/paripriv.h':
     int gpd_QUIET, gpd_TEST, gpd_EMACS, gpd_TEXMACS
 
diff --git a/src/sage/libs/pari/gen.pyx b/src/sage/libs/pari/gen.pyx
index 71b3f14..981bd1f 100644
--- a/src/sage/libs/pari/gen.pyx
+++ b/src/sage/libs/pari/gen.pyx
@@ -23,6 +23,8 @@ AUTHORS:
 - Peter Bruin (2013-11-17): move PariInstance to a separate file
   (#15185)
 
+ - Jeroen Demeyer (2014-02-09): upgrade to PARI 2.7 (#15767)
+
 """
 
 #*****************************************************************************
@@ -332,7 +334,7 @@ cdef class gen(sage.structure.element.RingElement):
             sage: K.getattr("reg")
             Traceback (most recent call last):
             ...
-            PariError: _.reg: incorrect type in reg
+            PariError: _.reg: incorrect type in reg (t_VEC)
             sage: K.getattr("zzz")
             Traceback (most recent call last):
             ...
@@ -385,14 +387,15 @@ cdef class gen(sage.structure.element.RingElement):
             sage: bnr.nf_get_pol()
             x^4 - 4*x^2 + 1
 
-        For relative extensions, this returns the absolute polynomial,
-        not the relative one::
+        For relative number fields, this returns the relative
+        polynomial. However, beware that ``pari(L)`` returns an absolute
+        number field::
 
             sage: L.<b> = K.extension(x^2 - 5)
-            sage: pari(L).nf_get_pol()   # Absolute polynomial
+            sage: pari(L).nf_get_pol()        # Absolute
             y^8 - 28*y^6 + 208*y^4 - 408*y^2 + 36
-            sage: L.pari_rnf().nf_get_pol()
-            x^8 - 28*x^6 + 208*x^4 - 408*x^2 + 36
+            sage: L.pari_rnf().nf_get_pol()   # Relative
+            x^2 - 5
 
         TESTS::
 
@@ -408,7 +411,8 @@ cdef class gen(sage.structure.element.RingElement):
             sage: pari("[0]").nf_get_pol()
             Traceback (most recent call last):
             ...
-            PariError: incorrect type in pol
+            PariError: incorrect type in pol (t_VEC)
+
         """
         pari_catch_sig_on()
         return P.new_gen(member_pol(self.g))
@@ -555,7 +559,7 @@ cdef class gen(sage.structure.element.RingElement):
 
             sage: K.<i> = QuadraticField(-1)
             sage: F = pari(K).idealfactor(K.ideal(5)); F
-            [[5, [-2, 1]~, 1, 1, [2, 1]~], 1; [5, [2, 1]~, 1, 1, [-2, 1]~], 1]
+            [[5, [-2, 1]~, 1, 1, [2, -1; 1, 2]], 1; [5, [2, 1]~, 1, 1, [-2, -1; 1, -2]], 1]
             sage: F[0,0].pr_get_p()
             5
         """
@@ -1152,9 +1156,11 @@ cdef class gen(sage.structure.element.RingElement):
             -36bb1e3929d1a8fe2802f083
         """
         cdef GEN x
-        cdef long lx, *xp
+        cdef long lx
+        cdef long *xp
         cdef long w
-        cdef char *s, *sp
+        cdef char *s
+        cdef char *sp
         cdef char *hexdigits
         hexdigits = "0123456789abcdef"
         cdef int i, j
@@ -1379,7 +1385,7 @@ cdef class gen(sage.structure.element.RingElement):
             sage: complex(g)
             Traceback (most recent call last):
             ...
-            PariError: incorrect type in greal/gimag
+            PariError: incorrect type in greal/gimag (t_INTMOD)
         """
         cdef double re, im
         pari_catch_sig_on()
@@ -1735,7 +1741,9 @@ cdef class gen(sage.structure.element.RingElement):
         moebius(x): Moebius function of x.
         """
         pari_catch_sig_on()
-        return P.new_gen(gmoebius(x.g))
+        r = moebius(x.g)
+        pari_catch_sig_off()
+        return r
 
     def sign(gen x):
         """
@@ -1757,7 +1765,7 @@ cdef class gen(sage.structure.element.RingElement):
             sage: pari(I).sign()
             Traceback (most recent call last):
             ...
-            PariError: incorrect type in gsigne
+            PariError: incorrect type in gsigne (t_COMPLEX)
 
         """
         pari_catch_sig_on()
@@ -2055,7 +2063,7 @@ cdef class gen(sage.structure.element.RingElement):
                sage: pari('x+y').Pol('y')
                Traceback (most recent call last):
                ...
-               PariError: variable must have higher priority in gtopoly
+               PariError: incorrect priority in gtopoly: variable x < y
 
         INPUT:
 
@@ -2174,7 +2182,7 @@ cdef class gen(sage.structure.element.RingElement):
             sage: pari(3).Qfb(7, 2)  # discriminant is 25
             Traceback (most recent call last):
             ...
-            PariError: square discriminant in Qfb
+            PariError: domain error in Qfb: issquare(disc) = 1
         """
         cdef gen t0 = objtogen(b)
         cdef gen t1 = objtogen(c)
@@ -2281,17 +2289,17 @@ cdef class gen(sage.structure.element.RingElement):
         EXAMPLES::
 
             sage: pari([1,5,2]).Set()
-            ["1", "2", "5"]
+            [1, 2, 5]
             sage: pari([]).Set()     # the empty set
             []
             sage: pari([1,1,-1,-1,3,3]).Set()
-            ["-1", "1", "3"]
+            [-1, 1, 3]
             sage: pari(1).Set()
-            ["1"]
+            [1]
             sage: pari('1/(x*y)').Set()
-            ["1/(y*x)"]
+            [1/(y*x)]
             sage: pari('["bc","ab","bc"]').Set()
-            ["\"ab\"", "\"bc\""]
+            ["ab", "bc"]
         """
         pari_catch_sig_on()
         return P.new_gen(gtoset(x.g))
@@ -2557,9 +2565,7 @@ cdef class gen(sage.structure.element.RingElement):
             sage: pari(1234).Vecsmall()
             Vecsmall([1234])
             sage: pari('x^2 + 2*x + 3').Vecsmall()
-            Traceback (most recent call last):
-            ...
-            PariError: incorrect type in vectosmall
+            Vecsmall([1, 2, 3])
 
         We demonstate the `n` argument::
 
@@ -2595,7 +2601,7 @@ cdef class gen(sage.structure.element.RingElement):
         EXAMPLES::
 
             sage: pari(0).binary()
-            [0]
+            []
             sage: pari(-5).binary()
             [1, 0, 1]
             sage: pari(5).binary()
@@ -2967,7 +2973,7 @@ cdef class gen(sage.structure.element.RingElement):
             sage: pari('x').component(0)
             Traceback (most recent call last):
             ...
-            PariError: nonexistent component
+            PariError: non-existent component: index < 1
         """
         pari_catch_sig_on()
         return P.new_gen(compo(x.g, n))
@@ -2999,7 +3005,7 @@ cdef class gen(sage.structure.element.RingElement):
             sage: pari('Mod(x,x^3-3)').conj()
             Traceback (most recent call last):
             ...
-            PariError: incorrect type in gconj
+            PariError: incorrect type in gconj (t_POLMOD)
         """
         pari_catch_sig_on()
         return P.new_gen(gconj(x.g))
@@ -3023,7 +3029,7 @@ cdef class gen(sage.structure.element.RingElement):
             sage: pari('Mod(1+x,x^2-2)').conjvec()
             [-0.414213562373095, 2.41421356237310]~
             sage: pari('Mod(x,x^3-3)').conjvec()
-            [1.44224957030741, -0.721124785153704 + 1.24902476648341*I, -0.721124785153704 - 1.24902476648341*I]~
+            [1.44224957030741, -0.721124785153704 - 1.24902476648341*I, -0.721124785153704 + 1.24902476648341*I]~
             sage: pari('Mod(1+x,x^2-2)').conjvec(precision=192)[0].sage()
             -0.414213562373095048801688724209698078569671875376948073177
         """
@@ -3098,7 +3104,7 @@ cdef class gen(sage.structure.element.RingElement):
             sage: pari('"hello world"').floor()
             Traceback (most recent call last):
             ...
-            PariError: incorrect type in gfloor
+            PariError: incorrect type in gfloor (t_STR)
         """
         pari_catch_sig_on()
         return P.new_gen(gfloor(x.g))
@@ -3124,7 +3130,7 @@ cdef class gen(sage.structure.element.RingElement):
             sage: pari('sqrt(-2)').frac()
             Traceback (most recent call last):
             ...
-            PariError: incorrect type in gfloor
+            PariError: incorrect type in gfloor (t_COMPLEX)
         """
         pari_catch_sig_on()
         return P.new_gen(gfrac(x.g))
@@ -3281,7 +3287,7 @@ cdef class gen(sage.structure.element.RingElement):
             sage: y.padicprec(17)
             Traceback (most recent call last):
             ...
-            PariError: not the same prime in padicprec
+            PariError: inconsistent moduli in padicprec: 11 != 17
 
         This works for polynomials too::
 
@@ -3740,7 +3746,7 @@ cdef class gen(sage.structure.element.RingElement):
         """
         cdef gen t0 = objtogen(p)
         pari_catch_sig_on()
-        v = ggval(x.g, t0.g)
+        v = gvaluation(x.g, t0.g)
         pari_catch_sig_off()
         return v
 
@@ -3881,7 +3887,7 @@ cdef class gen(sage.structure.element.RingElement):
             0.881373587019543 + 1.57079632679490*I
         """
         pari_catch_sig_on()
-        return P.new_gen(gach(x.g, prec_bits_to_words(precision)))
+        return P.new_gen(gacosh(x.g, prec_bits_to_words(precision)))
 
     def agm(gen x, y, unsigned long precision=0):
         r"""
@@ -3972,7 +3978,7 @@ cdef class gen(sage.structure.element.RingElement):
             1.52857091948100 + 0.427078586392476*I
         """
         pari_catch_sig_on()
-        return P.new_gen(gash(x.g, prec_bits_to_words(precision)))
+        return P.new_gen(gasinh(x.g, prec_bits_to_words(precision)))
 
     def atan(gen x, unsigned long precision=0):
         r"""
@@ -4015,7 +4021,7 @@ cdef class gen(sage.structure.element.RingElement):
             0.549306144334055 - 1.57079632679490*I
         """
         pari_catch_sig_on()
-        return P.new_gen(gath(x.g, prec_bits_to_words(precision)))
+        return P.new_gen(gatanh(x.g, prec_bits_to_words(precision)))
 
     def bernfrac(gen x):
         r"""
@@ -4064,10 +4070,14 @@ cdef class gen(sage.structure.element.RingElement):
         EXAMPLES::
 
             sage: pari(8).bernvec()
+            doctest:...: DeprecationWarning: bernvec() is deprecated, use repeated calls to bernfrac() instead
+            See http://trac.sagemath.org/15767 for details.
             [1, 1/6, -1/30, 1/42, -1/30, 5/66, -691/2730, 7/6, -3617/510]
             sage: [pari(2*n).bernfrac() for n in range(9)]
             [1, 1/6, -1/30, 1/42, -1/30, 5/66, -691/2730, 7/6, -3617/510]
         """
+        from sage.misc.superseded import deprecation
+        deprecation(15767, 'bernvec() is deprecated, use repeated calls to bernfrac() instead')
         pari_catch_sig_on()
         return P.new_gen(bernvec(x))
 
@@ -4152,8 +4162,7 @@ cdef class gen(sage.structure.element.RingElement):
         EXAMPLES::
 
             sage: pari(2).besseljh(3)
-            0.4127100324          # 32-bit
-            0.412710032209716     # 64-bit
+            0.412710032209716
         """
         cdef gen t0 = objtogen(x)
         pari_catch_sig_on()
@@ -4291,7 +4300,7 @@ cdef class gen(sage.structure.element.RingElement):
             1 + 1/2*x^2 + 1/24*x^4 + 1/720*x^6 + O(x^8)
         """
         pari_catch_sig_on()
-        return P.new_gen(gch(x.g, prec_bits_to_words(precision)))
+        return P.new_gen(gcosh(x.g, prec_bits_to_words(precision)))
 
     def cotan(gen x, unsigned long precision=0):
         """
@@ -4470,7 +4479,7 @@ cdef class gen(sage.structure.element.RingElement):
             sage: pari(-1).gamma()
             Traceback (most recent call last):
             ...
-            PariError: non-positive integer argument in ggamma
+            PariError: domain error in gamma: argument = non-positive integer
         """
         pari_catch_sig_on()
         return P.new_gen(ggamma(s.g, prec_bits_to_words(precision)))
@@ -4495,7 +4504,7 @@ cdef class gen(sage.structure.element.RingElement):
             0.575315188063452 + 0.0882106775440939*I
         """
         pari_catch_sig_on()
-        return P.new_gen(ggamd(s.g, prec_bits_to_words(precision)))
+        return P.new_gen(ggammah(s.g, prec_bits_to_words(precision)))
 
     def hyperu(gen a, b, x, unsigned long precision=0):
         r"""
@@ -4614,19 +4623,13 @@ cdef class gen(sage.structure.element.RingElement):
 
     def lngamma(gen x, unsigned long precision=0):
         r"""
-        This method is deprecated, please use :meth:`.log_gamma` instead.
-
-        See the :meth:`.log_gamma` method for documentation and examples.
+        Alias for :meth:`log_gamma`.
 
         EXAMPLES::
 
             sage: pari(100).lngamma()
-            doctest:...: DeprecationWarning: The method lngamma() is deprecated. Use log_gamma() instead.
-            See http://trac.sagemath.org/6992 for details.
             359.134205369575
         """
-        from sage.misc.superseded import deprecation
-        deprecation(6992, "The method lngamma() is deprecated. Use log_gamma() instead.")
         return x.log_gamma(precision)
 
     def log_gamma(gen x, unsigned long precision=0):
@@ -4741,7 +4744,7 @@ cdef class gen(sage.structure.element.RingElement):
             0.634963914784736 + 1.29845758141598*I
         """
         pari_catch_sig_on()
-        return P.new_gen(gsh(x.g, prec_bits_to_words(precision)))
+        return P.new_gen(gsinh(x.g, prec_bits_to_words(precision)))
 
     def sqr(gen x):
         """
@@ -4834,11 +4837,11 @@ cdef class gen(sage.structure.element.RingElement):
             sage: s^5
             2.00000000000000
             sage: z^5
-            1.00000000000000 + 5.42101086 E-19*I        # 32-bit
-            1.00000000000000 + 5.96311194867027 E-19*I  # 64-bit
+            1.00000000000000 - 2.710505431 E-20*I       # 32-bit
+            1.00000000000000 - 2.71050543121376 E-20*I  # 64-bit
             sage: (s*z)^5
-            2.00000000000000 + 1.409462824 E-18*I       # 32-bit
-            2.00000000000000 + 9.21571846612679 E-19*I  # 64-bit
+            2.00000000000000 + 0.E-19*I                 # 32-bit
+            2.00000000000000 - 1.08420217248550 E-19*I  # 64-bit
         """
         # TODO: ???  lots of good examples in the PARI docs ???
         cdef GEN zetan
@@ -4890,7 +4893,7 @@ cdef class gen(sage.structure.element.RingElement):
             1.55740772465490
         """
         pari_catch_sig_on()
-        return P.new_gen(gth(x.g, prec_bits_to_words(precision)))
+        return P.new_gen(gtanh(x.g, prec_bits_to_words(precision)))
 
     def teichmuller(gen x):
         r"""
@@ -4964,8 +4967,7 @@ cdef class gen(sage.structure.element.RingElement):
 
             sage: C.<i> = ComplexField()
             sage: pari(i).weber()
-            1.18920711500272 + 0.E-19*I                 # 32-bit
-            1.18920711500272 + 2.71050543121376 E-20*I  # 64-bit
+            1.18920711500272
             sage: pari(i).weber(1)
             1.09050773266526
             sage: pari(i).weber(2)
@@ -5246,17 +5248,19 @@ cdef class gen(sage.structure.element.RingElement):
             4
         """
         pari_catch_sig_on()
-        return P.new_gen(gnumbdiv(n.g))
+        return P.new_gen(numdiv(n.g))
 
     def phi(gen n):
         """
-        Return the Euler phi function of n. EXAMPLES::
+        Return the Euler phi function of n.
+        
+        EXAMPLES::
 
             sage: pari(10).phi()
             4
         """
         pari_catch_sig_on()
-        return P.new_gen(geulerphi(n.g))
+        return P.new_gen(eulerphi(n.g))
 
     def primepi(gen self):
         """
@@ -5390,11 +5394,9 @@ cdef class gen(sage.structure.element.RingElement):
         INPUT:
 
 
-        -  ``self`` - a list of 5 coefficients
+        -  ``self`` -- a list of 5 coefficients
 
-        -  ``flag (optional, default: 0)`` - if 0, ask for a PARI ell
-           structure with 19 components; if 1, ask for a shorted PARI
-           sell structure with only the first 13 components.
+        -  ``flag`` -- ignored (for backwards compatibility)
 
         -  ``precision (optional, default: 0)`` - the real
            precision to be used in the computation of the components of the
@@ -5412,80 +5414,62 @@ cdef class gen(sage.structure.element.RingElement):
 
         OUTPUT:
 
+        -  ``gen`` - a PARI ell structure.
 
-        -  ``gen`` - either a PARI ell structure with 19 components
-           (if flag=0), or a PARI sell structure with 13 components
-           (if flag=1).
-
-
-        EXAMPLES: An elliptic curve with integer coefficients::
+        EXAMPLES:
+        
+        An elliptic curve with integer coefficients::
 
             sage: e = pari([0,1,0,1,0]).ellinit(); e
-            [0, 1, 0, 1, 0, 4, 2, 0, -1, -32, 224, -48, 2048/3, [0.E-28, -0.500000000000000 - 0.866025403784439*I, -0.500000000000000 + 0.866025403784439*I]~, 3.37150070962519, -1.68575035481260 - 2.15651564749964*I, 1.37451455785745 - 1.084202173 E-19*I,      -0.687257278928726 + 0.984434956803824*I, 7.27069403586288] # 32-bit
-            [0, 1, 0, 1, 0, 4, 2, 0, -1, -32, 224, -48, 2048/3, [0.E-38, -0.500000000000000 - 0.866025403784439*I, -0.500000000000000 + 0.866025403784439*I]~, 3.37150070962519, -1.68575035481260 - 2.15651564749964*I, 1.37451455785745 - 5.42101086242752 E-19*I, -0.687257278928726 + 0.984434956803824*I, 7.27069403586288] # 64-bit
-
-        Its inexact components have the default precision of 53 bits::
-
-            sage: RR(e[14])
-            3.37150070962519
-
-        We can compute this to higher precision::
-
-            sage: R = RealField(150)
-            sage: e = pari([0,1,0,1,0]).ellinit(precision=150)
-            sage: R(e[14])
-            3.3715007096251920857424073155981539790016018
-
-        Using flag=1 returns a short elliptic curve PARI object::
-
-            sage: pari([0,1,0,1,0]).ellinit(flag=1)
-            [0, 1, 0, 1, 0, 4, 2, 0, -1, -32, 224, -48, 2048/3]
+            [0, 1, 0, 1, 0, 4, 2, 0, -1, -32, 224, -48, 2048/3, Vecsmall([1]), [Vecsmall([64, -1])], [0, 0, 0, 0, 0, 0, 0, 0]]
 
         The coefficients can be any ring elements that convert to PARI::
 
-            sage: pari([0,1/2,0,-3/4,0]).ellinit(flag=1)
-            [0, 1/2, 0, -3/4, 0, 2, -3/2, 0, -9/16, 40, -116, 117/4, 256000/117]
-            sage: pari([0,0.5,0,-0.75,0]).ellinit(flag=1)
-            [0, 0.500000000000000, 0, -0.750000000000000, 0, 2.00000000000000, -1.50000000000000, 0, -0.562500000000000, 40.0000000000000, -116.000000000000, 29.2500000000000, 2188.03418803419]
-            sage: pari([0,I,0,1,0]).ellinit(flag=1)
-            [0, I, 0, 1, 0, 4*I, 2, 0, -1, -64, 352*I, -80, 16384/5]
-            sage: pari([0,x,0,2*x,1]).ellinit(flag=1)
-            [0, x, 0, 2*x, 1, 4*x, 4*x, 4, -4*x^2 + 4*x, 16*x^2 - 96*x, -64*x^3 + 576*x^2 - 864, 64*x^4 - 576*x^3 + 576*x^2 - 432, (256*x^6 - 4608*x^5 + 27648*x^4 - 55296*x^3)/(4*x^4 - 36*x^3 + 36*x^2 - 27)]
+            sage: pari([0,1/2,0,-3/4,0]).ellinit()
+            [0, 1/2, 0, -3/4, 0, 2, -3/2, 0, -9/16, 40, -116, 117/4, 256000/117, Vecsmall([1]), [Vecsmall([64, 1])], [0, 0, 0, 0, 0, 0, 0, 0]]
+            sage: pari([0,0.5,0,-0.75,0]).ellinit()
+            [0, 0.500000000000000, 0, -0.750000000000000, 0, 2.00000000000000, -1.50000000000000, 0, -0.562500000000000, 40.0000000000000, -116.000000000000, 29.2500000000000, 2188.03418803419, Vecsmall([0]), [Vecsmall([64, 1])], [0, 0, 0, 0]]
+            sage: pari([0,I,0,1,0]).ellinit()
+            [0, I, 0, 1, 0, 4*I, 2, 0, -1, -64, 352*I, -80, 16384/5, Vecsmall([0]), [Vecsmall([64, 0])], [0, 0, 0, 0]]
+            sage: pari([0,x,0,2*x,1]).ellinit()
+            [0, x, 0, 2*x, 1, 4*x, 4*x, 4, -4*x^2 + 4*x, 16*x^2 - 96*x, -64*x^3 + 576*x^2 - 864, 64*x^4 - 576*x^3 + 576*x^2 - 432, (256*x^6 - 4608*x^5 + 27648*x^4 - 55296*x^3)/(4*x^4 - 36*x^3 + 36*x^2 - 27), Vecsmall([0]), [Vecsmall([64, 0])], [0, 0, 0, 0]]
         """
+        if flag:
+            from sage.misc.superseded import deprecation
+            deprecation(15767, 'The flag argument to ellinit() is deprecated and not used anymore')
         pari_catch_sig_on()
-        return P.new_gen(ellinit0(self.g, flag, prec_bits_to_words(precision)))
+        return P.new_gen(ellinit(self.g, NULL, prec_bits_to_words(precision)))
 
     def ellglobalred(self):
         """
-        e.ellglobalred(): return information related to the global minimal
-        model of the elliptic curve e.
+        Return information related to the global minimal model of the
+        elliptic curve e.
 
         INPUT:
 
+        - ``e`` -- elliptic curve (returned by ellinit)
 
-        -  ``e`` - elliptic curve (returned by ellinit)
+        OUTPUT: A vector [N, [u,r,s,t], c, faN, L] with
 
+        - ``N`` - the (arithmetic) conductor of `e`
 
-        OUTPUT:
-
-
-        -  ``gen`` - the (arithmetic) conductor of e
-
-        -  ``gen`` - a vector giving the coordinate change over
+        - ``[u,r,s,t]`` - a vector giving the coordinate change over
            Q from e to its minimal integral model (see also ellminimalmodel)
 
-        -  ``gen`` - the product of the local Tamagawa numbers
-           of e
+        - ``c`` - the product of the local Tamagawa numbers of `e`.
 
+        - ``faN`` is the factorization of `N`
+        
+        - ``L[i]`` is ``elllocalred(E, faN[i,1])``
 
         EXAMPLES::
 
             sage: e = pari([0, 5, 2, -1, 1]).ellinit()
             sage: e.ellglobalred()
-            [20144, [1, -2, 0, -1], 1]
+            [20144, [1, -2, 0, -1], 1, [2, 4; 1259, 1], [[4, 2, 0, 1], [1, 5, 0, 1]]]
             sage: e = pari(EllipticCurve('17a').a_invariants()).ellinit()
             sage: e.ellglobalred()
-            [17, [1, 0, 0, 0], 4]
+            [17, [1, 0, 0, 0], 4, Mat([17, 1]), [[1, 8, 0, 4]]]
         """
         pari_catch_sig_on()
         return P.new_gen(ellglobalred(self.g))
@@ -5507,11 +5491,11 @@ cdef class gen(sage.structure.element.RingElement):
 
         OUTPUT: point on E
 
-        EXAMPLES: First we create an elliptic curve::
+        EXAMPLES:
+        
+        First we create an elliptic curve::
 
             sage: e = pari([0, 1, 1, -2, 0]).ellinit()
-            sage: str(e)[:65]   # first part of output
-            '[0, 1, 1, -2, 0, 4, -4, 1, -3, 112, -856, 389, 1404928/389, [0.90'
 
         Next we add two points on the elliptic curve. Notice that the
         Python lists are automatically converted to PARI objects so you
@@ -5525,7 +5509,7 @@ cdef class gen(sage.structure.element.RingElement):
         cdef gen t0 = objtogen(z0)
         cdef gen t1 = objtogen(z1)
         pari_catch_sig_on()
-        return P.new_gen(addell(self.g, t0.g, t1.g))
+        return P.new_gen(elladd(self.g, t0.g, t1.g))
 
     def ellak(self, n):
         r"""
@@ -5767,18 +5751,16 @@ cdef class gen(sage.structure.element.RingElement):
 
         INPUT:
 
-
         -  ``e`` - elliptic curve
 
         -  ``ch`` - change of coordinates vector with 4
            entries
 
-
         EXAMPLES::
 
             sage: e = pari([1,2,3,4,5]).ellinit()
             sage: e.ellglobalred()
-            [10351, [1, -1, 0, -1], 1]
+            [10351, [1, -1, 0, -1], 1, [11, 1; 941, 1], [[1, 5, 0, 1], [1, 5, 0, 1]]]
             sage: f = e.ellchangecurve([1,-1,0,-1])
             sage: f[:5]
             [1, -1, 0, 4, 3]
@@ -5804,10 +5786,6 @@ cdef class gen(sage.structure.element.RingElement):
             6.28318530717959*I
             sage: w1*eta2-w2*eta1 == pari(2*pi*I)
             True
-            sage: pari([0,0,0,-82,0]).ellinit(flag=1).elleta()
-            Traceback (most recent call last):
-            ...
-            PariError: incorrect type in elleta
         """
         pari_catch_sig_on()
         return P.new_gen(elleta(self.g, prec_bits_to_words(precision)))
@@ -5850,7 +5828,8 @@ cdef class gen(sage.structure.element.RingElement):
             sage: e.ellheight([1,0], flag=1)
             0.476711659343740
             sage: e.ellheight([1,0], precision=128).sage()
-            0.47671165934373953737948605888465305932
+            0.47671165934373953737948605888465305945902294217            # 32-bit
+            0.476711659343739537379486058884653059459022942211150879336  # 64-bit
         """
         cdef gen t0 = objtogen(a)
         pari_catch_sig_on()
@@ -5879,13 +5858,6 @@ cdef class gen(sage.structure.element.RingElement):
             sage: e = pari([0,1,1,-2,0]).ellinit().ellminimalmodel()[0]
             sage: e.ellheightmatrix([[1,0], [-1,1]])
             [0.476711659343740, 0.418188984498861; 0.418188984498861, 0.686667083305587]
-
-        It is allowed to call :meth:`ellinit` with ``flag=1``::
-
-            sage: E = pari([0,1,1,-2,0]).ellinit(flag=1)
-            sage: E.ellheightmatrix([[1,0], [-1,1]], precision=128).sage()
-            [0.47671165934373953737948605888465305932 0.41818898449886058562988945821587638244]
-            [0.41818898449886058562988945821587638244 0.68666708330558658572355210295409678904]
         """
         cdef gen t0 = objtogen(x)
         pari_catch_sig_on()
@@ -6100,9 +6072,9 @@ cdef class gen(sage.structure.element.RingElement):
             sage: e.elllseries(2.1)
             0.402838047956645
             sage: e.elllseries(1, precision=128)
-            2.87490929644255 E-38
+            2.98766720445395 E-38
             sage: e.elllseries(1, precision=256)
-            3.00282377034977 E-77
+            5.48956813891054 E-77
             sage: e.elllseries(-2)
             0
             sage: e.elllseries(2.1, A=1.1)
@@ -6217,8 +6189,6 @@ cdef class gen(sage.structure.element.RingElement):
             []
             sage: e.ellordinate(5.0)
             [11.3427192823270, -12.3427192823270]
-            sage: e.ellordinate(RR(-3))
-            [-1/2 + 3.42782730020052*I, -1/2 - 3.42782730020052*I]
         """
         cdef gen t0 = objtogen(x)
         pari_catch_sig_on()
@@ -6311,26 +6281,19 @@ cdef class gen(sage.structure.element.RingElement):
         cdef gen t0 = objtogen(z)
         cdef gen t1 = objtogen(n)
         pari_catch_sig_on()
-        return P.new_gen(powell(self.g, t0.g, t1.g))
+        return P.new_gen(ellmul(self.g, t0.g, t1.g))
 
-    def ellrootno(self, p=1):
+    def ellrootno(self, p=None):
         """
-        e.ellrootno(p): return the (local or global) root number of the
-        `L`-series of the elliptic curve e
-
-        If p is a prime number, the local root number at p is returned. If
-        p is 1, the global root number is returned. Note that the global
-        root number is the sign of the functional equation of the
-        `L`-series, and therefore conjecturally equal to the parity
-        of the rank of e.
+        Return the root number for the L-function of the elliptic curve
+        E/Q at a prime p (including 0, for the infinite place); return
+        the global root number if p is omitted.
 
         INPUT:
 
-
         -  ``e`` - elliptic curve over `\QQ`
 
-        -  ``p (default = 1)`` - 1 or a prime number
-
+        -  ``p`` - a prime number or ``None``.
 
         OUTPUT: 1 or -1
 
@@ -6344,9 +6307,19 @@ cdef class gen(sage.structure.element.RingElement):
             sage: e.ellrootno(1009)
             1
         """
-        cdef gen t0 = objtogen(p)
+        cdef gen t0
+        cdef GEN g0
+        if p is None:
+            g0 = NULL
+        elif p == 1:
+            from sage.misc.superseded import deprecation
+            deprecation(15767, 'The argument p=1 in ellrootno() is deprecated, use p=None instead')
+            g0 = NULL
+        else:
+            t0 = objtogen(p)
+            g0 = t0.g
         pari_catch_sig_on()
-        rootno = ellrootno(self.g, t0.g)
+        rootno = ellrootno(self.g, g0)
         pari_catch_sig_off()
         return rootno
 
@@ -6392,11 +6365,11 @@ cdef class gen(sage.structure.element.RingElement):
         cdef gen t0 = objtogen(z0)
         cdef gen t1 = objtogen(z1)
         pari_catch_sig_on()
-        return P.new_gen(subell(self.g, t0.g, t1.g))
+        return P.new_gen(ellsub(self.g, t0.g, t1.g))
 
-    def elltaniyama(self):
+    def elltaniyama(self, long n=16):
         pari_catch_sig_on()
-        return P.new_gen(taniyama(self.g))
+        return P.new_gen(elltaniyama(self.g, n))
 
     def elltors(self, long flag=0):
         """
@@ -6438,7 +6411,7 @@ cdef class gen(sage.structure.element.RingElement):
 
             sage: e = pari([1,0,1,-19,26]).ellinit()
             sage: e.elltors()
-            [12, [6, 2], [[-2, 8], [3, -2]]]
+            [12, [6, 2], [[1, 2], [3, -2]]]
         """
         pari_catch_sig_on()
         return P.new_gen(elltors0(self.g, flag))
@@ -6467,8 +6440,7 @@ cdef class gen(sage.structure.element.RingElement):
 
             sage: e = pari([0,0,0,1,0]).ellinit()
             sage: e.ellzeta(1)
-            1.06479841295883 + 0.E-19*I                # 32-bit
-            1.06479841295883 + 5.42101086242752 E-20*I # 64-bit
+            1.06479841295883
             sage: C.<i> = ComplexField()
             sage: e.ellzeta(i-1)
             -0.350122658523049 - 0.350122658523049*I
@@ -6498,8 +6470,7 @@ cdef class gen(sage.structure.element.RingElement):
             sage: e = pari([0,0,0,1,0]).ellinit()
             sage: C.<i> = ComplexField()
             sage: e.ellztopoint(1+i)
-            [0.E-19                - 1.02152286795670*I, -0.149072813701096 - 0.149072813701096*I]  # 32-bit
-            [7.96075508054992 E-21 - 1.02152286795670*I, -0.149072813701096 - 0.149072813701096*I]  # 64-bit
+            [0.E-19 - 1.02152286795670*I, -0.149072813701096 - 0.149072813701096*I]
 
         Complex numbers belonging to the period lattice of e are of course
         sent to the point at infinity on e::
@@ -6511,7 +6482,7 @@ cdef class gen(sage.structure.element.RingElement):
         pari_catch_sig_on()
         return P.new_gen(pointell(self.g, t0.g, prec_bits_to_words(precision)))
 
-    def omega(self):
+    def omega(self, unsigned long precision=0):
         """
         e.omega(): return basis for the period lattice of the elliptic
         curve e.
@@ -6520,9 +6491,10 @@ cdef class gen(sage.structure.element.RingElement):
 
             sage: e = pari([0, -1, 1, -10, -20]).ellinit()
             sage: e.omega()
-            [1.26920930427955, -0.634604652139777 - 1.45881661693850*I]
+            [1.26920930427955, 0.634604652139777 - 1.45881661693850*I]
         """
-        return self[14:16]
+        pari_catch_sig_on()
+        return P.new_gen(ellR_omega(self.g, prec_bits_to_words(precision)))
 
     def disc(self):
         """
@@ -6536,7 +6508,8 @@ cdef class gen(sage.structure.element.RingElement):
             sage: _.factor()
             [-1, 1; 11, 5]
         """
-        return self[11]
+        pari_catch_sig_on()
+        return P.new_gen(member_disc(self.g))
 
     def j(self):
         """
@@ -6550,7 +6523,8 @@ cdef class gen(sage.structure.element.RingElement):
             sage: _.factor()
             [-1, 1; 2, 12; 11, -5; 31, 3]
         """
-        return self[12]
+        pari_catch_sig_on()
+        return P.new_gen(member_j(self.g))
 
     def ellj(self, unsigned long precision=0):
         """
@@ -6569,7 +6543,7 @@ cdef class gen(sage.structure.element.RingElement):
             sage: pari(-I).ellj()
             Traceback (most recent call last):
             ...
-            PariError: argument '-I' does not belong to upper half-plane
+            PariError: domain error in modular function: Im(argument) <= 0
         """
         pari_catch_sig_on()
         return P.new_gen(jell(self.g, prec_bits_to_words(precision)))
@@ -6867,7 +6841,7 @@ cdef class gen(sage.structure.element.RingElement):
 
             sage: K.<i> = QuadraticField(-1)
             sage: F = pari(K).idealprimedec(5); F
-            [[5, [-2, 1]~, 1, 1, [2, 1]~], [5, [2, 1]~, 1, 1, [-2, 1]~]]
+            [[5, [-2, 1]~, 1, 1, [2, -1; 1, 2]], [5, [2, 1]~, 1, 1, [-2, -1; 1, -2]]]
             sage: F[0].pr_get_p()
             5
         """
@@ -6909,7 +6883,7 @@ cdef class gen(sage.structure.element.RingElement):
             sage: nf = F._pari_()
             sage: I = pari('[1, -1, 2]~')
             sage: nf.idealstar(I)
-            [[[43, 9, 5; 0, 1, 0; 0, 0, 1], [0]], [42, [42]], Mat([[43, [9, 1, 0]~, 1, 1, [-5, -9, 1]~], 1]), [[[[42], [[3, 0, 0]~], [[3, 0, 0]~], [Vecsmall([])], 1]], [[], [], []]], Mat(1)]
+            [[[43, 9, 5; 0, 1, 0; 0, 0, 1], [0]], [42, [42]], Mat([[43, [9, 1, 0]~, 1, 1, [-5, 2, -18; -9, -5, 2; 1, -9, -5]], 1]), [[[[42], [3], [3], [Vecsmall([])], 1]], [[], [], []]], Mat(1)]
         """
         cdef gen t0 = objtogen(I)
         pari_catch_sig_on()
@@ -6953,18 +6927,30 @@ cdef class gen(sage.structure.element.RingElement):
 
     def nfbasis(self, long flag=0, fa=None):
         """
-        nfbasis(x, flag, fa): integral basis of the field QQ[a], where ``a`` is
-        a root of the polynomial x.
+        Integral basis of the field `\QQ[a]`, where ``a`` is a root of
+        the polynomial x.
 
-        Binary digits of ``flag`` mean:
+        INPUT:
+
+        - ``flag``: if set to 1 and ``fa`` is not given: assume that no
+          square of a prime > 500000 divides the discriminant of ``x``.
+
+        - ``fa``: If present, encodes a subset of primes at which to
+          check for maximality. This must be one of the three following
+          things:
+        
+            - an integer: check all primes up to ``fa`` using trial
+              division.
 
-         - 1: assume that no square of a prime>primelimit divides the
-              discriminant of ``x``.
-         - 2: use round 2 algorithm instead of round 4.
+            - a vector: a list of primes to check.
+
+            - a matrix: a partial factorization of the discriminant
+              of ``x``.
+
+        .. NOTE::
 
-        If present, ``fa`` provides the matrix of a partial factorization of
-        the discriminant of ``x``, useful if one wants only an order maximal at
-        certain primes only.
+            In earlier versions of Sage, other bits in ``flag`` were
+            defined but these are now simply ignored.
 
         EXAMPLES::
 
@@ -6981,29 +6967,34 @@ cdef class gen(sage.structure.element.RingElement):
             [1, x]
             sage: pari(f).nfbasis()    # Correct result
             [1, 1/10000000019*x]
-            sage: pari(f).nfbasis(fa = "[2,2; %s,2]"%p)    # Correct result and faster
+            sage: pari(f).nfbasis(fa=10^6)   # Check primes up to 10^6: wrong result
+            [1, x]
+            sage: pari(f).nfbasis(fa="[2,2; %s,2]"%p)    # Correct result and faster
+            [1, 1/10000000019*x]
+            sage: pari(f).nfbasis(fa=[2,p])              # Equivalent with the above
             [1, 1/10000000019*x]
-
-        TESTS:
-
-        ``flag`` = 2 should give the same result::
-
-            sage: pari('x^3 - 17').nfbasis(flag = 2)
-            [1, x, 1/3*x^2 - 1/3*x + 1/3]
         """
+        if flag < 0 or flag > 1:
+            flag = flag & 1
+            from sage.misc.superseded import deprecation
+            deprecation(15767, 'In nfbasis(), flag must be 0 or 1, other bits are deprecated and ignored')
+
         cdef gen t0
-        if not fa:
-            pari_catch_sig_on()
-            return P.new_gen(nfbasis0(self.g, flag, NULL))
-        else:
+        cdef GEN g0
+        if fa is not None:
             t0 = objtogen(fa)
-            pari_catch_sig_on()
-            return P.new_gen(nfbasis0(self.g, flag, t0.g))
+            g0 = t0.g
+        elif flag:
+            g0 = utoi(500000)
+        else:
+            g0 = NULL
+        pari_catch_sig_on()
+        return P.new_gen(nfbasis(self.g, NULL, g0))
 
     def nfbasis_d(self, long flag=0, fa=None):
         """
-        nfbasis_d(x): Return a basis of the number field defined over QQ
-        by x and its discriminant.
+        Like :meth:`nfbasis`, but return a tuple ``(B, D)`` where `B`
+        is the integral basis and `D` the discriminant.
 
         EXAMPLES::
 
@@ -7022,15 +7013,23 @@ cdef class gen(sage.structure.element.RingElement):
             sage: pari([-2,0,0,1]).Polrev().nfbasis_d()
             ([1, x, x^2], -108)
         """
+        if flag < 0 or flag > 1:
+            flag = flag & 1
+            from sage.misc.superseded import deprecation
+            deprecation(15767, 'In nfbasis_d(), flag must be 0 or 1, other bits are deprecated and ignored')
+
         cdef gen t0
+        cdef GEN g0
         cdef GEN disc
-        if not fa:
-            pari_catch_sig_on()
-            B = P.new_gen_noclear(nfbasis(self.g, &disc, flag, NULL))
-        else:
+        if fa is not None:
             t0 = objtogen(fa)
-            pari_catch_sig_on()
-            B = P.new_gen_noclear(nfbasis(self.g, &disc, flag, t0.g))
+            g0 = t0.g
+        elif flag & 1:
+            g0 = utoi(500000)
+        else:
+            g0 = NULL
+        pari_catch_sig_on()
+        B = P.new_gen_noclear(nfbasis(self.g, &disc, g0))
         D = P.new_gen(disc)
         return B, D
 
@@ -7247,18 +7246,13 @@ cdef class gen(sage.structure.element.RingElement):
             sage: A = matrix(F,[[1,2,a,3],[3,0,a+2,0],[0,0,a,2],[3+a,a,0,1]])
             sage: I = [F.ideal(-2*a+1),F.ideal(7), F.ideal(3),F.ideal(1)]
             sage: Fp.nfhnf([pari(A),[pari(P) for P in I]])
-            [[1, [-969/5, -1/15]~, [15, -2]~, [-1938, -3]~; 0, 1, 0, 0; 0, 0, 1, 0;
-            0, 0, 0, 1], [[3997, 1911; 0, 7], [15, 6; 0, 3], [1, 0; 0, 1], [1, 0; 0,
-            1]]]
+            [[1, [-969/5, -1/15]~, [15, -2]~, [-1938, -3]~; 0, 1, 0, 0; 0, 0, 1, 0; 0, 0, 0, 1], [[3997, 1911; 0, 7], [15, 6; 0, 3], 1, 1]]
             sage: K.<b> = NumberField(x^3-2)
             sage: Kp = pari(K)
             sage: A = matrix(K,[[1,0,0,5*b],[1,2*b^2,b,57],[0,2,1,b^2-3],[2,0,0,b]])
             sage: I = [K.ideal(2),K.ideal(3+b^2),K.ideal(1),K.ideal(1)]
             sage: Kp.nfhnf([pari(A),[pari(P) for P in I]])
-            [[1, -225, 72, -31; 0, 1, [0, -1, 0]~, [0, 0, -1/2]~; 0, 0, 1, [0, 0,
-            -1/2]~; 0, 0, 0, 1], [[1116, 756, 612; 0, 18, 0; 0, 0, 18], [2, 0, 0; 0,
-            2, 0; 0, 0, 2], [1, 0, 0; 0, 1, 0; 0, 0, 1], [2, 0, 0; 0, 1, 0; 0, 0,
-            1]]]
+            [[1, -225, 72, -31; 0, 1, [0, -1, 0]~, [0, 0, -1/2]~; 0, 0, 1, [0, 0, -1/2]~; 0, 0, 0, 1], [[1116, 756, 612; 0, 18, 0; 0, 0, 18], 2, 1, [2, 0, 0; 0, 1, 0; 0, 0, 1]]]
 
         An example where the ring of integers of the number field is not a PID::
 
@@ -7267,15 +7261,11 @@ cdef class gen(sage.structure.element.RingElement):
             sage: A = matrix(K,[[1,0,0,5*b],[1,2*b^2,b,57],[0,2,1,b^2-3],[2,0,0,b]])
             sage: I = [K.ideal(2),K.ideal(3+b^2),K.ideal(1),K.ideal(1)]
             sage: Kp.nfhnf([pari(A),[pari(P) for P in I]])
-            [[1, [15, 6]~, [0, -54]~, [113, 72]~; 0, 1, [-4, -1]~, [0, -1]~; 0, 0,
-            1, 0; 0, 0, 0, 1], [[360, 180; 0, 180], [6, 4; 0, 2], [1, 0; 0, 1], [1,
-            0; 0, 1]]]
+            [[1, [15, 6]~, [0, -54]~, [113, 72]~; 0, 1, [-4, -1]~, [0, -1]~; 0, 0, 1, 0; 0, 0, 0, 1], [[360, 180; 0, 180], [6, 4; 0, 2], 1, 1]]
             sage: A = matrix(K,[[1,0,0,5*b],[1,2*b,b,57],[0,2,1,b-3],[2,0,b,b]])
             sage: I = [K.ideal(2).factor()[0][0],K.ideal(3+b),K.ideal(1),K.ideal(1)]
             sage: Kp.nfhnf([pari(A),[pari(P) for P in I]])
-            [[1, [7605, 4]~, [5610, 5]~, [7913, -6]~; 0, 1, 0, -1; 0, 0, 1, 0; 0, 0,
-            0, 1], [[19320, 13720; 0, 56], [2, 1; 0, 1], [1, 0; 0, 1], [1, 0; 0,
-            1]]]
+            [[1, [7605, 4]~, [5610, 5]~, [7913, -6]~; 0, 1, 0, -1; 0, 0, 1, 0; 0, 0, 0, 1], [[19320, 13720; 0, 56], [2, 1; 0, 1], 1, 1]]
 
         AUTHORS:
 
@@ -7302,41 +7292,19 @@ cdef class gen(sage.structure.element.RingElement):
         EXAMPLES::
 
             sage: pari('x^3 - 17').nfinit()
-            [x^3 - 17, [1, 1], -867, 3, [[1, 1.68006..., 2.57128...; 1, -0.340034... + 2.65083...*I, -1.28564... - 2.22679...*I], [1, 1.68006..., 2.57128...; 1, 2.31080..., -3.51243...; 1, -2.99087..., 0.941154...], [1, 2, 3; 1, 2, -4; 1, -3, 1], [3, 1, 0; 1, -11, 17; 0, 17, 0], [51, 0, 16; 0, 17, 3; 0, 0, 1], [17, 0, -1; 0, 0, 3; -1, 3, 2], [51, [-17, 6, -1; 0, -18, 3; 1, 0, -16]]], [2.57128..., -1.28564... - 2.22679...*I], [1, 1/3*x^2 - 1/3*x + 1/3, x], [1, 0, -1; 0, 0, 3; 0, 1, 1], [1, 0, 0, 0, -4, 6, 0, 6, -1; 0, 1, 0, 1, 1, -1, 0, -1, 3; 0, 0, 1, 0, 2, 0, 1, 0, 1]]
-
-        TESTS:
+            [x^3 - 17, [1, 1], -867, 3, [[1, 1.68006914259990, 2.57128159065824; 1, -0.340034571299952 - 2.65083754153991*I, -1.28564079532912 + 2.22679517779329*I], [1, 1.68006914259990, 2.57128159065824; 1, -2.99087211283986, 0.941154382464174; 1, 2.31080297023995, -3.51243597312241], [1, 2, 3; 1, -3, 1; 1, 2, -4], [3, 1, 0; 1, -11, 17; 0, 17, 0], [51, 0, 16; 0, 17, 3; 0, 0, 1], [17, 0, -1; 0, 0, 3; -1, 3, 2], [51, [-17, 6, -1; 0, -18, 3; 1, 0, -16]], [3, 17]], [2.57128159065824, -1.28564079532912 + 2.22679517779329*I], [1, 1/3*x^2 - 1/3*x + 1/3, x], [1, 0, -1; 0, 0, 3; 0, 1, 1], [1, 0, 0, 0, -4, 6, 0, 6, -1; 0, 1, 0, 1, 1, -1, 0, -1, 3; 0, 0, 1, 0, 2, 0, 1, 0, 1]]
 
-        This example only works after increasing precision::
+        TESTS::
 
-            sage: pari('x^2 + 10^100 + 1').nfinit(precision=64)
-            Traceback (most recent call last):
-            ...
-            PariError: precision too low in floorr (precision loss in truncation)
             sage: pari('x^2 + 10^100 + 1').nfinit()
             [...]
-
-        Throw a PARI error which is not of type ``precer``::
-
             sage: pari('1.0').nfinit()
             Traceback (most recent call last):
             ...
-            PariError: incorrect type in checknf
+            PariError: incorrect type in checknf [please apply nfinit()] (t_REAL)
         """
-        # If explicit precision is given, use only that
-        if precision:
-            pari_catch_sig_on()
-            return P.new_gen(nfinit0(self.g, flag, prec_bits_to_words(precision)))
-
-        # Otherwise, start with 64 bits of precision and increase as needed:
-        precision = 64
-        while True:
-            try:
-                return self.nfinit(flag, precision)
-            except PariError as err:
-                if err.errnum() == precer:
-                    precision *= 2
-                else:
-                    raise
+        pari_catch_sig_on()
+        return P.new_gen(nfinit0(self.g, flag, prec_bits_to_words(precision)))
 
     def nfisisom(self, gen other):
         """
@@ -7389,7 +7357,7 @@ cdef class gen(sage.structure.element.RingElement):
 
             sage: nf = pari('x^2 + 1').nfinit()
             sage: nf.nfrootsof1()
-            [4, -x]
+            [4, x]
         """
         pari_catch_sig_on()
         return P.new_gen(rootsof1(self.g))
@@ -7427,12 +7395,12 @@ cdef class gen(sage.structure.element.RingElement):
     def rnfeltabstorel(self, x):
         cdef gen t0 = objtogen(x)
         pari_catch_sig_on()
-        return P.new_gen(rnfelementabstorel(self.g, t0.g))
+        return P.new_gen(rnfeltabstorel(self.g, t0.g))
 
     def rnfeltreltoabs(self, x):
         cdef gen t0 = objtogen(x)
         pari_catch_sig_on()
-        return P.new_gen(rnfelementreltoabs(self.g, t0.g))
+        return P.new_gen(rnfeltreltoabs(self.g, t0.g))
 
     def rnfequation(self, poly, long flag=0):
         cdef gen t0 = objtogen(poly)
@@ -7460,10 +7428,10 @@ cdef class gen(sage.structure.element.RingElement):
 
             sage: P = pari('[[[1, 0]~, [0, 0]~; [0, 0]~, [1, 0]~], [[2, 0; 0, 2], [2, 0; 0, 1/2]]]')
 
-        And this is the HNF of the inert ideal (2) in nf:
+        And this is the inert ideal (2) in nf:
 
             sage: rnf.rnfidealdown(P)
-            [2, 0; 0, 2]
+            2
         """
         cdef gen t0 = objtogen(x)
         pari_catch_sig_on()
@@ -7472,7 +7440,7 @@ cdef class gen(sage.structure.element.RingElement):
     def rnfidealhnf(self, x):
         cdef gen t0 = objtogen(x)
         pari_catch_sig_on()
-        return P.new_gen(rnfidealhermite(self.g, t0.g))
+        return P.new_gen(rnfidealhnf(self.g, t0.g))
 
     def rnfidealnormrel(self, x):
         cdef gen t0 = objtogen(x)
@@ -7523,11 +7491,11 @@ cdef class gen(sage.structure.element.RingElement):
             sage: pari(-23).quadhilbert()
             x^3 - x^2 + 1
             sage: pari(145).quadhilbert()
-            x^4 - x^3 - 3*x^2 + x + 1
+            x^4 - 6*x^2 - 5*x - 1
             sage: pari(-12).quadhilbert()   # Not fundamental
             Traceback (most recent call last):
             ...
-            PariError: quadray needs a fundamental discriminant
+            PariError: domain error in quadray: isfundamental(D) = 0
         """
         pari_catch_sig_on()
         # Precision argument is only used for real quadratic extensions
@@ -7612,7 +7580,7 @@ cdef class gen(sage.structure.element.RingElement):
             sage: pari('1/x').eval(0)
             Traceback (most recent call last):
             ...
-            PariError: division by zero
+            PariError: impossible inverse in gdiv: 0
             sage: pari('1/x + O(x^2)').eval(0)
             Traceback (most recent call last):
             ...
@@ -7620,11 +7588,11 @@ cdef class gen(sage.structure.element.RingElement):
             sage: pari('1/x + O(x^2)').eval(pari('O(x^3)'))
             Traceback (most recent call last):
             ...
-            PariError: division by zero
+            PariError: impossible inverse in gdiv: O(x^3)
             sage: pari('O(x^0)').eval(0)
             Traceback (most recent call last):
             ...
-            PariError: non existent component in truecoeff
+            PariError: domain error in polcoeff: t_SER = O(x^0)
 
         Evaluating multivariate polynomials::
         
@@ -7690,9 +7658,9 @@ cdef class gen(sage.structure.element.RingElement):
             sage: K.<a> = NumberField(x^2 + 1)
             sage: nf = K._pari_()
             sage: nf
-            [y^2 + 1, [0, 1], -4, 1, [Mat([1, 0.E-19 - 1.00000000000000*I]), [1, -1.00000000000000; 1, 1.00000000000000], [1, -1; 1, 1], [2, 0; 0, -2], [2, 0; 0, 2], [1, 0; 0, -1], [1, [0, -1; 1, 0]]], [0.E-19 - 1.00000000000000*I], [1, y], [1, 0; 0, 1], [1, 0, 0, -1; 0, 1, 1, 0]]
+            [y^2 + 1, [0, 1], -4, 1, [Mat([1, 0.E-19 + 1.00000000000000*I]), [1, 1.00000000000000; 1, -1.00000000000000], [1, 1; 1, -1], [2, 0; 0, -2], [2, 0; 0, 2], [1, 0; 0, -1], [1, [0, -1; 1, 0]], []], [0.E-19 + 1.00000000000000*I], [1, y], [1, 0; 0, 1], [1, 0, 0, -1; 0, 1, 1, 0]]
             sage: nf(y='x')
-            [x^2 + 1, [0, 1], -4, 1, [Mat([1, 0.E-19 - 1.00000000000000*I]), [1, -1.00000000000000; 1, 1.00000000000000], [1, -1; 1, 1], [2, 0; 0, -2], [2, 0; 0, 2], [1, 0; 0, -1], [1, [0, -1; 1, 0]]], [0.E-19 - 1.00000000000000*I], [1, x], [1, 0; 0, 1], [1, 0, 0, -1; 0, 1, 1, 0]]
+            [x^2 + 1, [0, 1], -4, 1, [Mat([1, 0.E-19 + 1.00000000000000*I]), [1, 1.00000000000000; 1, -1.00000000000000], [1, 1; 1, -1], [2, 0; 0, -2], [2, 0; 0, 2], [1, 0; 0, -1], [1, [0, -1; 1, 0]], []], [0.E-19 + 1.00000000000000*I], [1, x], [1, 0; 0, 1], [1, 0, 0, -1; 0, 1, 1, 0]]
         """
         cdef long t = typ(self.g)
         cdef gen t0
@@ -7786,7 +7754,7 @@ cdef class gen(sage.structure.element.RingElement):
             sage: T(0)
             Traceback (most recent call last):
             ...
-            PariError: _/_: division by zero
+            PariError: _/_: impossible inverse in gdiv: 0
             sage: pari('() -> 42')(1,2,3)
             Traceback (most recent call last):
             ...
@@ -8012,7 +7980,7 @@ cdef class gen(sage.structure.element.RingElement):
         non-constant polynomial, or False if f is reducible or constant.
         """
         pari_catch_sig_on()
-        cdef long t = itos(gisirreducible(self.g))
+        t = isirreducible(self.g)
         P.clear_stack()
         return t != 0
 
@@ -8055,12 +8023,14 @@ cdef class gen(sage.structure.element.RingElement):
 
     def polroots(self, long flag=0, unsigned long precision=0):
         """
-        polroots(x,flag=0): complex roots of the polynomial x. flag is
-        optional, and can be 0: default, uses Schonhage's method modified
-        by Gourdon, or 1: uses a modified Newton method.
+        Complex roots of the given polynomial using Schonhage's method,
+        as modified by Gourdon.
         """
+        if flag:
+            from sage.misc.superseded import deprecation
+            deprecation(15767, 'The flag argument to polroots() is deprecated and not used anymore')
         pari_catch_sig_on()
-        return P.new_gen(roots0(self.g, flag, prec_bits_to_words(precision)))
+        return P.new_gen(cleanroots(self.g, prec_bits_to_words(precision)))
 
     def polrootsmod(self, p, long flag=0):
         cdef gen t0 = objtogen(p)
@@ -8128,7 +8098,7 @@ cdef class gen(sage.structure.element.RingElement):
             x + O(x^4)
         """
         pari_catch_sig_on()
-        return P.new_gen(recip(self.g))
+        return P.new_gen(serreverse(self.g))
 
     def thueinit(self, long flag=0, unsigned long precision=0):
         pari_catch_sig_on()
@@ -8332,7 +8302,7 @@ cdef class gen(sage.structure.element.RingElement):
              [
                                       [ -5 -10  -2  -7   3]
                                       [  1   2   1   2   0]
-             10, 5.00000000023283..., [  1   2   0   1  -1]
+             10, 5.00000000000000000, [  1   2   0   1  -1]
              ]
 
         """
@@ -8354,14 +8324,31 @@ cdef class gen(sage.structure.element.RingElement):
 
     def qfrep(self, B, long flag=0):
         """
-        qfrep(x,B,flag=0): vector of (half) the number of vectors of norms
-        from 1 to B for the integral and definite quadratic form x. Binary
-        digits of flag mean 1: count vectors of even norm from 1 to 2B, 2:
-        return a t_VECSMALL instead of a t_VEC.
+        Vector of (half) the number of vectors of norms from 1 to `B`
+        for the integral and definite quadratic form ``self``.
+        Binary digits of flag mean 1: count vectors of even norm from
+        1 to `2B`, 2: return a ``t_VECSMALL`` instead of a ``t_VEC``
+        (which is faster).
+
+        EXAMPLES::
+
+            sage: M = pari("[5,1,1;1,3,1;1,1,1]")
+            sage: M.qfrep(20)
+            [1, 1, 2, 2, 2, 4, 4, 3, 3, 4, 2, 4, 6, 0, 4, 6, 4, 5, 6, 4]
+            sage: M.qfrep(20, flag=1)
+            [1, 2, 4, 3, 4, 4, 0, 6, 5, 4, 12, 4, 4, 8, 0, 3, 8, 6, 12, 12]
+            sage: M.qfrep(20, flag=2)
+            Vecsmall([1, 1, 2, 2, 2, 4, 4, 3, 3, 4, 2, 4, 6, 0, 4, 6, 4, 5, 6, 4])
         """
+        # PARI 2.7 always returns a t_VECSMALL, but for backwards
+        # compatibility, we keep returning a t_VEC (unless flag & 2)
         cdef gen t0 = objtogen(B)
+        cdef GEN r
         pari_catch_sig_on()
-        return P.new_gen(qfrep0(self.g, t0.g, flag))
+        r = qfrep0(self.g, t0.g, flag & 1)
+        if (flag & 2) == 0:
+            r = vecsmall_to_vec(r)
+        return P.new_gen(r)
 
     def matsolve(self, B):
         """
@@ -8745,9 +8732,9 @@ cdef class gen(sage.structure.element.RingElement):
         cdef gen t0 = objtogen(y)
         cdef gen t1 = objtogen(p)
         pari_catch_sig_on()
-        ret = hilbert0(x.g, t0.g, t1.g)
-        pari_catch_sig_off()
-        return ret
+        r = hilbert(x.g, t0.g, t1.g)
+        P.clear_stack()
+        return r
 
     def chinese(self, y):
         cdef gen t0 = objtogen(y)
@@ -8786,7 +8773,7 @@ cdef class gen(sage.structure.element.RingElement):
             Mod(236736367459211723407, 473472734918423446802)
         """
         pari_catch_sig_on()
-        return P.new_gen(znprimroot0(self.g))
+        return P.new_gen(znprimroot(self.g))
 
     def __abs__(self):
         return self.abs()
@@ -8814,8 +8801,8 @@ cdef class gen(sage.structure.element.RingElement):
         """
         pari_catch_sig_on()
         if add_one:
-            return P.new_gen(gnextprime(gaddsg(1,self.g)))
-        return P.new_gen(gnextprime(self.g))
+            return P.new_gen(nextprime(gaddsg(1, self.g)))
+        return P.new_gen(nextprime(self.g))
 
     def change_variable_name(self, var):
         """
@@ -8957,12 +8944,12 @@ cdef class gen(sage.structure.element.RingElement):
         pari_catch_sig_on()
         return P.new_gen(charpoly0(self.g, P.get_var(var), flag))
 
-
     def kronecker(gen self, y):
         cdef gen t0 = objtogen(y)
         pari_catch_sig_on()
-        return P.new_gen(gkronecker(self.g, t0.g))
-
+        r = kronecker(self.g, t0.g)
+        P.clear_stack()
+        return r
 
     def type(gen self):
         """
@@ -9107,7 +9094,7 @@ cdef class gen(sage.structure.element.RingElement):
             sage: om = e.omega()
             sage: om
             [2.49021256085506, -1.97173770155165*I]
-            sage: om.elleisnum(2) # was:  -5.28864933965426
+            sage: om.elleisnum(2)
             10.0672605281120
             sage: om.elleisnum(4)
             112.000000000000
@@ -9151,7 +9138,7 @@ cdef class gen(sage.structure.element.RingElement):
         Compute P(1)::
 
             sage: E.ellwp(1)
-            13.9658695257485 + 0.E-18*I
+            13.9658695257485
 
         Compute P(1+i), where i = sqrt(-1)::
 
@@ -9180,11 +9167,18 @@ cdef class gen(sage.structure.element.RingElement):
         With flag=1, compute the pair P(z) and P'(z)::
 
             sage: E.ellwp(1, flag=1)
-            [13.9658695257485 + 0.E-18*I, 50.5619300880073 ... E-18*I]
+            [13.9658695257485, 50.5619893875144]
         """
         cdef gen t0 = objtogen(z)
+        cdef GEN g0 = t0.g
+
+        # Emulate toser_i() but with given precision
         pari_catch_sig_on()
-        return P.new_gen(ellwp0(self.g, t0.g, flag, n+2, prec_bits_to_words(precision)))
+        if typ(g0) == t_POL:
+            g0 = RgX_to_ser(g0, n+4)
+        elif typ(g0) == t_RFRAC:
+            g0 = rfrac_to_ser(g0, n+4)
+        return P.new_gen(ellwp0(self.g, g0, flag, prec_bits_to_words(precision)))
 
     def ellchangepoint(self, y):
         """
@@ -9368,7 +9362,7 @@ class PariError(RuntimeError):
             ....:     pari('1/0')
             ....: except PariError as err:
             ....:     print err.errnum()
-            27
+            30
         """
         return self.args[0]
 
@@ -9414,7 +9408,7 @@ class PariError(RuntimeError):
             ....:     pari('1/0')
             ....: except PariError as err:
             ....:     print err
-            _/_: division by zero
+            _/_: impossible inverse in gdiv: 0
 
         A syntax error::
 
@@ -9424,7 +9418,7 @@ class PariError(RuntimeError):
             PariError: syntax error, unexpected $undefined: !@#$%^&*()
         """
         lines = self.errtext().split('\n')
-        if self.errnum() == syntaxer:
+        if self.errnum() == e_SYNTAX:
             for line in lines:
                 if "syntax error" in line:
                     return line.lstrip(" *").rstrip(" .:")
diff --git a/src/sage/libs/pari/gen_py.py b/src/sage/libs/pari/gen_py.py
index 8ea4e5d..28f05f6 100644
--- a/src/sage/libs/pari/gen_py.py
+++ b/src/sage/libs/pari/gen_py.py
@@ -73,11 +73,11 @@ def pari(x):
 
         sage: K.<a> = NumberField(x^3 - 2)
         sage: pari(K)
-        [y^3 - 2, [1, 1], -108, 1, [[1, 1.25992104989487, 1.58740105196820; 1, -0.629960524947437 - 1.09112363597172*I, -0.793700525984100 + 1.37472963699860*I], [1, 1.25992104989487, 1.58740105196820; 1, -1.72108416091916, 0.581029111014503; 1, 0.461163111024285, -2.16843016298270], [1, 1, 2; 1, -2, 1; 1, 0, -2], [3, 0, 0; 0, 0, 6; 0, 6, 0], [6, 0, 0; 0, 6, 0; 0, 0, 3], [2, 0, 0; 0, 0, 1; 0, 1, 0], [2, [0, 0, 2; 1, 0, 0; 0, 1, 0]]], [1.25992104989487, -0.629960524947437 - 1.09112363597172*I], [1, y, y^2], [1, 0, 0; 0, 1, 0; 0, 0, 1], [1, 0, 0, 0, 0, 2, 0, 2, 0; 0, 1, 0, 1, 0, 0, 0, 0, 2; 0, 0, 1, 0, 1, 0, 1, 0, 0]]
+        [y^3 - 2, [1, 1], -108, 1, [[1, 1.25992104989487, 1.58740105196820; 1, -0.629960524947437 + 1.09112363597172*I, -0.793700525984100 - 1.37472963699860*I], [1, 1.25992104989487, 1.58740105196820; 1, 0.461163111024285, -2.16843016298270; 1, -1.72108416091916, 0.581029111014503], [1, 1, 2; 1, 0, -2; 1, -2, 1], [3, 0, 0; 0, 0, 6; 0, 6, 0], [6, 0, 0; 0, 6, 0; 0, 0, 3], [2, 0, 0; 0, 0, 1; 0, 1, 0], [2, [0, 0, 2; 1, 0, 0; 0, 1, 0]], []], [1.25992104989487, -0.629960524947437 + 1.09112363597172*I], [1, y, y^2], [1, 0, 0; 0, 1, 0; 0, 0, 1], [1, 0, 0, 0, 0, 2, 0, 2, 0; 0, 1, 0, 1, 0, 0, 0, 0, 2; 0, 0, 1, 0, 1, 0, 1, 0, 0]]
 
         sage: E = EllipticCurve('37a1')
         sage: pari(E)
-        [0, 0, 1, -1, 0, 0, -2, 1, -1, 48, -216, 37, 110592/37, [0.837565435283323, 0.269594436405445, -1.10715987168877]~, 2.99345864623196, -2.45138938198679*I, 0.942638555913623, 1.32703057887968*I, 7.33813274078958]
+        [0, 0, 1, -1, 0, 0, -2, 1, -1, 48, -216, 37, 110592/37, Vecsmall([1]), [Vecsmall([64, 1])], [0, 0, 0, 0, 0, 0, 0, 0]]
 
     Conversion from basic Python types::
 
diff --git a/src/sage/libs/pari/handle_error.pyx b/src/sage/libs/pari/handle_error.pyx
index 81472fb..101028b 100644
--- a/src/sage/libs/pari/handle_error.pyx
+++ b/src/sage/libs/pari/handle_error.pyx
@@ -27,7 +27,7 @@ cdef void _pari_init_error_handling():
         ....: except PariError as e:
         ....:     print e.errtext()
         ....:
-          ***   argument must be positive in polcyclo.
+          ***   domain error in polcyclo: index <= 0
 
     """
     global pari_error_string
@@ -73,17 +73,17 @@ cdef int _pari_handle_exception(long err) except 0:
         sage: pari(1)/pari(0)
         Traceback (most recent call last):
         ...
-        PariError: division by zero
+        PariError: impossible inverse in gdiv: 0
 
     """
-    if err == errpile:
+    if err == e_STACK:
         # PARI is out of memory.  We double the size of the PARI stack
         # and retry the computation.
         from sage.libs.pari.all import pari
         pari.allocatemem(silent=True)
         return 0
 
-    if err == user:
+    if err == e_USER:
         raise RuntimeError("PARI user exception\n%s" % pari_error_string)
     else:
         from sage.libs.pari.all import PariError
diff --git a/src/sage/libs/pari/pari_instance.pxd b/src/sage/libs/pari/pari_instance.pxd
index a7242a0..95db20d 100644
--- a/src/sage/libs/pari/pari_instance.pxd
+++ b/src/sage/libs/pari/pari_instance.pxd
@@ -9,6 +9,7 @@ cpdef long prec_bits_to_words(unsigned long prec_in_bits)
 
 @cython.final
 cdef class PariInstance(sage.structure.parent_base.ParentWithBase):
+    cdef long _real_precision
     cdef gen PARI_ZERO, PARI_ONE, PARI_TWO
     cdef inline gen new_gen(self, GEN x)
     cdef inline gen new_gen_noclear(self, GEN x)
diff --git a/src/sage/libs/pari/pari_instance.pyx b/src/sage/libs/pari/pari_instance.pyx
index 7991a62..21e3b36 100644
--- a/src/sage/libs/pari/pari_instance.pyx
+++ b/src/sage/libs/pari/pari_instance.pyx
@@ -20,6 +20,8 @@ AUTHORS:
 
 - Peter Bruin (2013-11-17): split off this file from gen.pyx (#15185)
 
+- Jeroen Demeyer (2014-02-09): upgrade to PARI 2.7 (#15767)
+
 
 EXAMPLES::
 
@@ -44,7 +46,7 @@ Arithmetic obeys the usual coercion rules::
 
 GUIDE TO REAL PRECISION AND THE PARI LIBRARY
 
-The default real precision in communicating with the Pari library
+The default real precision in communicating with the PARI library
 is the same as the default Sage real precision, which is 53 bits.
 Inexact Pari objects are therefore printed by default to 15 decimal
 digits (even if they are actually more precise).
@@ -132,14 +134,15 @@ with a precision of 100 bits::
     True
 
 Elliptic curves and precision: If you are working with elliptic
-curves and want to compute with a precision other than the default
-53 bits, you should use the precision parameter of ellinit()::
+curves, you should set the precision for each method::
 
-    sage: R = RealField(150)
-    sage: e = pari([0,0,0,-82,0]).ellinit(precision=150)
-    sage: eta1 = e.elleta()[0]
-    sage: R(eta1)
-    3.6054636014326520859158205642077267748102690
+    sage: e = pari([0,0,0,-82,0]).ellinit()
+    sage: eta1 = e.elleta(precision=100)[0]
+    sage: eta1.sage()
+    3.6054636014326520859158205642077267748
+    sage: eta1 = e.elleta(precision=180)[0]
+    sage: eta1.sage()
+    3.60546360143265208591582056420772677481026899659802474544
 
 Number fields and precision: TODO
 
@@ -157,9 +160,6 @@ include 'pari_err.pxi'
 include 'sage/ext/stdsage.pxi'
 include 'sage/ext/interrupt.pxi'
 
-cdef extern from 'c_lib/include/memory.h':
-    void init_memory_functions()
-
 import sys
 
 cimport libc.stdlib
@@ -348,8 +348,6 @@ pari_catch_sig_off()
 pari = pari_instance
 
 
-cdef unsigned long num_primes
-
 # Callbacks from PARI to print stuff using sys.stdout.write() instead
 # of C library functions like puts().
 cdef PariOUT sage_pariOut
@@ -432,7 +430,7 @@ cdef class PariInstance(sage.structure.parent_base.ParentWithBase):
         if bot:
             return  # pari already initialized.
 
-        global num_primes, top, bot
+        global top, bot
 
         # The size here doesn't really matter, because we will allocate
         # our own stack anyway. We ask PARI not to set up signal and
@@ -445,8 +443,6 @@ cdef class PariInstance(sage.structure.parent_base.ParentWithBase):
         # so we need to reset them.
         init_memory_functions()
 
-        num_primes = maxprime
-
         # Free the PARI stack and allocate our own (using Cython)
         pari_free(<void*>bot); bot = 0
         init_stack(size)
@@ -465,6 +461,7 @@ cdef class PariInstance(sage.structure.parent_base.ParentWithBase):
         pariErr.flush = sage_pariErr_flush
 
         # Display only 15 digits
+        self._real_precision = 15
         sd_format("g.15", d_SILENT)
 
         # Init global prec variable (PARI's precision is always a
@@ -585,11 +582,12 @@ cdef class PariInstance(sage.structure.parent_base.ParentWithBase):
             sage: pari.set_real_precision(15)
             60
         """
-        prev = self.get_real_precision()
+        prev = self._real_precision
         cdef bytes strn = str(n)
         pari_catch_sig_on()
         sd_realprecision(strn, d_SILENT)
         pari_catch_sig_off()
+        self._real_precision = n
         return prev
 
     def get_real_precision(self):
@@ -608,10 +606,7 @@ cdef class PariInstance(sage.structure.parent_base.ParentWithBase):
             sage: pari.get_real_precision()
             15
         """
-        pari_catch_sig_on()
-        cdef long prev = itos(sd_realprecision(NULL, d_RETURN))
-        pari_catch_sig_off()
-        return prev
+        return self._real_precision
 
     def set_series_precision(self, long n):
         global precdl
@@ -1147,7 +1142,7 @@ cdef class PariInstance(sage.structure.parent_base.ParentWithBase):
     def pari_version(self):
         return str(PARIVERSION)
 
-    def init_primes(self, _M):
+    def init_primes(self, unsigned long M):
         """
         Recompute the primes table including at least all primes up to M
         (but possibly more).
@@ -1156,29 +1151,22 @@ cdef class PariInstance(sage.structure.parent_base.ParentWithBase):
 
             sage: pari.init_primes(200000)
 
-        We make sure that ticket #11741 has been fixed, and double check to
-        make sure that diffptr has not been freed::
+        We make sure that ticket :trac:`11741` has been fixed::
 
-            sage: pari.init_primes(2^62)
+            sage: pari.init_primes(2^30)
             Traceback (most recent call last):
             ...
-            PariError: not enough memory                  # 64-bit
-            OverflowError: long int too large to convert  # 32-bit
-            sage: pari.init_primes(200000)
+            ValueError: Cannot compute primes beyond 436273290
         """
-        cdef unsigned long M
-        cdef char *tmpptr
-        M = _M
-        global diffptr, num_primes
-        if M <= num_primes:
+        # Hardcoded bound in PARI sources
+        if M > 436273290:
+            raise ValueError("Cannot compute primes beyond 436273290")
+
+        if M <= maxprime():
             return
         pari_catch_sig_on()
-        tmpptr = initprimes(M)
+        initprimetable(M)
         pari_catch_sig_off()
-        pari_free(<void*> diffptr)
-        num_primes = M
-        diffptr = tmpptr
-
 
     ##############################################
     ## Support for GP Scripts
@@ -1221,19 +1209,18 @@ cdef class PariInstance(sage.structure.parent_base.ParentWithBase):
 
     def _primelimit(self):
         """
-        Return the number of primes already computed
-        in this Pari instance.
+        Return the number of primes already computed by PARI.
+
+        EXAMPLES::
 
-        EXAMPLES:
             sage: pari._primelimit()
-            500000
+            499979
             sage: pari.init_primes(600000)
             sage: pari._primelimit()
-            600000
+            599999
         """
-        global num_primes
         from sage.rings.all import ZZ
-        return ZZ(num_primes)
+        return ZZ(maxprime())
 
     def prime_list(self, long n):
         """
@@ -1302,8 +1289,6 @@ cdef class PariInstance(sage.structure.parent_base.ParentWithBase):
         """
         nth_prime(n): returns the n-th prime, where n is a C-int
         """
-        global num_primes
-
         if n <= 0:
             raise ValueError, "nth prime meaningless for non-positive n (=%s)"%n
         cdef GEN g
@@ -1311,15 +1296,15 @@ cdef class PariInstance(sage.structure.parent_base.ParentWithBase):
         g = prime(n)
         return self.new_gen(g)
 
-
     def nth_prime(self, long n):
         from sage.libs.pari.all import PariError
         try:
             return self.__nth_prime(n)
         except PariError:
-            self.init_primes(max(2*num_primes,20*n))
+            self.init_primes(max(2*maxprime(), 20*n))
             return self.nth_prime(n)
 
+
     def euler(self, unsigned long precision=0):
         """
         Return Euler's constant to the requested real precision (in bits).
@@ -1488,16 +1473,16 @@ cdef class PariInstance(sage.structure.parent_base.ParentWithBase):
 
         TESTS:
 
-        Check that invalid inputs are handled properly (#11825)::
+        Check that invalid inputs are handled properly (:trac:`11825`)::
 
             sage: pari.setrand(0)
             Traceback (most recent call last):
             ...
-            PariError: incorrect type in setrand
+            PariError: incorrect type in setrand (t_INT)
             sage: pari.setrand("foobar")
             Traceback (most recent call last):
             ...
-            PariError: incorrect type in setrand
+            PariError: incorrect type in setrand (t_POL)
         """
         cdef gen t0 = self(seed)
         pari_catch_sig_on()
@@ -1579,6 +1564,24 @@ cdef class PariInstance(sage.structure.parent_base.ParentWithBase):
                     k = k + 1
         return A
 
+    def genus2red(self, Q, P):
+        """
+        Let Q,P be polynomials with integer coefficients. Determine
+        the reduction at p > 2 of the (proper, smooth) hyperelliptic
+        curve C/Q: y^2+Qy = P, of  genus 2. (The special fiber X_p of
+        the minimal regular model X of C over Z.)
+
+        EXAMPLES::
+
+            sage: x = polygen(QQ)
+            sage: pari.genus2red(x^3 - 2*x^2 - 2*x + 1, -5*x^5)
+            [1416875, [2, -1; 5, 4; 2267, 1], x^6 - 240*x^4 - 2550*x^3 - 11400*x^2 - 24100*x - 19855, [[2, [2, [Mod(1, 2)]], []], [5, [1, []], ["[V] page 156", [3]]], [2267, [2, [Mod(432, 2267)]], ["[I{1-0-0}] page 170", []]]]]
+        """
+        cdef gen t0 = objtogen(Q)
+        cdef gen t1 = objtogen(P)
+        pari_catch_sig_on()
+        return self.new_gen(genus2red(t0.g, t1.g, NULL))
+
 
 cdef int init_stack(size_t requested_size) except -1:
     r"""
diff --git a/src/sage/matrix/matrix_rational_dense.pyx b/src/sage/matrix/matrix_rational_dense.pyx
index cd1ccda..781db98 100644
--- a/src/sage/matrix/matrix_rational_dense.pyx
+++ b/src/sage/matrix/matrix_rational_dense.pyx
@@ -2617,7 +2617,7 @@ cdef class Matrix_rational_dense(matrix_dense.Matrix_dense):
             sage: matrix(QQ,2,[1,2,2,4])._invert_pari()
             Traceback (most recent call last):
             ...
-            PariError: non invertible matrix in gauss
+            PariError: impossible inverse in ginv: 0
         """
         if self._nrows != self._ncols:
             raise ValueError("self must be a square matrix")
diff --git a/src/sage/modular/cusps_nf.py b/src/sage/modular/cusps_nf.py
index 214172a..75c4519 100644
--- a/src/sage/modular/cusps_nf.py
+++ b/src/sage/modular/cusps_nf.py
@@ -41,7 +41,7 @@ Different operations with cusps over a number field:
     sage: alpha.ideal()
     Fractional ideal (7, a + 3)
     sage: alpha.ABmatrix()
-    [a + 10, 3*a - 1, 7, 2*a]
+    [a + 10, -3*a + 1, 7, -2*a]
     sage: alpha.apply([0, 1, -1,0])
     Cusp [7: -a - 10] of Number Field in a with defining polynomial x^2 + 5
 
@@ -895,7 +895,7 @@ class NFCusp(Element):
         Given R a Dedekind domain and A, B ideals of R in inverse classes, an
         AB-matrix is a matrix realizing the isomorphism between R+R and A+B.
         An AB-matrix associated to a cusp [a1: a2] is an AB-matrix with A the
-        ideal associated to the cusp (A=<a1, a2>) and  first column given by
+        ideal associated to the cusp (A=<a1, a2>) and first column given by
         the coefficients of the cusp.
 
         EXAMPLES:
@@ -1295,7 +1295,7 @@ def units_mod_ideal(I):
         [1]
         sage: I = k.ideal(3)
         sage: units_mod_ideal(I)
-        [1, -a, -1, a]
+        [1, a, -1, -a]
 
     ::
 
diff --git a/src/sage/modular/modform/constructor.py b/src/sage/modular/modform/constructor.py
index d5e5152..5a2f495 100644
--- a/src/sage/modular/modform/constructor.py
+++ b/src/sage/modular/modform/constructor.py
@@ -430,7 +430,7 @@ def Newforms(group, weight=2, base_ring=None, names=None):
     base field that is not minimal for that character::
 
         sage: K.<i> = QuadraticField(-1)
-        sage: chi = DirichletGroup(5, K)[3]
+        sage: chi = DirichletGroup(5, K)[1]
         sage: len(Newforms(chi, 7, names='a'))
         1
         sage: x = polygen(K); L.<c> = K.extension(x^2 - 402*i)
diff --git a/src/sage/quadratic_forms/quadratic_form__automorphisms.py b/src/sage/quadratic_forms/quadratic_form__automorphisms.py
index 680df6e..e48729b 100644
--- a/src/sage/quadratic_forms/quadratic_form__automorphisms.py
+++ b/src/sage/quadratic_forms/quadratic_form__automorphisms.py
@@ -220,18 +220,16 @@ def short_vector_list_up_to_length(self, len_bound, up_to_sign_flag=False):
         ...
         ValueError: Quadratic form must be positive definite in order to enumerate short vectors
 
-    Sometimes, PARI does not compute short vectors correctly.  It returns too long vectors.
-
-    ::
+    Check that PARI doesn't return vectors which are too long::
 
         sage: Q = QuadraticForm(matrix(2, [72, 12, 12, 120]))
         sage: len_bound_pari = 2*22953421 - 2; len_bound_pari
         45906840
         sage: vs = list(Q._pari_().qfminim(len_bound_pari)[2])  # long time (18s on sage.math, 2014)
         sage: v = vs[0]; v  # long time
-        [-65, 623]~
+        [-66, 623]~
         sage: v.Vec() * Q._pari_() * v  # long time
-        45907800
+        45902280
     """
     if not self.is_positive_definite() :
         raise ValueError( "Quadratic form must be positive definite in order to enumerate short vectors" )
@@ -256,11 +254,9 @@ def short_vector_list_up_to_length(self, len_bound, up_to_sign_flag=False):
     # Sort the vectors into lists by their length
     vec_sorted_list = [list() for i in range(len_bound)]
     for i in range(len(parilist)):
-        length = ZZ(parilens[i])
-        # PARI can sometimes return longer vectors than requested.
-        # E.g. : self.matrix() == matrix(2, [72, 12, 12, 120])
-        #        len_bound = 22953421
-        # gives maximal length 22955664
+        length = int(parilens[i])
+        # In certain trivial cases, PARI can sometimes return longer
+        # vectors than requested.
         if length < len_bound:
             v = parilist[i]
             sagevec = V(list(parilist[i]))
diff --git a/src/sage/rings/arith.py b/src/sage/rings/arith.py
index b9efb9f..2755682 100644
--- a/src/sage/rings/arith.py
+++ b/src/sage/rings/arith.py
@@ -2443,7 +2443,7 @@ def factor(n, proof=None, int_=False, algorithm='pari', verbose=0, **kwds):
 
         sage: K.<i> = QuadraticField(-1)
         sage: factor(122 - 454*i)
-        (-1) * (-i - 4) * (-3*i - 2) * (-i - 2)^3 * (i + 1)^3
+        (-3*i - 2) * (-i - 2)^3 * (i + 1)^3 * (i + 4)
 
     To access the data in a factorization::
 
@@ -4530,6 +4530,8 @@ def hilbert_symbol(a, b, p, algorithm="pari"):
     b = QQ(b).numerator() * QQ(b).denominator()
 
     if algorithm == "pari":
+        if p == -1:
+            p = 0
         return ZZ(pari(a).hilbert(b,p))
 
     elif algorithm == 'direct':
@@ -5386,7 +5388,7 @@ def dedekind_sum(p, q, algorithm='default'):
         sage: dedekind_sum(3^54 - 1, 2^93 + 1, algorithm='pari')
         459340694971839990630374299870/29710560942849126597578981379
 
-    Pari uses a different definition if the inputs are not coprime::
+    We check consistency of the results::
 
         sage: dedekind_sum(5, 7, algorithm='default')
         -1/14
@@ -5399,7 +5401,7 @@ def dedekind_sum(p, q, algorithm='default'):
         sage: dedekind_sum(6, 8, algorithm='flint')
         -1/8
         sage: dedekind_sum(6, 8, algorithm='pari')
-        -1/24
+        -1/8
 
     REFERENCES:
 
diff --git a/src/sage/rings/complex_double.pyx b/src/sage/rings/complex_double.pyx
index ebac16f..936044a 100644
--- a/src/sage/rings/complex_double.pyx
+++ b/src/sage/rings/complex_double.pyx
@@ -2061,8 +2061,8 @@ cdef class ComplexDoubleElement(FieldElement):
 
         The optional argument allows us to omit the fractional part::
 
-            sage: z.eta(omit_frac=True)  # abs tol 1e-12
-            0.998129069926 - 8.12769318782e-22*I
+            sage: z.eta(omit_frac=True)
+            0.998129069926
             sage: pi = CDF(pi)
             sage: prod([1-exp(2*pi*i*n*z) for n in range(1,10)])  # abs tol 1e-12
             0.998129069926 + 4.59084695545e-19*I
@@ -2140,7 +2140,7 @@ cdef class ComplexDoubleElement(FieldElement):
             sage: a.agm(b, algorithm='principal')
             0.338175462986 - 0.0135326969565*I
             sage: a.agm(b, algorithm='pari')
-            0.080689185076 + 0.239036532686*I
+            -0.371591652352 + 0.319894660207*I
 
         Some degenerate cases::
 
diff --git a/src/sage/rings/complex_number.pyx b/src/sage/rings/complex_number.pyx
index 0a8ce5c..5fa15c9 100644
--- a/src/sage/rings/complex_number.pyx
+++ b/src/sage/rings/complex_number.pyx
@@ -1508,7 +1508,7 @@ cdef class ComplexNumber(sage.structure.element.FieldElement):
 
             sage: z = 1 + i
             sage: z.eta(omit_frac=True)
-            0.998129069925959 - 8.12769318...e-22*I
+            0.998129069925959
             sage: prod([1-exp(2*pi*i*n*z) for n in range(1,10)])
             0.998129069925958 + 4.59099857829247e-19*I
 
@@ -1721,13 +1721,13 @@ cdef class ComplexNumber(sage.structure.element.FieldElement):
             sage: a.agm(b, algorithm="principal")
             0.338175462986180 - 0.0135326969565405*I
             sage: a.agm(b, algorithm="pari")
-            0.0806891850759812 + 0.239036532685557*I
+            -0.371591652351761 + 0.319894660206830*I
             sage: a.agm(b, algorithm="optimal").abs()
             0.490319232466314
             sage: a.agm(b, algorithm="principal").abs()
             0.338446122230459
             sage: a.agm(b, algorithm="pari").abs()
-            0.252287947683910
+            0.490319232466314
 
         TESTS:
 
@@ -2021,7 +2021,7 @@ cdef class ComplexNumber(sage.structure.element.FieldElement):
 
             sage: C, i = ComplexField(30).objgen()
             sage: (1+i).gamma_inc(2 + 3*i)
-            0.0020969149 - 0.059981914*I
+            0.002096914... - 0.059981914*I
             sage: (1+i).gamma_inc(5)
             -0.0013781309 + 0.0065198200*I
             sage: C(2).gamma_inc(1 + i)
diff --git a/src/sage/rings/fast_arith.pyx b/src/sage/rings/fast_arith.pyx
index 3a0e304..a224775 100644
--- a/src/sage/rings/fast_arith.pyx
+++ b/src/sage/rings/fast_arith.pyx
@@ -46,7 +46,7 @@ include "sage/ext/stdsage.pxi"
 include "sage/libs/pari/decl.pxi"
 
 cdef extern from "pari/pari.h":
-    cdef long NEXT_PRIME_VIADIFF(long, unsigned char*)
+    cdef long NEXT_PRIME_VIADIFF(long, byteptr)
 
 from sage.rings.integer_ring import ZZ
 from sage.libs.pari.gen cimport gen as pari_gen
@@ -84,7 +84,8 @@ cpdef prime_range(start, stop=None, algorithm="pari_primes", bint py_ints=False)
         - ``py_ints`` -- boolean (default False), return Python ints rather than Sage Integers (faster)
 
 
-    EXAMPLES:
+    EXAMPLES::
+
         sage: prime_range(10)
         [2, 3, 5, 7]
         sage: prime_range(7)
@@ -110,21 +111,31 @@ cpdef prime_range(start, stop=None, algorithm="pari_primes", bint py_ints=False)
         sage: type(prime_range(8,algorithm="pari_isprime")[0])
         <type 'sage.rings.integer.Integer'>
 
-    TESTS:
-        sage: len(prime_range(25000,2500000))
+    TESTS::
+
+        sage: prime_range(-1)
+        []
+        sage: L = prime_range(25000,2500000)
+        sage: len(L)
         180310
-        sage: prime_range(2500000)[-1].is_prime()
-        True
+        sage: L[-10:]
+        [2499923, 2499941, 2499943, 2499947, 2499949, 2499953, 2499967, 2499983, 2499989, 2499997]
+
+    A non-trivial range without primes::
+    
+        sage: prime_range(4652360, 4652400)
+        []
 
     AUTHORS:
-      - William Stein (original version)
-      - Craig Citro (rewrote for massive speedup)
-      - Kevin Stueve (added primes iterator option) 2010-10-16
-      - Robert Bradshaw (speedup using Pari prime table, py_ints option)
+
+    - William Stein (original version)
+    - Craig Citro (rewrote for massive speedup)
+    - Kevin Stueve (added primes iterator option) 2010-10-16
+    - Robert Bradshaw (speedup using Pari prime table, py_ints option)
     """
     cdef Integer z
-    cdef long c_start, c_stop, p
-    cdef unsigned char* pari_prime_ptr
+    cdef long c_start, c_stop, p, maxpr
+    cdef byteptr pari_prime_ptr
     if algorithm == "pari_primes":
         if stop is None:
             # In this case, "start" is really stop
@@ -133,13 +144,18 @@ cpdef prime_range(start, stop=None, algorithm="pari_primes", bint py_ints=False)
         else:
             c_start = start
             c_stop = stop
-            if c_stop <= c_start:
-                return []
             if c_start < 1:
                 c_start = 1
+        if c_stop <= c_start:
+            return []
+
         if maxprime() < c_stop:
-            pari.init_primes(c_stop)
-        pari_prime_ptr = <unsigned char*>diffptr
+            # Adding 1500 should be sufficient to guarantee an
+            # additional prime, given that c_stop < 2^63.
+            pari.init_primes(c_stop + 1500)
+            assert maxprime() >= c_stop
+
+        pari_prime_ptr = diffptr
         p = 0
         res = []
         while p < c_start:
diff --git a/src/sage/rings/finite_rings/element_ext_pari.py b/src/sage/rings/finite_rings/element_ext_pari.py
index 074c2c4..cb76e70 100644
--- a/src/sage/rings/finite_rings/element_ext_pari.py
+++ b/src/sage/rings/finite_rings/element_ext_pari.py
@@ -284,20 +284,20 @@ class FiniteField_ext_pariElement(FinitePolyExtElement):
                 if not value:
                     value = [0]
                 try:
-                    # First, try the conversion directly in PARI.  This
-                    # should cover the most common cases, like converting
-                    # from integers or intmods.
                     # Convert the list to PARI, then mod out the
-                    # characteristic (PARI can do this directly for lists),
-                    # convert to a polynomial with variable "a" and finally
-                    # mod out the field modulus.
-                    self.__value = pari(value).Mod(parent.characteristic()).Polrev("a").Mod(parent._pari_modulus())
+                    # characteristic (PARI can do this directly for lists).
+                    # If we get only INTMODs, we can do the conversion
+                    # directly.
+                    parilist = pari(value).Mod(parent.characteristic())
+                    if not all(c.type() == "t_INTMOD" for c in parilist):
+                        raise RuntimeError
                 except RuntimeError:
                     # That didn't work, do it in a more general but also
                     # slower way: first convert all list elements to the
                     # prime field.
                     GFp = parent.prime_subfield()
-                    self.__value = pari([GFp(c) for c in value]).Polrev("a").Mod(parent._pari_modulus())
+                    parilist = pari([GFp(c) for c in value])
+                self.__value = parilist.Polrev("a").Mod(parent._pari_modulus())
             elif isinstance(value, str):
                 raise TypeError("value must not be a string")
             else:
diff --git a/src/sage/rings/finite_rings/finite_field_prime_modn.py b/src/sage/rings/finite_rings/finite_field_prime_modn.py
index a3b3044..b66b1e3 100644
--- a/src/sage/rings/finite_rings/finite_field_prime_modn.py
+++ b/src/sage/rings/finite_rings/finite_field_prime_modn.py
@@ -168,7 +168,7 @@ class FiniteField_prime_modn(FiniteField_generic, integer_mod_ring.IntegerModRin
             sage: RF13 = K.residue_field(pp)
             sage: RF13.hom([GF(13)(1)])
             Ring morphism:
-             From: Residue field of Fractional ideal (w - 18)
+             From: Residue field of Fractional ideal (-w + 18)
              To:   Finite Field of size 13
              Defn: 1 |--> 1
         """
diff --git a/src/sage/rings/integer.pyx b/src/sage/rings/integer.pyx
index 943036d..34b5f2c 100644
--- a/src/sage/rings/integer.pyx
+++ b/src/sage/rings/integer.pyx
@@ -4746,8 +4746,7 @@ cdef class Integer(sage.structure.element.EuclideanDomainElement):
             sage: 3._bnfisnorm(QuadraticField(-1, 'i'))
             (1, 3)
             sage: 7._bnfisnorm(CyclotomicField(7))
-            (-zeta7 + 1, 1)            # 64-bit
-            (-zeta7^5 + zeta7^4, 1)    # 32-bit
+            (zeta7^5 - zeta7, 1)
         """
         from sage.rings.rational_field import QQ
         return QQ(self)._bnfisnorm(K, proof=proof, extra_primes=extra_primes)
diff --git a/src/sage/rings/number_field/class_group.py b/src/sage/rings/number_field/class_group.py
index a69a3ad..210a28c 100644
--- a/src/sage/rings/number_field/class_group.py
+++ b/src/sage/rings/number_field/class_group.py
@@ -223,7 +223,7 @@ class FractionalIdealClass(AbelianGroupWithValuesElement):
             sage: k.<a> = NumberField(x^2 + 20072); G = k.class_group(); G
             Class group of order 76 with structure C38 x C2
             of Number Field in a with defining polynomial x^2 + 20072
-            sage: I = (G.0)^35; I
+            sage: I = (G.0)^11; I
             Fractional ideal class (41, 1/2*a + 5)
             sage: J = G(I.ideal()^5); J
             Fractional ideal class (115856201, 1/2*a + 40407883)
@@ -471,7 +471,7 @@ class ClassGroup(AbelianGroupWithValues_class):
             Class group of order 68 with structure C34 x C2 of Number Field
             in a with defining polynomial x^2 + x + 23899
             sage: C.gens()
-            (Fractional ideal class (23, a + 14), Fractional ideal class (5, a + 3))
+            (Fractional ideal class (7, a + 5), Fractional ideal class (5, a + 3))
             sage: C.ngens()
             2
         """
diff --git a/src/sage/rings/number_field/galois_group.py b/src/sage/rings/number_field/galois_group.py
index fbb4ab0..0189900 100644
--- a/src/sage/rings/number_field/galois_group.py
+++ b/src/sage/rings/number_field/galois_group.py
@@ -404,10 +404,12 @@ class GaloisGroup_v2(PermutationGroup_generic):
 
         EXAMPLE::
 
-            sage: L = CyclotomicField(7)
+            sage: L.<z> = CyclotomicField(7)
             sage: G = L.galois_group()
-            sage: G.complex_conjugation()
-            (1,6)(2,3)(4,5)
+            sage: conj = G.complex_conjugation(); conj
+            (1,4)(2,5)(3,6)
+            sage: conj(z)
+            -z^5 - z^4 - z^3 - z^2 - z - 1
 
         An example where the field is not CM, so complex conjugation really
         depends on the choice of embedding::
diff --git a/src/sage/rings/number_field/maps.py b/src/sage/rings/number_field/maps.py
index 1f59062..d262818 100644
--- a/src/sage/rings/number_field/maps.py
+++ b/src/sage/rings/number_field/maps.py
@@ -302,12 +302,12 @@ class MapRelativeVectorSpaceToRelativeNumberField(NumberFieldIsomorphism):
         # Apply to_B, so now each coefficient is in an absolute field,
         # and is expressed in terms of a polynomial in y, then make
         # the PARI poly in x.
-        w = [pari(to_B(a).polynomial('y')) for a in w]
+        w = [to_B(a)._pari_('y') for a in w]
         h = pari(w).Polrev()
 
         # Next we write the poly in x over a poly in y in terms
         # of an absolute polynomial for the rnf.
-        g = self.__R(self.__rnf.rnfeltreltoabs(h))
+        g = self.__rnf.rnfeltreltoabs(h)
         return self.__K._element_class(self.__K, g)
 
 class MapRelativeNumberFieldToRelativeVectorSpace(NumberFieldIsomorphism):
diff --git a/src/sage/rings/number_field/number_field.py b/src/sage/rings/number_field/number_field.py
index 08624f0..86cba05 100644
--- a/src/sage/rings/number_field/number_field.py
+++ b/src/sage/rings/number_field/number_field.py
@@ -2632,9 +2632,9 @@ class NumberField_generic(number_field_base.NumberField):
             sage: K.<a> = NumberField(x^2 + 23)
             sage: d = K.ideals_of_bdd_norm(10)
             sage: for n in d:
-            ...       print n
-            ...       for I in d[n]:
-            ...           print I
+            ....:     print n
+            ....:     for I in d[n]:
+            ....:         print I
             1
             Fractional ideal (1)
             2
@@ -2649,13 +2649,13 @@ class NumberField_generic(number_field_base.NumberField):
             Fractional ideal (4, 1/2*a + 5/2)
             5
             6
-            Fractional ideal (-1/2*a + 1/2)
+            Fractional ideal (1/2*a - 1/2)
             Fractional ideal (6, 1/2*a + 5/2)
             Fractional ideal (6, 1/2*a + 7/2)
             Fractional ideal (1/2*a + 1/2)
             7
             8
-            Fractional ideal (-1/2*a - 3/2)
+            Fractional ideal (1/2*a + 3/2)
             Fractional ideal (4, a - 1)
             Fractional ideal (4, a + 1)
             Fractional ideal (1/2*a - 3/2)
@@ -3101,7 +3101,9 @@ class NumberField_generic(number_field_base.NumberField):
             return self.__pari_nf
         except AttributeError:
             f = self.pari_polynomial("y")
-            self.__pari_nf = pari([f, self._pari_integral_basis(important=important)]).nfinit()
+            if f.poldegree() > 1:
+                f = pari([f, self._pari_integral_basis(important=important)])
+            self.__pari_nf = f.nfinit()
             return self.__pari_nf
 
     def pari_zk(self):
@@ -3184,7 +3186,7 @@ class NumberField_generic(number_field_base.NumberField):
             sage: len(k.pari_bnf())
             10
             sage: k.pari_bnf()[:4]
-            [[;], matrix(0,7), [;], ...]
+            [[;], matrix(0,3), [;], ...]
             sage: len(k.pari_nf())
             9
             sage: k.<a> = NumberField(x^7 + 7); k
@@ -3545,8 +3547,8 @@ class NumberField_generic(number_field_base.NumberField):
               14/13*a^2 + 267/13*a - 85/13,
               7/13*a^2 + 127/13*a - 49/13,
               -1,
-              1/13*a^2 + 20/13*a - 7/13,
-              1/13*a^2 - 19/13*a + 6/13],
+              1/13*a^2 - 19/13*a + 6/13,
+              1/13*a^2 - 19/13*a - 7/13],
              [(Fractional ideal (11, a - 2), 2),
               (Fractional ideal (19, 1/13*a^2 - 45/13*a - 332/13), 2)])
         """
@@ -3645,7 +3647,7 @@ class NumberField_generic(number_field_base.NumberField):
 
             sage: K.<a> = NumberField(x^3 - 381 * x + 127)
             sage: K.selmer_group(K.primes_above(13), 2)
-            [-7/13*a^2 - 140/13*a + 36/13, 14/13*a^2 + 267/13*a - 85/13, 7/13*a^2 + 127/13*a - 49/13, -1, 1/13*a^2 + 20/13*a - 7/13, 1/13*a^2 - 19/13*a + 6/13, -2/13*a^2 - 53/13*a + 92/13, 10/13*a^2 + 44/13*a - 4555/13]
+            [-7/13*a^2 - 140/13*a + 36/13, 14/13*a^2 + 267/13*a - 85/13, 7/13*a^2 + 127/13*a - 49/13, -1, 1/13*a^2 - 19/13*a + 6/13, 1/13*a^2 - 19/13*a - 7/13, 2/13*a^2 + 53/13*a - 92/13, 10/13*a^2 + 44/13*a - 4555/13]
         """
         units, clgp_gens = self._S_class_group_and_units(tuple(S), proof=proof)
         gens = []
@@ -4197,19 +4199,19 @@ class NumberField_generic(number_field_base.NumberField):
         Here are the factors::
 
             sage: fi, fj = K.factor(17); fi,fj
-            ((Fractional ideal (4*I + 1), 1), (Fractional ideal (-I - 4), 1))
+            ((Fractional ideal (I - 4), 1), (Fractional ideal (I + 4), 1))
 
         Now we extract the reduced form of the generators::
 
             sage: zi = fi[0].gens_reduced()[0]; zi
-            4*I + 1
+            I - 4
             sage: zj = fj[0].gens_reduced()[0]; zj
-            -I - 4
+            I + 4
 
         We recover the integer that was factored in `\ZZ[i]` (up to a unit)::
 
             sage: zi*zj
-            -17*I
+            -17
 
         One can also factor elements or ideals of the number field::
 
@@ -4219,15 +4221,14 @@ class NumberField_generic(number_field_base.NumberField):
             sage: K.factor(1+a)
             Fractional ideal (a + 1)
             sage: K.factor(1+a/5)
-            (Fractional ideal (-3*a - 2)) * (Fractional ideal (a + 1)) * (Fractional ideal (-a - 2))^-1 * (Fractional ideal (a - 2))^-1
+            (Fractional ideal (-3*a - 2)) * (Fractional ideal (a + 1)) * (Fractional ideal (-a - 2))^-1 * (Fractional ideal (2*a + 1))^-1
 
         An example over a relative number field::
 
             sage: pari('setrand(2)')
             sage: L.<b> = K.extension(x^2 - 7)
             sage: f = L.factor(a + 1); f
-            (Fractional ideal (-1/2*a*b - a - 1/2)) * (Fractional ideal (1/2*b + 1/2*a - 1)) # 32-bit
-            (Fractional ideal (1/2*a*b + a + 1/2)) * (Fractional ideal (-1/2*b - 1/2*a + 1)) # 64-bit
+            (Fractional ideal (1/2*a*b - a + 1/2)) * (Fractional ideal (-1/2*a*b - a + 1/2))
             sage: f.value() == a+1
             True
 
@@ -4553,8 +4554,7 @@ class NumberField_generic(number_field_base.NumberField):
         except (AttributeError, KeyError):
             f = self.pari_polynomial("y")
             if len(v) > 0:
-                m = self._pari_disc_factorization_matrix(v)
-                B = f.nfbasis(fa = m)
+                B = f.nfbasis(fa=v)
             elif self._assume_disc_small:
                 B = f.nfbasis(1)
             elif not important:
@@ -4575,34 +4575,6 @@ class NumberField_generic(number_field_base.NumberField):
             self._integral_basis_dict[v] = B
             return B
 
-    def _pari_disc_factorization_matrix(self, v):
-        """
-        Returns a PARI matrix representation for the partial
-        factorization of the discriminant of the defining polynomial
-        of self, defined by the list of primes in the Python list v.
-        This function is used internally by the number fields code.
-
-        EXAMPLES::
-
-            sage: x = polygen(QQ,'x')
-            sage: f = x^3 + 17*x + 393; f.discriminant().factor()
-            -1 * 5^2 * 29 * 5779
-            sage: K.<a> = NumberField(f)
-            sage: fa = K._pari_disc_factorization_matrix([5,29]); fa
-            [5, 2; 29, 1]
-            sage: fa.type()
-            't_MAT'
-        """
-        f = self.pari_polynomial()
-        m = pari.matrix(len(v), 2)
-        d = f.poldisc()
-        for i in range(len(v)):
-            p = pari(ZZ(v[i]))
-            m[i,0] = p
-            m[i,1] = d.valuation(p)
-        return m
-
-
     def reduced_basis(self, prec=None):
         r"""
         This function returns an LLL-reduced basis for the
@@ -5299,7 +5271,14 @@ class NumberField_generic(number_field_base.NumberField):
             sage: K.units(proof=True)  # takes forever, not tested
             ...
             sage: K.units(proof=False)  # result not independently verified
-            (a^9 + a - 1, a^16 - a^15 + a^14 - a^12 + a^11 - a^10 - a^8 + a^7 - 2*a^6 + a^4 - 3*a^3 + 2*a^2 - 2*a + 1, 2*a^16 - a^14 - a^13 + 3*a^12 - 2*a^10 + a^9 + 3*a^8 - 3*a^6 + 3*a^5 + 3*a^4 - 2*a^3 - 2*a^2 + 3*a + 4, a^15 + a^14 + 2*a^11 + a^10 - a^9 + a^8 + 2*a^7 - a^5 + 2*a^3 - a^2 - 3*a + 1, a^16 + a^15 + a^14 + a^13 + a^12 + a^11 + a^10 + a^9 + a^8 + a^7 + a^6 + a^5 + a^4 + a^3 + a^2 - 2, 2*a^16 - 3*a^15 + 3*a^14 - 3*a^13 + 3*a^12 - a^11 + a^9 - 3*a^8 + 4*a^7 - 5*a^6 + 6*a^5 - 4*a^4 + 3*a^3 - 2*a^2 - 2*a + 4, a^15 - a^12 + a^10 - a^9 - 2*a^8 + 3*a^7 + a^6 - 3*a^5 + a^4 + 4*a^3 - 3*a^2 - 2*a + 2, 2*a^16 + a^15 - a^11 - 3*a^10 - 4*a^9 - 4*a^8 - 4*a^7 - 5*a^6 - 7*a^5 - 8*a^4 - 6*a^3 - 5*a^2 - 6*a - 7)
+            (a^9 + a - 1,
+             a^15 - a^12 + a^10 - a^9 - 2*a^8 + 3*a^7 + a^6 - 3*a^5 + a^4 + 4*a^3 - 3*a^2 - 2*a + 2,
+             a^16 - a^15 + a^14 - a^12 + a^11 - a^10 - a^8 + a^7 - 2*a^6 + a^4 - 3*a^3 + 2*a^2 - 2*a + 1,
+             2*a^16 - a^14 - a^13 + 3*a^12 - 2*a^10 + a^9 + 3*a^8 - 3*a^6 + 3*a^5 + 3*a^4 - 2*a^3 - 2*a^2 + 3*a + 4,
+             2*a^16 - 3*a^15 + 3*a^14 - 3*a^13 + 3*a^12 - a^11 + a^9 - 3*a^8 + 4*a^7 - 5*a^6 + 6*a^5 - 4*a^4 + 3*a^3 - 2*a^2 - 2*a + 4,
+             a^16 - a^15 - 3*a^14 - 4*a^13 - 4*a^12 - 3*a^11 - a^10 + 2*a^9 + 4*a^8 + 5*a^7 + 4*a^6 + 2*a^5 - 2*a^4 - 6*a^3 - 9*a^2 - 9*a - 7,
+             a^15 + a^14 + 2*a^11 + a^10 - a^9 + a^8 + 2*a^7 - a^5 + 2*a^3 - a^2 - 3*a + 1,
+             5*a^16 - 6*a^14 + a^13 + 7*a^12 - 2*a^11 - 7*a^10 + 4*a^9 + 7*a^8 - 6*a^7 - 7*a^6 + 8*a^5 + 6*a^4 - 11*a^3 - 5*a^2 + 13*a + 4)
         """
         proof = proof_flag(proof)
 
@@ -5371,7 +5350,7 @@ class NumberField_generic(number_field_base.NumberField):
             sage: U.gens()
             (u0, u1, u2, u3, u4, u5, u6, u7, u8)
             sage: U.gens_values()  # result not independently verified
-            [-1, a^9 + a - 1, a^16 - a^15 + a^14 - a^12 + a^11 - a^10 - a^8 + a^7 - 2*a^6 + a^4 - 3*a^3 + 2*a^2 - 2*a + 1, 2*a^16 - a^14 - a^13 + 3*a^12 - 2*a^10 + a^9 + 3*a^8 - 3*a^6 + 3*a^5 + 3*a^4 - 2*a^3 - 2*a^2 + 3*a + 4, a^15 + a^14 + 2*a^11 + a^10 - a^9 + a^8 + 2*a^7 - a^5 + 2*a^3 - a^2 - 3*a + 1, a^16 + a^15 + a^14 + a^13 + a^12 + a^11 + a^10 + a^9 + a^8 + a^7 + a^6 + a^5 + a^4 + a^3 + a^2 - 2, 2*a^16 - 3*a^15 + 3*a^14 - 3*a^13 + 3*a^12 - a^11 + a^9 - 3*a^8 + 4*a^7 - 5*a^6 + 6*a^5 - 4*a^4 + 3*a^3 - 2*a^2 - 2*a + 4, a^15 - a^12 + a^10 - a^9 - 2*a^8 + 3*a^7 + a^6 - 3*a^5 + a^4 + 4*a^3 - 3*a^2 - 2*a + 2, 2*a^16 + a^15 - a^11 - 3*a^10 - 4*a^9 - 4*a^8 - 4*a^7 - 5*a^6 - 7*a^5 - 8*a^4 - 6*a^3 - 5*a^2 - 6*a - 7]
+            [-1, a^9 + a - 1, a^15 - a^12 + a^10 - a^9 - 2*a^8 + 3*a^7 + a^6 - 3*a^5 + a^4 + 4*a^3 - 3*a^2 - 2*a + 2, a^16 - a^15 + a^14 - a^12 + a^11 - a^10 - a^8 + a^7 - 2*a^6 + a^4 - 3*a^3 + 2*a^2 - 2*a + 1, 2*a^16 - a^14 - a^13 + 3*a^12 - 2*a^10 + a^9 + 3*a^8 - 3*a^6 + 3*a^5 + 3*a^4 - 2*a^3 - 2*a^2 + 3*a + 4, 2*a^16 - 3*a^15 + 3*a^14 - 3*a^13 + 3*a^12 - a^11 + a^9 - 3*a^8 + 4*a^7 - 5*a^6 + 6*a^5 - 4*a^4 + 3*a^3 - 2*a^2 - 2*a + 4, a^16 - a^15 - 3*a^14 - 4*a^13 - 4*a^12 - 3*a^11 - a^10 + 2*a^9 + 4*a^8 + 5*a^7 + 4*a^6 + 2*a^5 - 2*a^4 - 6*a^3 - 9*a^2 - 9*a - 7, a^15 + a^14 + 2*a^11 + a^10 - a^9 + a^8 + 2*a^7 - a^5 + 2*a^3 - a^2 - 3*a + 1, 5*a^16 - 6*a^14 + a^13 + 7*a^12 - 2*a^11 - 7*a^10 + 4*a^9 + 7*a^8 - 6*a^7 - 7*a^6 + 8*a^5 + 6*a^4 - 11*a^3 - 5*a^2 + 13*a + 4]
         """
         proof = proof_flag(proof)
 
@@ -5421,8 +5400,7 @@ class NumberField_generic(number_field_base.NumberField):
             sage: U.gens()
             (u0, u1, u2, u3)
             sage: U.gens_values()
-            [-7/275*a^3 + 1/11*a^2 - 9/11*a - 1, 6/275*a^3 - 9/55*a^2 + 14/11*a - 2, 14/275*a^3 - 21/55*a^2 + 29/11*a - 6, 1/275*a^3 + 4/55*a^2 - 5/11*a + 5]  # 32-bit
-            [-7/275*a^3 + 1/11*a^2 - 9/11*a - 1, 6/275*a^3 - 9/55*a^2 + 14/11*a - 2, -14/275*a^3 + 21/55*a^2 - 29/11*a + 6, 1/275*a^3 + 4/55*a^2 - 5/11*a + 5]  # 64-bit
+            [-7/275*a^3 + 1/11*a^2 - 9/11*a - 1, 6/275*a^3 - 9/55*a^2 + 14/11*a - 2, -14/275*a^3 + 21/55*a^2 - 29/11*a + 6, 1/275*a^3 + 4/55*a^2 - 5/11*a + 5]
             sage: U.invariants()
             (10, 0, 0, 0)
             sage: [u.multiplicative_order() for u in U.gens()]
@@ -5566,9 +5544,9 @@ class NumberField_generic(number_field_base.NumberField):
             sage: r.<x> = QQ[]
             sage: K.<b> = NumberField(x^2+1)
             sage: K.zeta(4)
-            -b
+            b
             sage: K.zeta(4,all=True)
-            [-b, b]
+            [b, -b]
             sage: K.zeta(3)
             Traceback (most recent call last):
             ...
@@ -5666,7 +5644,7 @@ class NumberField_generic(number_field_base.NumberField):
 
             sage: K.<i> = NumberField(x^2+1)
             sage: z = K.primitive_root_of_unity(); z
-            -i
+            i
             sage: z.multiplicative_order()
             4
 
@@ -5692,11 +5670,11 @@ class NumberField_generic(number_field_base.NumberField):
             sage: z.multiplicative_order()
             6
 
-            sage: K = CyclotomicField(7)
+            sage: K = CyclotomicField(3)
             sage: z = K.primitive_root_of_unity(); z
-            zeta7^5 + zeta7^4 + zeta7^3 + zeta7^2 + zeta7 + 1
+            zeta3 + 1
             sage: z.multiplicative_order()
-            14
+            6
 
         TESTS:
 
@@ -5730,7 +5708,7 @@ class NumberField_generic(number_field_base.NumberField):
 
             sage: K.<b> = NumberField(x^2+1)
             sage: zs = K.roots_of_unity(); zs
-            [-b, -1, b, 1]
+            [b, -1, -b, 1]
             sage: [ z**K.number_of_roots_of_unity() for z in zs ]
             [1, 1, 1, 1]
         """
@@ -7795,8 +7773,7 @@ class NumberField_absolute(NumberField_generic):
             sage: K.hilbert_conductor(K(2),K(-2))
             Fractional ideal (1)
             sage: K.hilbert_conductor(K(2*b),K(-2))
-            Fractional ideal (-b^2 - b + 2)
-
+            Fractional ideal (b^2 + b - 2)
 
         AUTHOR:
 
diff --git a/src/sage/rings/number_field/number_field_element.pyx b/src/sage/rings/number_field/number_field_element.pyx
index 91c4d1b..a8dcbeb 100644
--- a/src/sage/rings/number_field/number_field_element.pyx
+++ b/src/sage/rings/number_field/number_field_element.pyx
@@ -329,9 +329,11 @@ cdef class NumberFieldElement(FieldElement):
                     fmod = f.mod()
                     for i from 0 <= i <= fmod.poldegree():
                         if fmod.polcoeff(i).type() in ["t_POL", "t_POLMOD"]:
-                            # Convert relative element to absolute
-                            # This returns a polynomial, not a polmod
-                            f = parent.pari_rnf().rnfeltreltoabs(f)
+                            # Convert relative element to absolute.
+                            # Sometimes the result is a polynomial,
+                            # sometimed a polmod. Lift to convert to a
+                            # polynomial in all cases.
+                            f = parent.pari_rnf().rnfeltreltoabs(f).lift()
                             break
                 # Check that the modulus is actually the defining polynomial
                 # of the number field.
@@ -1188,7 +1190,7 @@ cdef class NumberFieldElement(FieldElement):
             sage: Q.<X> = K[]
             sage: L.<b> = NumberField(X^4 + a)
             sage: t = (-a).is_norm(L, element=True); t
-            (True, -b^3 + 1)
+            (True, b^3 + 1)
             sage: t[1].norm(K)
             -a
 
@@ -1289,11 +1291,11 @@ cdef class NumberFieldElement(FieldElement):
             sage: Q.<X> = K[]
             sage: L.<b> = NumberField(X^4 + a)
             sage: t = (-a)._rnfisnorm(L); t
-            (-b^3 + 1, 1)
+            (b^3 + 1, 1)
             sage: t[0].norm(K)
             -a
             sage: t = K(3)._rnfisnorm(L); t
-            ((a^2 + 1)*b^3 + b^2 - a*b + a^2 + 1, -3*a)
+            ((a^2 + 1)*b^3 - b^2 - a*b - a^2, -3*a^2 + 3*a - 3)
             sage: t[0].norm(K)*t[1]
             3
 
@@ -1323,6 +1325,9 @@ cdef class NumberFieldElement(FieldElement):
 
         rnf_data = K.pari_rnfnorm_data(L, proof=proof)
         x, q = self._pari_().rnfisnorm(rnf_data)
+
+        # Convert x to an absolute element
+        x = L.pari_rnf().rnfeltreltoabs(x)
         return L(x), K(q)
 
     def _mpfr_(self, R):
@@ -1339,7 +1344,7 @@ cdef class NumberFieldElement(FieldElement):
             sage: (a^2)._mpfr_(RR)
             -1.00000000000000
 
-        Verify that :trac:`#13005` has been fixed::
+        Verify that :trac:`13005` has been fixed::
 
             sage: K.<a> = NumberField(x^2-5)
             sage: RR(K(1))
@@ -3813,12 +3818,12 @@ cdef class NumberFieldElement_relative(NumberFieldElement):
             sage: K.<a> = NumberField(y^2 + y + 1)
             sage: x = polygen(K)
             sage: L.<b> = NumberField(x^4 + a*x + 2)
-            sage: e = pari(a*b); e
-            Mod(-y^4 - 2, y^8 - y^5 + 4*y^4 + y^2 - 2*y + 4)
+            sage: e = (a*b)._pari_('x'); e
+            Mod(-x^4 - 2, x^8 - x^5 + 4*x^4 + x^2 - 2*x + 4)
             sage: L(e)  # Conversion from PARI absolute number field element
             a*b
             sage: e = L.pari_rnf().rnfeltabstorel(e); e
-            Mod(Mod(y, y^2 + y + 1)*x, x^4 + y*x + 2)
+            Mod(Mod(y, y^2 + y + 1)*x, x^4 + Mod(y, y^2 + y + 1)*x + 2)
             sage: L(e)  # Conversion from PARI relative number field element
             a*b
             sage: e = pari('Mod(0, x^8 + 1)'); L(e)  # Wrong modulus
@@ -3832,10 +3837,12 @@ cdef class NumberFieldElement_relative(NumberFieldElement):
             sage: L(e)
             a*b^2 + 1
 
-        Currently, conversions of PARI relative number fields are not checked::
+        This wrong modulus yields a PARI error::
 
-            sage: e = pari('Mod(y*x, x^4 + y^2*x + 2)'); L(e)  # Wrong modulus, but succeeds anyway
-            a*b
+            sage: e = pari('Mod(y*x, x^4 + y^2*x + 2)'); L(e)
+            Traceback (most recent call last):
+            ...
+            PariError: inconsistent moduli in rnfeltreltoabs: x^4 + y^2*x + 2 != y^2 + y + 1
         """
         NumberFieldElement.__init__(self, parent, f)
 
diff --git a/src/sage/rings/number_field/number_field_ideal.py b/src/sage/rings/number_field/number_field_ideal.py
index 51dadd8..2092543 100644
--- a/src/sage/rings/number_field/number_field_ideal.py
+++ b/src/sage/rings/number_field/number_field_ideal.py
@@ -83,14 +83,17 @@ def convert_from_idealprimedec_form(field, ideal):
         sage: K_bnf = gp(K.pari_bnf())
         sage: ideal = K_bnf.idealprimedec(3)[1]
         sage: convert_from_idealprimedec_form(K, ideal)
+        doctest:...: DeprecationWarning: convert_from_idealprimedec_form() is deprecated
+        See http://trac.sagemath.org/15767 for details.
         Fractional ideal (-a)
         sage: K.factor(3)
         (Fractional ideal (-a))^2
-
     """
-    # This indexation is very ugly and should be dealt with in #10002
+    from sage.misc.superseded import deprecation
+    deprecation(15767, "convert_from_idealprimedec_form() is deprecated")
+
     p = ZZ(ideal[1])
-    alpha = field(field.pari_nf().getattr('zk') * ideal[2])
+    alpha = field(field.pari_zk() * ideal[2])
     return field.ideal(p, alpha)
 
 def convert_to_idealprimedec_form(field, ideal):
@@ -116,16 +119,13 @@ def convert_to_idealprimedec_form(field, ideal):
         sage: K.<a> = NumberField(x^2 + 3)
         sage: P = K.ideal(a/2-3/2)
         sage: convert_to_idealprimedec_form(K, P)
-        [3, [1, 2]~, 2, 1, [1, -1]~]
-
+        doctest:...: DeprecationWarning: convert_to_idealprimedec_form() is deprecated, use ideal.pari_prime() instead
+        See http://trac.sagemath.org/15767 for details.
+        [3, [1, 2]~, 2, 1, [1, 1; -1, 2]]
     """
-    p = ideal.residue_field().characteristic()
-    from sage.interfaces.gp import gp
-    K_bnf = gp(field.pari_bnf())
-    for primedecform in K_bnf.idealprimedec(p):
-        if convert_from_idealprimedec_form(field, primedecform) == ideal:
-            return primedecform
-    raise RuntimeError
+    from sage.misc.superseded import deprecation
+    deprecation(15767, "convert_to_idealprimedec_form() is deprecated, use ideal.pari_prime() instead")
+    return field.ideal(ideal).pari_prime()
 
 class NumberFieldIdeal(Ideal_generic):
     """
@@ -157,7 +157,7 @@ class NumberFieldIdeal(Ideal_generic):
             Fractional ideal (3)
             sage: F = pari(K).idealprimedec(5)
             sage: K.ideal(F[0])
-            Fractional ideal (i - 2)
+            Fractional ideal (2*i + 1)
 
         TESTS:
 
@@ -165,7 +165,7 @@ class NumberFieldIdeal(Ideal_generic):
         prime ideal::
 
             sage: K.ideal(pari(K).idealprimedec(5)[0])._pari_prime
-            [5, [-2, 1]~, 1, 1, [2, 1]~]
+            [5, [-2, 1]~, 1, 1, [2, -1; 1, 2]]
         """
         if not isinstance(field, number_field.NumberField_generic):
             raise TypeError("field (=%s) must be a number field."%field)
@@ -195,8 +195,8 @@ class NumberFieldIdeal(Ideal_generic):
         EXAMPLES::
 
             sage: NumberField(x^2 + 1, 'a').ideal(7).__hash__()
-            -9223372036854775779                # 64-bit
-            -2147483619                         # 32-bit
+            848642427            # 32-bit
+            3643975048496365947  # 64-bit
         """
         try:
             return self._hash
@@ -313,7 +313,7 @@ class NumberFieldIdeal(Ideal_generic):
             sage: A = K.ideal([5, 2 + I])
             sage: B = K.ideal([13, 5 + 12*I])
             sage: A*B
-            Fractional ideal (-4*I + 7)
+            Fractional ideal (4*I - 7)
             sage: (K.ideal(3 + I) * K.ideal(7 + I)).gens()
             (10*I + 20,)
 
@@ -1060,7 +1060,7 @@ class NumberFieldIdeal(Ideal_generic):
             sage: K.ideal(3).pari_prime()
             [3, [3, 0]~, 1, 2, 1]
             sage: K.ideal(2+i).pari_prime()
-            [5, [2, 1]~, 1, 1, [-2, 1]~]
+            [5, [2, 1]~, 1, 1, [-2, -1; 1, -2]]
             sage: K.ideal(2).pari_prime()
             Traceback (most recent call last):
             ...
@@ -2238,7 +2238,7 @@ class NumberFieldFractionalIdeal(NumberFieldIdeal):
             sage: I = K.ideal((3+4*i)/5); I
             Fractional ideal (4/5*i + 3/5)
             sage: I.denominator()
-            Fractional ideal (i - 2)
+            Fractional ideal (2*i + 1)
             sage: I.numerator()
             Fractional ideal (-i - 2)
             sage: I.numerator().is_integral() and I.denominator().is_integral()
@@ -2268,7 +2268,7 @@ class NumberFieldFractionalIdeal(NumberFieldIdeal):
             sage: I = K.ideal((3+4*i)/5); I
             Fractional ideal (4/5*i + 3/5)
             sage: I.denominator()
-            Fractional ideal (i - 2)
+            Fractional ideal (2*i + 1)
             sage: I.numerator()
             Fractional ideal (-i - 2)
             sage: I.numerator().is_integral() and I.denominator().is_integral()
@@ -2999,15 +2999,15 @@ class NumberFieldFractionalIdeal(NumberFieldIdeal):
         An example of reduction maps to the residue field: these are
         defined on the whole valuation ring, i.e. the subring of the
         number field consisting of elements with non-negative
-        valuation.  This shows that the issue raised in trac \#1951
+        valuation.  This shows that the issue raised in :trac:`1951`
         has been fixed::
 
             sage: K.<i> = NumberField(x^2 + 1)
             sage: P1, P2 = [g[0] for g in K.factor(5)]; (P1,P2)
-            (Fractional ideal (-i - 2), Fractional ideal (i - 2))
+            (Fractional ideal (-i - 2), Fractional ideal (2*i + 1))
             sage: a = 1/(1+2*i)
             sage: F1, F2 = [g.residue_field() for g in [P1,P2]]; (F1,F2)
-            (Residue field of Fractional ideal (-i - 2), Residue field of Fractional ideal (i - 2))
+            (Residue field of Fractional ideal (-i - 2), Residue field of Fractional ideal (2*i + 1))
             sage: a.valuation(P1)
             0
             sage: F1(i/7)
@@ -3018,7 +3018,7 @@ class NumberFieldFractionalIdeal(NumberFieldIdeal):
             -1
             sage: F2(a)
             Traceback (most recent call last):
-            ZeroDivisionError: Cannot reduce field element -2/5*i + 1/5 modulo Fractional ideal (i - 2): it has negative valuation
+            ZeroDivisionError: Cannot reduce field element -2/5*i + 1/5 modulo Fractional ideal (2*i + 1): it has negative valuation
 
         An example with a relative number field::
 
@@ -3058,7 +3058,7 @@ class NumberFieldFractionalIdeal(NumberFieldIdeal):
             sage: K.<a> = NumberField(x^5 + 2); K
             Number Field in a with defining polynomial x^5 + 2
             sage: f = K.factor(19); f
-            (Fractional ideal (a^2 + a - 3)) * (Fractional ideal (-2*a^4 - a^2 + 2*a - 1)) * (Fractional ideal (-a^2 - a + 1))
+            (Fractional ideal (a^2 + a - 3)) * (Fractional ideal (-2*a^4 - a^2 + 2*a - 1)) * (Fractional ideal (a^2 + a - 1))
             sage: [i.residue_class_degree() for i, _ in f]
             [2, 2, 1]
         """
diff --git a/src/sage/rings/number_field/number_field_ideal_rel.py b/src/sage/rings/number_field/number_field_ideal_rel.py
index ba6fab5..6f50855 100644
--- a/src/sage/rings/number_field/number_field_ideal_rel.py
+++ b/src/sage/rings/number_field/number_field_ideal_rel.py
@@ -114,12 +114,12 @@ class NumberFieldFractionalIdeal_rel(NumberFieldFractionalIdeal):
             sage: K.<a, b> = NumberField([x^2 + 23, x^2 - 7])
             sage: I = K.ideal(2, (a + 2*b + 3)/2)
             sage: I.pari_rhnf()
-            [[1, -2; 0, 1], [[2, 1; 0, 1], [1/2, 0; 0, 1/2]]]
+            [[1, -2; 0, 1], [[2, 1; 0, 1], 1/2]]
         """
         try:
             return self.__pari_rhnf
         except AttributeError:
-            nfzk = self.number_field().absolute_field('a').pari_zk()
+            nfzk = self.number_field().pari_nf().nf_subst('x').nf_get_zk()
             rnf = self.number_field().pari_rnf()
             L_hnf = self.absolute_ideal().pari_hnf()
             self.__pari_rhnf = rnf.rnfidealabstorel(nfzk * L_hnf)
@@ -485,7 +485,7 @@ class NumberFieldFractionalIdeal_rel(NumberFieldFractionalIdeal):
             sage: K.<c> = F.extension(Y^2 - (1 + a)*(a + b)*a*b)
             sage: I = K.ideal(3, c)
             sage: J = I.ideal_below(); J
-            Fractional ideal (-b)
+            Fractional ideal (b)
             sage: J.number_field() == F
             True
         """
diff --git a/src/sage/rings/number_field/number_field_rel.py b/src/sage/rings/number_field/number_field_rel.py
index 3fb70f7..98435fe 100644
--- a/src/sage/rings/number_field/number_field_rel.py
+++ b/src/sage/rings/number_field/number_field_rel.py
@@ -207,7 +207,7 @@ class NumberField_relative(NumberField_generic):
             sage: b
             Traceback (most recent call last):
             ...
-            PariError: incorrect type in core2partial
+            PariError: incorrect type in core2partial (t_FRAC)
 
         However, if the polynomial is linear, rational coefficients should work::
 
@@ -1060,7 +1060,7 @@ class NumberField_relative(NumberField_generic):
         pol = element.polynomial('y')
         t2 = pol(a).lift()
         if check:
-            t1 = self.pari_rnf().rnfeltreltoabs(pol._pari_())
+            t1 = self.pari_rnf().rnfeltreltoabs(pol).lift()
             assert t1 == t2
         return t2
 
@@ -1145,7 +1145,7 @@ class NumberField_relative(NumberField_generic):
 
             sage: k.<a> = NumberField([x^3 + 2, x^2 + 2])
             sage: k._pari_base_bnf()
-            [[;], matrix(0,9), [;], ... 0]
+            [[;], matrix(0,3), [;], ...]
         """
         abs_base, from_abs_base, to_abs_base = self.absolute_base_field()
         return abs_base.pari_bnf(proof, units)
@@ -1283,10 +1283,10 @@ class NumberField_relative(NumberField_generic):
         Galois conjugate::
 
             sage: for g in G:
-            ...     if L1.is_isomorphic_relative(L2, g.as_hom()):
-            ...         print g.as_hom()
+            ....:   if L1.is_isomorphic_relative(L2, g.as_hom()):
+            ....:       print g.as_hom()
             Ring endomorphism of Number Field in z9 with defining polynomial x^6 + x^3 + 1
-              Defn: z9 |--> -z9^4 - z9
+              Defn: z9 |--> z9^4
         """
         if is_RelativeNumberField(other):
             s_base_field = self.base_field()
@@ -1575,7 +1575,7 @@ class NumberField_relative(NumberField_generic):
 
             sage: k.<a> = NumberField([x^4 + 3, x^2 + 2])
             sage: k.pari_rnf()
-            [x^4 + 3, [], [[108, 0; 0, 108], 3], [8, 0; 0, 8], [], [], [[1, x - 1, x^2 - 1, x^3 - x^2 - x - 3], ..., 0]
+            [x^4 + 3, [[364, -10*x^7 - 87*x^5 - 370*x^3 - 41*x], 1/364], [[108, 0; 0, 108], 3], ...]
         """
         return self._pari_base_nf().rnfinit(self.pari_relative_polynomial())
 
@@ -2317,7 +2317,7 @@ class NumberField_relative(NumberField_generic):
             ...
             ValueError: The element b is not in the base field
         """
-        polmodmod_xy = self.pari_rnf().rnfeltabstorel( self(element)._pari_() )
+        polmodmod_xy = self.pari_rnf().rnfeltabstorel( self(element)._pari_('x') )
         # polmodmod_xy is a POLMOD with POLMOD coefficients in general.
         # These POLMOD coefficients represent elements of the base field K.
         # We do two lifts so we get a polynomial. We need the simplify() to
diff --git a/src/sage/rings/number_field/order.py b/src/sage/rings/number_field/order.py
index 99fe015..43d2e25 100644
--- a/src/sage/rings/number_field/order.py
+++ b/src/sage/rings/number_field/order.py
@@ -245,7 +245,7 @@ class Order(IntegralDomain):
 
             sage: k.<a> = NumberField(x^2 + 5077); G = k.class_group(); G
             Class group of order 22 with structure C22 of Number Field in a with defining polynomial x^2 + 5077
-            sage: G.0
+            sage: G.0 ^ -9
             Fractional ideal class (11, a + 7)
             sage: Ok = k.maximal_order(); Ok
             Maximal Order in Number Field in a with defining polynomial x^2 + 5077
diff --git a/src/sage/rings/number_field/unit_group.py b/src/sage/rings/number_field/unit_group.py
index 6029b83..a8fcc15 100644
--- a/src/sage/rings/number_field/unit_group.py
+++ b/src/sage/rings/number_field/unit_group.py
@@ -173,18 +173,10 @@ class UnitGroup(AbelianGroupWithValues_class):
         sage: UK = K.unit_group()
         sage: UK.ngens()
         6
-        sage: UK.gen(0) # random
-        -z^11
-        sage: UK.gen(1) # random
-        z^5 + z^3
-        sage: UK.gen(2) # random
-        z^6 + z^5
-        sage: UK.gen(3) # random
-        z^9 + z^7 + z^5
-        sage: UK.gen(4) # random
-        z^9 + z^5 + z^4 + 1
-        sage: UK.gen(5) # random
-        z^5 + z
+        sage: UK.gen(5)
+        u5
+        sage: UK.gen(5).value()
+        z^6 + z^4
 
     An S-unit group::
 
@@ -195,7 +187,7 @@ class UnitGroup(AbelianGroupWithValues_class):
         sage: SUK.zeta_order()
         26
         sage: SUK.log(21*z)
-        (6, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
+        (13, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
     """
     # This structure is not a parent in the usual sense. The
     # "elements" are NumberFieldElement_absolute. Instead, they should
@@ -427,7 +419,7 @@ class UnitGroup(AbelianGroupWithValues_class):
             sage: K.<b> = NumberField(x^2+1)
             sage: U = UnitGroup(K)
             sage: zs = U.roots_of_unity(); zs
-            [-b, -1, b, 1]
+            [b, -1, -b, 1]
             sage: [ z**U.zeta_order() for z in zs ]
             [1, 1, 1, 1]
         """
@@ -493,9 +485,9 @@ class UnitGroup(AbelianGroupWithValues_class):
             sage: K.<b> = NumberField(x^2+1)
             sage: U = UnitGroup(K)
             sage: U.zeta(4)
-            -b
+            b
             sage: U.zeta(4,all=True)
-            [-b, b]
+            [b, -b]
             sage: U.zeta(3)
             Traceback (most recent call last):
             ...
@@ -599,7 +591,7 @@ class UnitGroup(AbelianGroupWithValues_class):
            sage: SUK = UnitGroup(K,S=2)
            sage: v = (3,1,4,1,5,9,2)
            sage: u = SUK.exp(v); u
-           -997204*z^11 - 2419728*z^10 - 413812*z^9 - 413812*z^8 - 2419728*z^7 - 997204*z^6 - 2129888*z^4 - 1616524*z^3 + 149364*z^2 - 1616524*z - 2129888
+           180*z^10 - 280*z^9 + 580*z^8 - 720*z^7 + 948*z^6 - 924*z^5 + 948*z^4 - 720*z^3 + 580*z^2 - 280*z + 180
            sage: SUK.log(u)
            (3, 1, 4, 1, 5, 9, 2)
            sage: SUK.log(u) == v
@@ -645,7 +637,7 @@ class UnitGroup(AbelianGroupWithValues_class):
            sage: SUK = UnitGroup(K,S=2)
            sage: v = (3,1,4,1,5,9,2)
            sage: u = SUK.exp(v); u
-           -997204*z^11 - 2419728*z^10 - 413812*z^9 - 413812*z^8 - 2419728*z^7 - 997204*z^6 - 2129888*z^4 - 1616524*z^3 + 149364*z^2 - 1616524*z - 2129888
+           180*z^10 - 280*z^9 + 580*z^8 - 720*z^7 + 948*z^6 - 924*z^5 + 948*z^4 - 720*z^3 + 580*z^2 - 280*z + 180
            sage: SUK.log(u)
            (3, 1, 4, 1, 5, 9, 2)
            sage: SUK.log(u) == v
diff --git a/src/sage/rings/polynomial/cyclotomic.pyx b/src/sage/rings/polynomial/cyclotomic.pyx
index 8c5adb8..571c9d2 100644
--- a/src/sage/rings/polynomial/cyclotomic.pyx
+++ b/src/sage/rings/polynomial/cyclotomic.pyx
@@ -247,13 +247,16 @@ def cyclotomic_value(n, x):
 
     TESTS::
 
-        sage: K.<i> = NumberField(polygen(QQ)^2 + 1)
         sage: R.<x> = QQ[]
-        sage: for y in [-1, 0, 1, 2, 1/2, mod(3, 8), GF(9,'a').gen(), Zp(3)(54), i, x^2+2]:
-        ...       for n in range(1, 61):
-        ...           val1 = cyclotomic_value(n, y)
-        ...           val2 = cyclotomic_polynomial(n)(y)
-        ...           assert val1 == val2 and val1.parent() is val2.parent()
+        sage: K.<i> = NumberField(x^2 + 1)
+        sage: for y in [-1, 0, 1, 2, 1/2, Mod(3, 8), Mod(3,11), GF(9,'a').gen(), Zp(3)(54), i, x^2+2]:
+        ....:     for n in [1..60]:
+        ....:         val1 = cyclotomic_value(n, y)
+        ....:         val2 = cyclotomic_polynomial(n)(y)
+        ....:         if val1 != val2:
+        ....:             print "Wrong value for cyclotomic_value(%s, %s) in %s"%(n,y,parent(y))
+        ....:         if val1.parent() is not val2.parent():
+        ....:             print "Wrong parent for cyclotomic_value(%s, %s) in %s"%(n,y,parent(y))
 
         sage: cyclotomic_value(20, I)
         5
@@ -275,15 +278,25 @@ def cyclotomic_value(n, x):
         1
     """
     n = int(n)
-    if n == 1:
-        return x - 1
-    if n <= 0:
-        raise ValueError, "n must be positive"
+    if n < 3:
+        if n == 1:
+            return x - 1
+        if n == 2:
+            return x + 1
+        raise ValueError("n must be positive")
+
     try:
-        return x.parent()(pari.polcyclo_eval(n, x._pari_()))
+        return x.parent()(pari.polcyclo_eval(n, x))
     except Exception:
         pass
-    # The following is modeled on the implementation in Pari
+
+    # The following is modeled on the implementation in PARI and is
+    # used for cases for which PARI doesn't work. These are in
+    # particular:
+    # - n does not fit in a C long;
+    # - x is some Sage type which cannot be converted to PARI;
+    # - PARI's algorithm encounters a zero-divisor which is not zero.
+
     factors = factor(n)
     cdef Py_ssize_t i, j, ti, L, root_of_unity = -1
     primes = [p for p, e in factors]
diff --git a/src/sage/rings/polynomial/padics/polynomial_padic.py b/src/sage/rings/polynomial/padics/polynomial_padic.py
index c8cae05..c99fe1e 100644
--- a/src/sage/rings/polynomial/padics/polynomial_padic.py
+++ b/src/sage/rings/polynomial/padics/polynomial_padic.py
@@ -86,7 +86,7 @@ class Polynomial_padic(Polynomial):
             1 (1 + O(3^3))*t + (-1 + O(3^3))
             1 (1 + O(3^3))*t^2 + (5 + O(3^3))*t + (-1 + O(3^3))
             1 (1 + O(3^3))*t^2 + (-5 + O(3^3))*t + (-1 + O(3^3))
-            1 (1 + O(3^3))*t^2 + (1 + O(3^3))
+            1 (1 + O(3^3))*t^2 + (0 + O(3^3))*t + (1 + O(3^3))
             sage: R.<t> = PolynomialRing(Qp(5,6,print_mode='terse',print_pos=False))
             sage: pol = 100 * (5*t - 1) * (t - 5)
             sage: pol
diff --git a/src/sage/rings/polynomial/polynomial_element.pyx b/src/sage/rings/polynomial/polynomial_element.pyx
index b81a919..14173df 100644
--- a/src/sage/rings/polynomial/polynomial_element.pyx
+++ b/src/sage/rings/polynomial/polynomial_element.pyx
@@ -3244,9 +3244,7 @@ cdef class Polynomial(CommutativeAlgebraElement):
             sage: K.<a> = QuadraticField(p*q)
             sage: R.<x> = PolynomialRing(K)
             sage: K.pari_polynomial('a').nffactor("x^2+1")
-            Traceback (most recent call last):
-            ...
-            PariError: precision too low in floorr (precision loss in truncation)
+            Mat([x^2 + 1, 1])
             sage: factor(x^2 + 1)
             x^2 + 1
             sage: factor( (x - a) * (x + 2*a) )
@@ -4614,7 +4612,7 @@ cdef class Polynomial(CommutativeAlgebraElement):
             sage: pari(f)
             Traceback (most recent call last):
             ...
-            PariError: variable must have higher priority in gtopoly
+            PariError: incorrect priority in gtopoly: variable x <= a
 
         Stacked polynomial rings, first with a univariate ring on the
         bottom::
diff --git a/src/sage/rings/polynomial/polynomial_quotient_ring.py b/src/sage/rings/polynomial/polynomial_quotient_ring.py
index 8d9975d..99bec5a 100644
--- a/src/sage/rings/polynomial/polynomial_quotient_ring.py
+++ b/src/sage/rings/polynomial/polynomial_quotient_ring.py
@@ -1234,11 +1234,11 @@ class PolynomialQuotientRing_generic(sage.rings.commutative_ring.CommutativeRing
             sage: L.<b> = K['y'].quotient(y^3 + 5); L
             Univariate Quotient Polynomial Ring in b over Number Field in a with defining polynomial x^2 + 3 with modulus y^3 + 5
             sage: L.S_units([])
-            [(-1/2*a + 1/2, 6), ((-1/3*a + 1)*b^2 - 4/3*a*b - 4/3*a - 3, +Infinity), (2/3*a*b^2 + (2/3*a + 2)*b - 4/3*a + 3, +Infinity)]
+            [(-1/2*a + 1/2, 6), ((1/3*a - 1)*b^2 + 4/3*a*b + 5/6*a + 7/2, +Infinity), ((-1/3*a + 1)*b^2 + (2/3*a - 2)*b - 5/6*a + 7/2, +Infinity)]
             sage: L.S_units([K.ideal(1/2*a - 3/2)])
-            [((-1/6*a - 1/2)*b^2 + (1/3*a + 1)*b - 2/3*a - 2, +Infinity), (-1/2*a + 1/2, 6), ((-1/3*a + 1)*b^2 - 4/3*a*b - 4/3*a - 3, +Infinity), (2/3*a*b^2 + (2/3*a + 2)*b - 4/3*a + 3, +Infinity)]
+            [((-1/6*a - 1/2)*b^2 + (1/3*a - 1)*b + 4/3*a, +Infinity), (-1/2*a + 1/2, 6), ((1/3*a - 1)*b^2 + 4/3*a*b + 5/6*a + 7/2, +Infinity), ((-1/3*a + 1)*b^2 + (2/3*a - 2)*b - 5/6*a + 7/2, +Infinity)]
             sage: L.S_units([K.ideal(2)])
-            [((1/6*a + 1/2)*b^2 + (-1/3*a - 1)*b + 2/3*a + 1, +Infinity), ((-1/6*a - 1/2)*b^2 + (1/3*a + 1)*b - 1/6*a - 3/2, +Infinity), ((-1/2*a + 1/2)*b^2 + (a - 1)*b - 3/2*a + 3/2, +Infinity), (-1/2*a + 1/2, 6), ((-1/3*a + 1)*b^2 - 4/3*a*b - 4/3*a - 3, +Infinity), (2/3*a*b^2 + (2/3*a + 2)*b - 4/3*a + 3, +Infinity)]
+            [((-1/2*a + 1/2)*b^2 + (-a - 1)*b - 3, +Infinity), ((-1/6*a - 1/2)*b^2 + (1/3*a - 1)*b + 5/6*a - 1/2, +Infinity), ((1/6*a + 1/2)*b^2 + (-1/3*a + 1)*b - 5/6*a - 1/2, +Infinity), (-1/2*a + 1/2, 6), ((1/3*a - 1)*b^2 + 4/3*a*b + 5/6*a + 7/2, +Infinity), ((-1/3*a + 1)*b^2 + (2/3*a - 2)*b - 5/6*a + 7/2, +Infinity)]
 
         Note that all the returned values live where we expect them to::
 
@@ -1314,14 +1314,14 @@ class PolynomialQuotientRing_generic(sage.rings.commutative_ring.CommutativeRing
             sage: L.<b> = K['y'].quotient(y^3 + 5); L
             Univariate Quotient Polynomial Ring in b over Number Field in a with defining polynomial x^2 + 3 with modulus y^3 + 5
             sage: L.units()
-            [(-1/2*a + 1/2, 6), ((-1/3*a + 1)*b^2 - 4/3*a*b - 4/3*a - 3, +Infinity), (2/3*a*b^2 + (2/3*a + 2)*b - 4/3*a + 3, +Infinity)]
+            [(-1/2*a + 1/2, 6), ((1/3*a - 1)*b^2 + 4/3*a*b + 5/6*a + 7/2, +Infinity), ((-1/3*a + 1)*b^2 + (2/3*a - 2)*b - 5/6*a + 7/2, +Infinity)]
             sage: L.<b> = K.extension(y^3 + 5)
             sage: L.unit_group()
             Unit group with structure C6 x Z x Z of Number Field in b with defining polynomial x^3 + 5 over its base field
             sage: L.unit_group().gens()    # abstract generators
             (u0, u1, u2)
             sage: L.unit_group().gens_values()
-            [-1/2*a + 1/2, (-1/3*a + 1)*b^2 - 4/3*a*b - 4/3*a - 3, 2/3*a*b^2 + (2/3*a + 2)*b - 4/3*a + 3]
+            [-1/2*a + 1/2, (1/3*a - 1)*b^2 + 4/3*a*b + 5/6*a + 7/2, (-1/3*a + 1)*b^2 + (2/3*a - 2)*b - 5/6*a + 7/2]
 
         Note that all the returned values live where we expect them to::
 
diff --git a/src/sage/rings/polynomial/polynomial_rational_flint.pyx b/src/sage/rings/polynomial/polynomial_rational_flint.pyx
index 0c13ffe..e84e148 100644
--- a/src/sage/rings/polynomial/polynomial_rational_flint.pyx
+++ b/src/sage/rings/polynomial/polynomial_rational_flint.pyx
@@ -1568,9 +1568,9 @@ cdef class Polynomial_rational_flint(Polynomial):
             sage: R.<x> = QQ[]
             sage: f = x^3 - 2
             sage: f.factor_padic(2)
-            (1 + O(2^10))*x^3 + (2 + 2^2 + 2^3 + 2^4 + 2^5 + 2^6 + 2^7 + 2^8 + 2^9 + O(2^10))
+            (1 + O(2^10))*x^3 + (O(2^10))*x^2 + (O(2^10))*x + (2 + 2^2 + 2^3 + 2^4 + 2^5 + 2^6 + 2^7 + 2^8 + 2^9 + O(2^10))
             sage: f.factor_padic(3)
-            (1 + O(3^10))*x^3 + (1 + 2*3 + 2*3^2 + 2*3^3 + 2*3^4 + 2*3^5 + 2*3^6 + 2*3^7 + 2*3^8 + 2*3^9 + O(3^10))
+            (1 + O(3^10))*x^3 + (O(3^10))*x^2 + (O(3^10))*x + (1 + 2*3 + 2*3^2 + 2*3^3 + 2*3^4 + 2*3^5 + 2*3^6 + 2*3^7 + 2*3^8 + 2*3^9 + O(3^10))
             sage: f.factor_padic(5)
             ((1 + O(5^10))*x + (2 + 4*5 + 2*5^2 + 2*5^3 + 5^4 + 3*5^5 + 4*5^7 + 2*5^8 + 5^9 + O(5^10))) * ((1 + O(5^10))*x^2 + (3 + 2*5^2 + 2*5^3 + 3*5^4 + 5^5 + 4*5^6 + 2*5^8 + 3*5^9 + O(5^10))*x + (4 + 5 + 2*5^2 + 4*5^3 + 4*5^4 + 3*5^5 + 3*5^6 + 4*5^7 + 4*5^9 + O(5^10)))
 
diff --git a/src/sage/rings/qqbar.py b/src/sage/rings/qqbar.py
index 7f5653e..1038bcb 100644
--- a/src/sage/rings/qqbar.py
+++ b/src/sage/rings/qqbar.py
@@ -1635,7 +1635,7 @@ def do_polred(poly):
         sage: do_polred(x^2 - x - 11)
         (1/3*x + 1/3, 3*x - 1, x^2 - x - 1)
         sage: do_polred(x^3 + 123456)
-        (-1/4*x, -4*x, x^3 - 1929)
+        (1/4*x, 4*x, x^3 + 1929)
 
     This shows that :trac:`13054` has been fixed::
 
@@ -1887,11 +1887,11 @@ def number_field_elements_from_algebraics(numbers, minimal=False):
     elements, and then mapping them back into ``QQbar``::
 
         sage: (fld,nums,hom) = number_field_elements_from_algebraics((rt2, rt3, qqI, z3))
-        sage: fld,nums,hom
-        (Number Field in a with defining polynomial y^8 - y^4 + 1, [-a^5 + a^3 + a, a^6 - 2*a^2, -a^6, a^4 - 1], Ring morphism:
-        From: Number Field in a with defining polynomial y^8 - y^4 + 1
-        To:   Algebraic Field
-        Defn: a |--> -0.2588190451025208? + 0.9659258262890683?*I)
+        sage: fld,nums,hom  # random
+        (Number Field in a with defining polynomial y^8 - y^4 + 1, [-a^5 + a^3 + a, a^6 - 2*a^2, a^6, -a^4], Ring morphism:
+          From: Number Field in a with defining polynomial y^8 - y^4 + 1
+          To:   Algebraic Field
+          Defn: a |--> -0.2588190451025208? - 0.9659258262890683?*I)
         sage: (nfrt2, nfrt3, nfI, nfz3) = nums
         sage: hom(nfrt2)
         1.414213562373095? + 0.?e-18*I
@@ -1904,7 +1904,8 @@ def number_field_elements_from_algebraics(numbers, minimal=False):
         sage: nfI^2
         -1
         sage: sum = nfrt2 + nfrt3 + nfI + nfz3; sum
-        -a^5 + a^4 + a^3 - 2*a^2 + a - 1
+        -a^5 + a^4 + a^3 - 2*a^2 + a - 1     # 32-bit
+        2*a^6 - a^5 - a^4 + a^3 - 2*a^2 + a  # 64-bit
         sage: hom(sum)
         2.646264369941973? + 1.866025403784439?*I
         sage: hom(sum) == rt2 + rt3 + qqI + z3
diff --git a/src/sage/rings/rational.pyx b/src/sage/rings/rational.pyx
index d4e65c8..51ca79a 100644
--- a/src/sage/rings/rational.pyx
+++ b/src/sage/rings/rational.pyx
@@ -1193,7 +1193,7 @@ cdef class Rational(sage.structure.element.FieldElement):
             sage: 0.is_norm(K)
             True
             sage: (1/7).is_norm(K, element=True)
-            (True, -1/7*beta - 3/7)
+            (True, 1/7*beta + 3/7)
             sage: (1/10).is_norm(K, element=True)
             (False, None)
             sage: (1/691).is_norm(QQ, element=True)
diff --git a/src/sage/rings/residue_field.pyx b/src/sage/rings/residue_field.pyx
index 828b638..884ff93 100644
--- a/src/sage/rings/residue_field.pyx
+++ b/src/sage/rings/residue_field.pyx
@@ -19,13 +19,13 @@ monogenic (i.e., 2 is an essential discriminant divisor)::
 
     sage: K.<a> = NumberField(x^3 + x^2 - 2*x + 8)
     sage: F = K.factor(2); F
-    (Fractional ideal (-1/2*a^2 + 1/2*a - 1)) * (Fractional ideal (-a^2 + 2*a - 3)) * (Fractional ideal (3/2*a^2 - 5/2*a + 4))
+    (Fractional ideal (1/2*a^2 - 1/2*a + 1)) * (Fractional ideal (-a^2 + 2*a - 3)) * (Fractional ideal (-3/2*a^2 + 5/2*a - 4))
     sage: F[0][0].residue_field()
-    Residue field of Fractional ideal (-1/2*a^2 + 1/2*a - 1)
+    Residue field of Fractional ideal (1/2*a^2 - 1/2*a + 1)
     sage: F[1][0].residue_field()
     Residue field of Fractional ideal (-a^2 + 2*a - 3)
     sage: F[2][0].residue_field()
-    Residue field of Fractional ideal (3/2*a^2 - 5/2*a + 4)
+    Residue field of Fractional ideal (-3/2*a^2 + 5/2*a - 4)
 
 We can also form residue fields from `\ZZ`::
 
@@ -254,9 +254,9 @@ class ResidueFieldFactory(UniqueFactory):
     the index of ``ZZ[a]`` in the maximal order for all ``a``::
 
         sage: K.<a> = NumberField(x^3 + x^2 - 2*x + 8); P = K.ideal(2).factor()[0][0]; P
-        Fractional ideal (-1/2*a^2 + 1/2*a - 1)
+        Fractional ideal (1/2*a^2 - 1/2*a + 1)
         sage: F = K.residue_field(P); F
-        Residue field of Fractional ideal (-1/2*a^2 + 1/2*a - 1)
+        Residue field of Fractional ideal (1/2*a^2 - 1/2*a + 1)
         sage: F(a)
         0
         sage: B = K.maximal_order().basis(); B
@@ -266,7 +266,7 @@ class ResidueFieldFactory(UniqueFactory):
         sage: F(B[2])
         0
         sage: F
-        Residue field of Fractional ideal (-1/2*a^2 + 1/2*a - 1)
+        Residue field of Fractional ideal (1/2*a^2 - 1/2*a + 1)
         sage: F.degree()
         1
 
@@ -692,15 +692,15 @@ class ResidueField_generic(Field):
         EXAMPLES::
 
             sage: I = QQ[3^(1/3)].factor(5)[1][0]; I
-            Fractional ideal (a - 2)
+            Fractional ideal (-a + 2)
             sage: k = I.residue_field(); k
-            Residue field of Fractional ideal (a - 2)
+            Residue field of Fractional ideal (-a + 2)
             sage: f = k.lift_map(); f
             Lifting map:
-              From: Residue field of Fractional ideal (a - 2)
+              From: Residue field of Fractional ideal (-a + 2)
               To:   Maximal Order in Number Field in a with defining polynomial x^3 - 3
             sage: f.domain()
-            Residue field of Fractional ideal (a - 2)
+            Residue field of Fractional ideal (-a + 2)
             sage: f.codomain()
             Maximal Order in Number Field in a with defining polynomial x^3 - 3
             sage: f(k.0)
@@ -728,7 +728,7 @@ class ResidueField_generic(Field):
 
             sage: K.<a> = NumberField(x^3-11)
             sage: F = K.ideal(37).factor(); F
-            (Fractional ideal (37, a + 12)) * (Fractional ideal (-2*a + 5)) * (Fractional ideal (37, a + 9))
+            (Fractional ideal (37, a + 12)) * (Fractional ideal (2*a - 5)) * (Fractional ideal (37, a + 9))
             sage: k = K.residue_field(F[0][0])
             sage: l = K.residue_field(F[1][0])
             sage: k == l
@@ -805,7 +805,7 @@ cdef class ReductionMap(Map):
             sage: F.reduction_map()
             Partially defined reduction map:
               From: Number Field in a with defining polynomial x^3 + x^2 - 2*x + 8
-              To:   Residue field of Fractional ideal (-1/2*a^2 + 1/2*a - 1)
+              To:   Residue field of Fractional ideal (1/2*a^2 - 1/2*a + 1)
 
             sage: K.<theta_5> = CyclotomicField(5)
             sage: F = K.factor(7)[0][0].residue_field()
@@ -933,10 +933,10 @@ cdef class ReductionMap(Map):
 
             sage: K.<i> = NumberField(x^2 + 1)
             sage: P1, P2 = [g[0] for g in K.factor(5)]; (P1,P2)
-            (Fractional ideal (-i - 2), Fractional ideal (i - 2))
+            (Fractional ideal (-i - 2), Fractional ideal (2*i + 1))
             sage: a = 1/(1+2*i)
             sage: F1, F2 = [g.residue_field() for g in [P1,P2]]; (F1,F2)
-            (Residue field of Fractional ideal (-i - 2), Residue field of Fractional ideal (i - 2))
+            (Residue field of Fractional ideal (-i - 2), Residue field of Fractional ideal (2*i + 1))
             sage: a.valuation(P1)
             0
             sage: F1(i/7)
@@ -948,7 +948,7 @@ cdef class ReductionMap(Map):
             sage: F2(a)
             Traceback (most recent call last):
             ...
-            ZeroDivisionError: Cannot reduce field element -2/5*i + 1/5 modulo Fractional ideal (i - 2): it has negative valuation
+            ZeroDivisionError: Cannot reduce field element -2/5*i + 1/5 modulo Fractional ideal (2*i + 1): it has negative valuation
         """
         # The reduction map is just x |--> F(to_vs(x) * (PB**(-1))) if
         # either x is integral or the denominator of x is coprime to
@@ -1012,7 +1012,7 @@ cdef class ReductionMap(Map):
             sage: f = k.convert_map_from(K)
             sage: s = f.section(); s
             Lifting map:
-              From: Residue field in abar of Fractional ideal (-14*a^4 + 24*a^3 + 26*a^2 - 58*a + 15)
+              From: Residue field in abar of Fractional ideal (14*a^4 - 24*a^3 - 26*a^2 + 58*a - 15)
               To:   Number Field in a with defining polynomial x^5 - 5*x + 2
             sage: s(k.gen())
             a
@@ -1223,7 +1223,7 @@ cdef class ResidueFieldHomomorphism_global(RingHomomorphism):
             sage: f = k.coerce_map_from(K.ring_of_integers())
             sage: s = f.section(); s
             Lifting map:
-              From: Residue field in abar of Fractional ideal (-14*a^4 + 24*a^3 + 26*a^2 - 58*a + 15)
+              From: Residue field in abar of Fractional ideal (14*a^4 - 24*a^3 - 26*a^2 + 58*a - 15)
               To:   Maximal Order in Number Field in a with defining polynomial x^5 - 5*x + 2
             sage: s(k.gen())
             a
diff --git a/src/sage/schemes/elliptic_curves/ell_generic.py b/src/sage/schemes/elliptic_curves/ell_generic.py
index 1c3b2bb..be2fd62 100644
--- a/src/sage/schemes/elliptic_curves/ell_generic.py
+++ b/src/sage/schemes/elliptic_curves/ell_generic.py
@@ -565,7 +565,7 @@ class EllipticCurve_generic(plane_curve.ProjectiveCurve_generic):
             sage: E = EllipticCurve([0,0,0,-49,0])
             sage: T = E.torsion_subgroup()
             sage: [E(t) for t in T]
-            [(0 : 1 : 0), (7 : 0 : 1), (0 : 0 : 1), (-7 : 0 : 1)]
+            [(0 : 1 : 0), (-7 : 0 : 1), (0 : 0 : 1), (7 : 0 : 1)]
 
         ::
 
@@ -2923,26 +2923,24 @@ class EllipticCurve_generic(plane_curve.ProjectiveCurve_generic):
         Over a finite field::
 
             sage: EllipticCurve(GF(41),[2,5]).pari_curve()
-            [Mod(0, 41), Mod(0, 41), Mod(0, 41), Mod(2, 41), Mod(5, 41), Mod(0, 41), Mod(4, 41), Mod(20, 41), Mod(37, 41), Mod(27, 41), Mod(26, 41), Mod(4, 41), Mod(11, 41), 0, 0, 0, 0, 0, 0]
+            [Mod(0, 41), Mod(0, 41), Mod(0, 41), Mod(2, 41), Mod(5, 41), Mod(0, 41), Mod(4, 41), Mod(20, 41), Mod(37, 41), Mod(27, 41), Mod(26, 41), Mod(4, 41), Mod(11, 41), Vecsmall([3]), [41, [9, 31, [6, 0, 0, 0]]], [0, 0, 0, 0]]
 
         Over a `p`-adic field::
 
             sage: Qp = pAdicField(5, prec=3)
             sage: E = EllipticCurve(Qp,[3, 4])
             sage: E.pari_curve()
-            [O(5^3), O(5^3), O(5^3), 3 + O(5^3), 4 + O(5^3), O(5^3), 1 + 5 + O(5^3), 1 + 3*5 + O(5^3), 1 + 3*5 + 4*5^2 + O(5^3), 1 + 5 + 4*5^2 + O(5^3), 4 + 3*5 + 5^2 + O(5^3), 2*5 + 4*5^2 + O(5^3), 3*5^-1 + O(5), [4 + 4*5 + 4*5^2 + O(5^3)], 1 + 2*5 + 4*5^2 + O(5^3), 1 + 5 + 4*5^2 + O(5^3), 2*5 + 4*5^2 + O(5^3), 3 + 3*5 + 3*5^2 + O(5^3), 0]
+            [0, 0, 0, 3, 4, 0, 6, 16, -9, -144, -3456, -8640, 1728/5, Vecsmall([2]), [O(5^3)], [0, 0]]
             sage: E.j_invariant()
             3*5^-1 + O(5)
 
-        The `j`-invariant must have negative `p`-adic valuation::
+        PARI no longer requires that the `j`-invariant has negative `p`-adic valuation::
 
             sage: E = EllipticCurve(Qp,[1, 1])
             sage: E.j_invariant() # the j-invariant is a p-adic integer
             2 + 4*5^2 + O(5^3)
             sage: E.pari_curve()
-            Traceback (most recent call last):
-            ...
-            PariError: valuation of j must be negative in p-adic ellinit
+            [0, 0, 0, 1, 1, 0, 2, 4, -1, -48, -864, -496, 6912/31, Vecsmall([2]), [O(5^3)], [0, 0]]
         """
         try:
             return self._pari_curve
@@ -2965,13 +2963,11 @@ class EllipticCurve_generic(plane_curve.ProjectiveCurve_generic):
 
             sage: E = EllipticCurve('11a1')
             sage: pari(E)
-            [0, -1, 1, -10, -20, -4, -20, -79, -21, 496, 20008, -161051, -122023936/161051, [4.34630815820539, -1.67315407910270 + 1.32084892226908*I, -1.67315407910270 - 1.32084892226908*I]~, ...]
-            sage: E.pari_curve(prec=64)
-            [0, -1, 1, -10, -20, -4, -20, -79, -21, 496, 20008, -161051, -122023936/161051, [4.34630815820539, -1.67315407910270 + 1.32084892226908*I, -1.67315407910270 - 1.32084892226908*I]~, ...]
+            [0, -1, 1, -10, -20, -4, -20, -79, -21, 496, 20008, -161051, -122023936/161051, Vecsmall([1]), [Vecsmall([64, -1])], [0, 0, 0, 0, 0, 0, 0, 0]]
 
         Over a finite field::
 
             sage: EllipticCurve(GF(2), [0,0,1,1,1])._pari_()
-            [Mod(0, 2), Mod(0, 2), Mod(1, 2), Mod(1, 2), Mod(1, 2), Mod(0, 2), Mod(0, 2), Mod(1, 2), Mod(1, 2), Mod(0, 2), Mod(0, 2), Mod(1, 2), Mod(0, 2), 0, 0, 0, 0, 0, 0]
+            [0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, Vecsmall([4]), [1, [[Vecsmall([0, 1]), Vecsmall([0, 1]), Vecsmall([0, 1])], Vecsmall([0, 1]), [Vecsmall([0, 1]), Vecsmall([0]), Vecsmall([0]), Vecsmall([0])]]], [0, 0, 0, 0]]
         """
         return self.pari_curve()
diff --git a/src/sage/schemes/elliptic_curves/ell_number_field.py b/src/sage/schemes/elliptic_curves/ell_number_field.py
index eff2c0a..c8a23be 100644
--- a/src/sage/schemes/elliptic_curves/ell_number_field.py
+++ b/src/sage/schemes/elliptic_curves/ell_number_field.py
@@ -281,8 +281,10 @@ class EllipticCurve_number_field(EllipticCurve_field):
               A = 0
               B = Mod(1, y^2 + 7)
               C = Mod(y, y^2 + 7)
+            <BLANKLINE>
               Computing L(S,2)
-              L(S,2) = [Mod(Mod(-1, y^2 + 7)*x^2 + Mod(-1/2*y + 1/2, y^2 + 7)*x + 1, x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7)), Mod(Mod(-1, y^2 + 7)*x^2 + Mod(-1/2*y - 1/2, y^2 + 7)*x + 1, x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7)), Mod(-1, x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7)), Mod(Mod(1/2*y - 1/2, y^2 + 7)*x + Mod(1/2*y - 3/2, y^2 + 7), x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7)), Mod(Mod(1, y^2 + 7)*x + Mod(1/2*y + 3/2, y^2 + 7), x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7)), Mod(Mod(-1, y^2 + 7)*x + Mod(-1/2*y + 3/2, y^2 + 7), x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7))]
+              L(S,2) = [Mod(Mod(-1, y^2 + 7)*x^2 + Mod(-1/2*y + 1/2, y^2 + 7)*x + 1, x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7)), Mod(Mod(-1, y^2 + 7)*x^2 + Mod(-1/2*y - 1/2, y^2 + 7)*x + 1, x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7)), Mod(-1, x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7)), Mod(x^2 + 2, x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7)), Mod(Mod(1, y^2 + 7)*x + Mod(1/2*y + 3/2, y^2 + 7), x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7)), Mod(Mod(1, y^2 + 7)*x + Mod(1/2*y - 3/2, y^2 + 7), x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7))]
+            <BLANKLINE>
               Computing the Selmer group
               #LS2gen = 2
                LS2gen = [Mod(Mod(-5, y^2 + 7)*x^2 + Mod(-3*y, y^2 + 7)*x + Mod(8, y^2 + 7), x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7)), Mod(Mod(1, y^2 + 7)*x^2 + Mod(1/2*y - 1/2, y^2 + 7)*x - 1, x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7))]
@@ -296,7 +298,7 @@ class EllipticCurve_number_field(EllipticCurve_field):
               zc*z1^2 = Mod(Mod(2*y - 2, y^2 + 7)*x + Mod(2*y + 10, y^2 + 7), x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7))
               quartic: (-1/2*y + 1/2)*Y^2 = x^4 + (-3*y - 15)*x^2 + (-8*y - 16)*x + (-11/2*y - 15/2)
               reduced: Y^2 = (-1/2*y + 1/2)*x^4 - 4*x^3 + (-3*y + 3)*x^2 + (2*y - 2)*x + (1/2*y + 3/2)
-              not ELS at [2, [0, 1]~, 1, 1, [1, 1]~]
+              not ELS at [2, [0, 1]~, 1, 1, [1, -2; 1, 0]]
               zc = Mod(Mod(1, y^2 + 7)*x^2 + Mod(1/2*y + 1/2, y^2 + 7)*x + Mod(-1, y^2 + 7), x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7))
               comes from the trivial point [Mod(1/2*y + 3/2, y^2 + 7), Mod(-y - 2, y^2 + 7)]
               m1 = 1
@@ -336,8 +338,7 @@ class EllipticCurve_number_field(EllipticCurve_field):
             sage: K = CyclotomicField(43).subfields(3)[0][0]
             sage: E = EllipticCurve(K, '37')
             sage: E.simon_two_descent()  # long time (4s on sage.math, 2013)
-            (3, 3, [(0 : 0 : 1), (1/2*zeta43_0^2 + 3/2*zeta43_0 - 2 : -zeta43_0^2 - 4*zeta43_0 + 3 : 1)])
-
+            (3, 3, [(0 : 0 : 1), (-1/4*zeta43_0^2 - 1/2*zeta43_0 + 3 : -3/8*zeta43_0^2 - 3/4*zeta43_0 + 4 : 1)])
         """
         verbose = int(verbose)
         if known_points is None:
@@ -380,7 +381,7 @@ class EllipticCurve_number_field(EllipticCurve_field):
         - ``map`` -- (default: ``False``) also return an embedding of
           the :meth:`base_field` into the resulting field.
 
-        - ``kwds`` -- additional keywords passed to 
+        - ``kwds`` -- additional keywords passed to
           :func:`sage.rings.number_field.splitting_field.splitting_field`.
 
         OUTPUT:
@@ -840,7 +841,7 @@ class EllipticCurve_number_field(EllipticCurve_field):
             sage: K.<v> = NumberField(x^2 + 161*x - 150)
             sage: E = EllipticCurve([25105/216*v - 3839/36, 634768555/7776*v - 98002625/1296, 634768555/7776*v - 98002625/1296, 0, 0])
             sage: E.global_integral_model()
-            Elliptic Curve defined by y^2 + (-502639783*v+465618899)*x*y + (-6603604211463489399460860*v+6117229527723443603191500)*y = x^3 + (1526887622075335620*v-1414427901517840500)*x^2 over Number Field in v with defining polynomial x^2 + 161*x - 150
+            Elliptic Curve defined by y^2 + (2094779518028859*v-1940492905300351)*x*y + (477997268472544193101178234454165304071127500*v-442791377441346852919930773849502871958097500)*y = x^3 + (26519784690047674853185542622500*v-24566525306469707225840460652500)*x^2 over Number Field in v with defining polynomial x^2 + 161*x - 150
 
         :trac:`14476`::
 
@@ -970,7 +971,7 @@ class EllipticCurve_number_field(EllipticCurve_field):
             sage: K.<i> = NumberField(x^2+1)
             sage: E = EllipticCurve([1 + i, 0, 1, 0, 0])
             sage: E.local_data()
-            [Local data at Fractional ideal (i - 2):
+            [Local data at Fractional ideal (2*i + 1):
             Reduction type: bad non-split multiplicative
             Local minimal model: Elliptic Curve defined by y^2 + (i+1)*x*y + y = x^3 over Number Field in i with defining polynomial x^2 + 1
             Minimal discriminant valuation: 1
@@ -1530,7 +1531,7 @@ class EllipticCurve_number_field(EllipticCurve_field):
             Fractional ideal (21*i - 3)
             sage: K.<a>=NumberField(x^2-x+3)
             sage: EllipticCurve([1 + a , -1 + a , 1 + a , -11 + a , 5 -9*a  ]).conductor()
-            Fractional ideal (6*a)
+            Fractional ideal (-6*a)
 
         A not so well known curve with everywhere good reduction::
 
@@ -2139,7 +2140,7 @@ class EllipticCurve_number_field(EllipticCurve_field):
             sage: E.gens(lim1=1, lim3=1)
             []
             sage: E.rank(), E.gens()  # long time (about 3 s)
-            (1, [(-369/25*y^3 + 539/25*y^2 - 1178/25*y + 1718/25 : -27193/125*y^3 + 39683/125*y^2 - 86816/125*y + 126696/125 : 1)])
+            (1, [(9/25*y^2 + 26/25 : -229/125*y^3 - 67/25*y^2 - 731/125*y - 213/25 : 1)])
 
         Here is a curve of rank 2, yet the list contains many points::
 
@@ -2315,10 +2316,10 @@ class EllipticCurve_number_field(EllipticCurve_field):
             sage: K.<i> = QuadraticField(-1)
             sage: E1 = EllipticCurve([i + 1, 0, 1, -240*i - 400, -2869*i - 2627])
             sage: E1.conductor()
-            Fractional ideal (4*i + 7)
+            Fractional ideal (-4*i - 7)
             sage: E2 = EllipticCurve([1+i,0,1,0,0])
             sage: E2.conductor()
-            Fractional ideal (4*i + 7)
+            Fractional ideal (-4*i - 7)
             sage: E1.is_isogenous(E2)  # long time (2s on sage.math, 2014)
             Traceback (most recent call last):
             ...
diff --git a/src/sage/schemes/elliptic_curves/ell_point.py b/src/sage/schemes/elliptic_curves/ell_point.py
index 78b99fa..33fc802 100644
--- a/src/sage/schemes/elliptic_curves/ell_point.py
+++ b/src/sage/schemes/elliptic_curves/ell_point.py
@@ -2266,7 +2266,7 @@ class EllipticCurvePoint_number_field(EllipticCurvePoint_field):
             sage: E.discriminant().support()
             [Fractional ideal (i + 1),
             Fractional ideal (-i - 2),
-            Fractional ideal (i - 2),
+            Fractional ideal (2*i + 1),
             Fractional ideal (3)]
             sage: [E.tamagawa_exponent(p) for p in E.discriminant().support()]
             [1, 4, 4, 4]
@@ -2651,7 +2651,7 @@ class EllipticCurvePoint_number_field(EllipticCurvePoint_field):
                 Emin = E.minimal_model()
                 iso = E.isomorphism_to(Emin)
                 P = iso(self)
-                h = Emin.pari_curve(prec=precision).ellheight(P, precision=precision)
+                h = Emin.pari_curve().ellheight(P, precision=precision)
                 height = rings.RealField(precision)(h)
             else:
                 height = (self.non_archimedean_local_height(prec=precision)
@@ -3192,7 +3192,7 @@ class EllipticCurvePoint_number_field(EllipticCurvePoint_field):
             E_work = EllipticCurve(ai)  # defined over RR
             pt_pari = pari([emb(x), emb(y)])
         working_prec = precision
-        E_pari = E_work.pari_curve(prec=working_prec)
+        E_pari = E_work.pari_curve()
         log_pari = E_pari.ellpointtoz(pt_pari, precision=working_prec)
 
         while prec_words_to_bits(log_pari.precision()) < precision:
@@ -3206,7 +3206,7 @@ class EllipticCurvePoint_number_field(EllipticCurvePoint_field):
                 ai = [emb(a) for a in E.a_invariants()]
                 E_work = EllipticCurve(ai)  # defined over RR
                 pt_pari = pari([emb(x), emb(y)])
-            E_pari = E_work.pari_curve(prec=working_prec)
+            E_pari = E_work.pari_curve()
             log_pari = E_pari.ellpointtoz(pt_pari, precision=working_prec)
 
         # normalization step
diff --git a/src/sage/schemes/elliptic_curves/ell_rational_field.py b/src/sage/schemes/elliptic_curves/ell_rational_field.py
index c831c7f..913d408 100644
--- a/src/sage/schemes/elliptic_curves/ell_rational_field.py
+++ b/src/sage/schemes/elliptic_curves/ell_rational_field.py
@@ -592,17 +592,9 @@ class EllipticCurve_rational_field(EllipticCurve_number_field):
 
         INPUT:
 
+        -  ``prec`` -- Deprecated
 
-        -  ``prec`` - The precision of quantities calculated for the
-           returned curve, in bits. If None, defaults to factor
-           multiplied by the precision of the largest cached curve (or
-           a small default precision depending on the curve if none yet
-           computed).
-
-        -  ``factor`` - The factor by which to increase the
-           precision over the maximum previously computed precision. Only used
-           if prec (which gives an explicit precision) is None.
-
+        -  ``factor`` -- Deprecated
 
         EXAMPLES::
 
@@ -618,84 +610,57 @@ class EllipticCurve_rational_field(EllipticCurve_number_field):
         ::
 
             sage: E = EllipticCurve(RationalField(), ['1/3', '2/3'])
-            sage: e = E.pari_curve(prec=100)
-            sage: 100 in E._pari_curve
-            True
-            sage: e.type()
-            't_VEC'
+            sage: e = E.pari_curve()
             sage: e[:5]
             [0, 0, 0, 1/3, 2/3]
 
-        This shows that the bug uncovered by trac:`3954` is fixed::
-
-            sage: 100 in E._pari_curve
-            True
-
-        ::
+        When doing certain computations, PARI caches the results::
 
             sage: E = EllipticCurve('37a1')
             sage: Epari = E.pari_curve()
-            sage: Epari[14].python().prec()
-            64
-            sage: [a.precision() for a in Epari]
-            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4]  # 32-bit
-            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3]  # 64-bit
-            sage: Epari = E.pari_curve(factor=2)
-            sage: Epari[14].python().prec()
-            128
+            sage: Epari
+            [0, 0, 1, -1, 0, 0, -2, 1, -1, 48, -216, 37, 110592/37, Vecsmall([1]), [Vecsmall([64, 1])], [0, 0, 0, 0, 0, 0, 0, 0]]
+            sage: Epari.omega()
+            [2.99345864623196, -2.45138938198679*I]
+            sage: Epari
+            [0, 0, 1, -1, 0, 0, -2, 1, -1, 48, -216, 37, 110592/37, Vecsmall([1]), [Vecsmall([64, 1])], [[2.99345864623196, -2.45138938198679*I], 0, [0.837565435283323, 0.269594436405445, -1.10715987168877]~, 0, 0, 0, 0, 0]]
 
-        This shows that the bug uncovered by trac`4715` is fixed::
+        This shows that the bug uncovered by :trac:`4715` is fixed::
 
             sage: Ep = EllipticCurve('903b3').pari_curve()
 
-        When the curve coefficients are large, a larger precision is
-        required (see :trac:`13163`)::
+        This still works, even When the curve coefficients are large
+        (see :trac:`13163`)::
 
             sage: E = EllipticCurve([4382696457564794691603442338788106497, 28, 3992, 16777216, 298])
-            sage: E.pari_curve(prec=64)
-            Traceback (most recent call last):
-            ...
-            PariError: precision too low in ellinit
-            sage: E.pari_curve()  # automatically choose the right precision
+            sage: E.pari_curve()
             [4382696457564794691603442338788106497, 28, 3992, 16777216, 298, ...]
             sage: E.minimal_model()
             Elliptic Curve defined by y^2 + x*y + y = x^3 + x^2 - 7686423934083797390675981169229171907674183588326184511391146727143672423167091484392497987721106542488224058921302964259990799229848935835464702*x + 8202280443553761483773108648734271851215988504820214784899752662100459663011709992446860978259617135893103951840830254045837355547141096270521198994389833928471736723050112419004202643591202131091441454709193394358885 over Rational Field
-        """
-        try:
-            # if the PARI curve has already been computed to this
-            # precision, returned the cached copy
-            return self._pari_curve[prec]
-        except AttributeError:
-            self._pari_curve = {}
-        except KeyError:
-            pass
 
-        # Double the precision if needed?
-        retry_prec = False
+        The arguments ``prec`` and ``factor`` are deprecated::
 
-        if prec is None:
-            if len(self._pari_curve) == 0:
-                # No curves computed yet
-                prec = 64
-                retry_prec = True
-            else:
-                # Take largest cached precision
-                prec = max(self._pari_curve.keys())
-                if factor == 1:
-                    return self._pari_curve[prec]
-                prec = int(prec * factor)
+            sage: E.pari_curve(prec=128)
+            doctest:...: DeprecationWarning: The prec argument to pari_curve() is deprecated and no longer used
+            See http://trac.sagemath.org/15767 for details.
+            [4382696457564794691603442338788106497, 28, 3992, 16777216, 298, ...]
+            sage: E.pari_curve(factor=2)
+            doctest:...: DeprecationWarning: The factor argument to pari_curve() is deprecated and no longer used
+            See http://trac.sagemath.org/15767 for details.
+            [4382696457564794691603442338788106497, 28, 3992, 16777216, 298, ...]
+        """
+        if prec is not None:
+            from sage.misc.superseded import deprecation
+            deprecation(15767, 'The prec argument to pari_curve() is deprecated and no longer used')
+        if factor != 1:
+            from sage.misc.superseded import deprecation
+            deprecation(15767, 'The factor argument to pari_curve() is deprecated and no longer used')
 
-        pari_invariants = pari(self.a_invariants())
-        while True:
-            try:
-                self._pari_curve[prec] = pari_invariants.ellinit(precision=prec)
-                return self._pari_curve[prec]
-            except PariError as e:
-                if retry_prec and 'precision too low' in str(e):
-                    # Retry with double precision
-                    prec *= 2
-                else:
-                    raise
+        try:
+            return self._pari_curve
+        except AttributeError:
+            self._pari_curve = pari(self.a_invariants()).ellinit()
+            return self._pari_curve
 
     def pari_mincurve(self, prec=None, factor=1):
         """
@@ -704,16 +669,9 @@ class EllipticCurve_rational_field(EllipticCurve_number_field):
 
         INPUT:
 
+        -  ``prec`` -- Deprecated
 
-        -  ``prec`` - The precision of quantities calculated for the
-           returned curve, in bits. If None, defaults to factor
-           multiplied by the precision of the largest cached curve (or
-           the default real precision if none yet computed).
-
-        -  ``factor`` - The factor by which to increase the
-           precision over the maximum previously computed precision. Only used
-           if prec (which gives an explicit precision) is None.
-
+        -  ``factor`` -- Deprecated
 
         EXAMPLES::
 
@@ -724,29 +682,21 @@ class EllipticCurve_rational_field(EllipticCurve_number_field):
             sage: E.conductor()
             47232
             sage: e.ellglobalred()
-            [47232, [1, 0, 0, 0], 2]
+            [47232, [1, 0, 0, 0], 2, [2, 7; 3, 2; 41, 1], [[7, 2, 0, 1], [2, -3, 0, 2], [1, 5, 0, 1]]]
         """
+        if prec is not None:
+            from sage.misc.superseded import deprecation
+            deprecation(15767, 'The prec argument to pari_mincurve() is deprecated and no longer used')
+        if factor != 1:
+            from sage.misc.superseded import deprecation
+            deprecation(15767, 'The factor argument to pari_mincurve() is deprecated and no longer used')
+
         try:
-            # if the PARI curve has already been computed to this
-            # precision, returned the cached copy
-            return self._pari_mincurve[prec]
+            return self._pari_mincurve
         except AttributeError:
-            # no PARI curves have been computed for this elliptic curve
-            self._pari_mincurve = {}
-        except KeyError:
-            # PARI curves are cached for this elliptic curve, but they
-            # are not of the requested precision (or prec = None)
-            if prec is None:
-                L = sorted(self._pari_mincurve.keys())
-                if factor == 1:
-                    return self._pari_mincurve[L[-1]]
-                else:
-                    prec = int(factor * L[-1])
-        e = self.pari_curve(prec)
-        mc, change = e.ellminimalmodel()
-        self._pari_mincurve[prec] = mc
-        # self.__min_transform = change
-        return mc
+            mc, change = self.pari_curve().ellminimalmodel()
+            self._pari_mincurve = mc
+            return self._pari_mincurve
 
     def database_curve(self):
         """
@@ -3705,12 +3655,12 @@ class EllipticCurve_rational_field(EllipticCurve_number_field):
             Torsion Subgroup isomorphic to Z/2 + Z/8 associated to the Elliptic
             Curve defined by y^2 = x^3 - 1386747*x + 368636886 over
             Rational Field
-            sage: G.0
+            sage: G.0*3 + G.1
             (1227 : 22680 : 1)
             sage: G.1
             (282 : 0 : 1)
             sage: list(G)
-            [(0 : 1 : 0), (1227 : 22680 : 1), (2307 : -97200 : 1), (8787 : 816480 : 1), (1011 : 0 : 1), (8787 : -816480 : 1), (2307 : 97200 : 1), (1227 : -22680 : 1), (282 : 0 : 1), (-933 : 29160 : 1), (-285 : -27216 : 1), (147 : 12960 : 1), (-1293 : 0 : 1), (147 : -12960 : 1), (-285 : 27216 : 1), (-933 : -29160 : 1)]
+            [(0 : 1 : 0), (147 : 12960 : 1), (2307 : 97200 : 1), (-933 : 29160 : 1), (1011 : 0 : 1), (-933 : -29160 : 1), (2307 : -97200 : 1), (147 : -12960 : 1), (282 : 0 : 1), (8787 : 816480 : 1), (-285 : 27216 : 1), (1227 : 22680 : 1), (-1293 : 0 : 1), (1227 : -22680 : 1), (-285 : -27216 : 1), (8787 : -816480 : 1)]
         """
         try:
             return self.__torsion_subgroup
@@ -3745,10 +3695,10 @@ class EllipticCurve_rational_field(EllipticCurve_number_field):
             sage: EllipticCurve('37b').torsion_points()
             [(0 : 1 : 0), (8 : -19 : 1), (8 : 18 : 1)]
 
-        ::
+        Some curves with large torsion groups::
 
-            sage: E=EllipticCurve([-1386747,368636886])
-            sage: T=E.torsion_subgroup(); T
+            sage: E = EllipticCurve([-1386747,368636886])
+            sage: T = E.torsion_subgroup(); T
             Torsion Subgroup isomorphic to Z/2 + Z/8 associated to the Elliptic Curve defined by y^2  = x^3 - 1386747*x + 368636886 over Rational Field
             sage: T == E.torsion_subgroup(algorithm="doud")
             True
@@ -3756,33 +3706,54 @@ class EllipticCurve_rational_field(EllipticCurve_number_field):
             True
             sage: E.torsion_points()
             [(-1293 : 0 : 1),
-            (-933 : -29160 : 1),
-            (-933 : 29160 : 1),
-            (-285 : -27216 : 1),
-            (-285 : 27216 : 1),
-            (0 : 1 : 0),
-            (147 : -12960 : 1),
-            (147 : 12960 : 1),
-            (282 : 0 : 1),
-            (1011 : 0 : 1),
-            (1227 : -22680 : 1),
-            (1227 : 22680 : 1),
-            (2307 : -97200 : 1),
-            (2307 : 97200 : 1),
-            (8787 : -816480 : 1),
-            (8787 : 816480 : 1)]
+             (-933 : -29160 : 1),
+             (-933 : 29160 : 1),
+             (-285 : -27216 : 1),
+             (-285 : 27216 : 1),
+             (0 : 1 : 0),
+             (147 : -12960 : 1),
+             (147 : 12960 : 1),
+             (282 : 0 : 1),
+             (1011 : 0 : 1),
+             (1227 : -22680 : 1),
+             (1227 : 22680 : 1),
+             (2307 : -97200 : 1),
+             (2307 : 97200 : 1),
+             (8787 : -816480 : 1),
+             (8787 : 816480 : 1)]
+            sage: EllipticCurve('210b5').torsion_points()
+            [(-41/4 : 37/8 : 1),
+             (-5 : -103 : 1),
+             (-5 : 107 : 1),
+             (0 : 1 : 0),
+             (10 : -208 : 1),
+             (10 : 197 : 1),
+             (37 : -397 : 1),
+             (37 : 359 : 1),
+             (100 : -1153 : 1),
+             (100 : 1052 : 1),
+             (415 : -8713 : 1),
+             (415 : 8297 : 1)]
+            sage: EllipticCurve('210e2').torsion_points()
+            [(-36 : 18 : 1),
+             (-26 : -122 : 1),
+             (-26 : 148 : 1),
+             (-8 : -122 : 1),
+             (-8 : 130 : 1),
+             (0 : 1 : 0),
+             (4 : -62 : 1),
+             (4 : 58 : 1),
+             (31/4 : -31/8 : 1),
+             (28 : -14 : 1),
+             (34 : -122 : 1),
+             (34 : 88 : 1),
+             (64 : -482 : 1),
+             (64 : 418 : 1),
+             (244 : -3902 : 1),
+             (244 : 3658 : 1)]
         """
         return sorted(self.torsion_subgroup(algorithm).points())
 
-    ## def newform_eval(self, z, prec):
-##         """
-##         The value of the newform attached to this elliptic curve at
-##         the point z in the complex upper half plane, computed using
-##         prec terms of the power series expansion.  Note that the power
-##         series need not converge well near the real axis.
-##         """
-##         raise NotImplementedError
-
     @cached_method
     def root_number(self, p=None):
         """
diff --git a/src/sage/schemes/elliptic_curves/ell_torsion.py b/src/sage/schemes/elliptic_curves/ell_torsion.py
index 050b7fa..6cac604 100644
--- a/src/sage/schemes/elliptic_curves/ell_torsion.py
+++ b/src/sage/schemes/elliptic_curves/ell_torsion.py
@@ -44,7 +44,7 @@ class EllipticCurveTorsionSubgroup(groups.AdditiveAbelianGroupWrapper):
         sage: G.order()
         4
         sage: G.gen(0)
-        (2 : 0 : 1)
+        (-2 : 0 : 1)
         sage: G.gen(1)
         (0 : 0 : 1)
         sage: G.ngens()
@@ -81,7 +81,7 @@ class EllipticCurveTorsionSubgroup(groups.AdditiveAbelianGroupWrapper):
         sage: E = EllipticCurve([0,0,0,-49,0])
         sage: T = E.torsion_subgroup()
         sage: [E(t) for t in T]
-        [(0 : 1 : 0), (7 : 0 : 1), (0 : 0 : 1), (-7 : 0 : 1)]
+        [(0 : 1 : 0), (-7 : 0 : 1), (0 : 0 : 1), (7 : 0 : 1)]
 
     An example where the torsion subgroup is trivial::
 
@@ -166,23 +166,15 @@ class EllipticCurveTorsionSubgroup(groups.AdditiveAbelianGroupWrapper):
         if self.__K is RationalField() and algorithm in pari_torsion_algorithms:
             flag = pari_torsion_algorithms.index(algorithm)
 
-            G = None
-            loop = 0
-            while G is None and loop < 3:
-                loop += 1
-                try:
-                    G = self.__E.pari_curve(prec = 400).elltors(flag) # pari_curve will return the curve of maximum known precision
-                except RuntimeError:
-                    self.__E.pari_curve(factor = 2) # caches a curve of twice the precision
-            if G is not None:
-                order = G[0].python()
-                structure = G[1].python()
-                gens = G[2].python()
-
-                self.__torsion_gens = [ self.__E(P) for P in gens ]
-                from sage.groups.additive_abelian.additive_abelian_group import cover_and_relations_from_invariants
-                groups.AdditiveAbelianGroupWrapper.__init__(self, self.__E(0).parent(), self.__torsion_gens, structure)
-                return
+            G = self.__E.pari_curve().elltors(flag)
+            order = G[0].python()
+            structure = G[1].python()
+            gens = G[2].python()
+
+            self.__torsion_gens = [ self.__E(P) for P in gens ]
+            from sage.groups.additive_abelian.additive_abelian_group import cover_and_relations_from_invariants
+            groups.AdditiveAbelianGroupWrapper.__init__(self, self.__E(0).parent(), self.__torsion_gens, structure)
+            return
 
         T1 = E(0) # these will be the two generators
         T2 = E(0)
diff --git a/src/sage/schemes/elliptic_curves/heegner.py b/src/sage/schemes/elliptic_curves/heegner.py
index d1a114d..5af7988 100644
--- a/src/sage/schemes/elliptic_curves/heegner.py
+++ b/src/sage/schemes/elliptic_curves/heegner.py
@@ -22,7 +22,7 @@ EXAMPLES::
     1
     sage: K.<a> = QuadraticField(-8)
     sage: K.factor(3)
-    (Fractional ideal (1/2*a + 1)) * (Fractional ideal (1/2*a - 1))
+    (Fractional ideal (1/2*a + 1)) * (Fractional ideal (-1/2*a + 1))
 
 Next try an inert prime::
 
diff --git a/src/sage/schemes/elliptic_curves/lseries_ell.py b/src/sage/schemes/elliptic_curves/lseries_ell.py
index 1f4905d..02b1358 100644
--- a/src/sage/schemes/elliptic_curves/lseries_ell.py
+++ b/src/sage/schemes/elliptic_curves/lseries_ell.py
@@ -67,8 +67,8 @@ class Lseries_ell(SageObject):
             sage: E = EllipticCurve('389a')
             sage: L = E.lseries()
             sage: L.taylor_series(series_prec=3)
-            -1.28158145675273e-23 + (7.26268290541182e-24)*z + 0.759316500288427*z^2 + O(z^3)  # 32-bit
-            -2.69129566562797e-23 + (1.52514901968783e-23)*z + 0.759316500288427*z^2 + O(z^3)  # 64-bit
+            -1.27685190980159e-23 + (7.23588070754027e-24)*z + 0.759316500288427*z^2 + O(z^3)  # 32-bit
+            -2.72911738151096e-23 + (1.54658247036311e-23)*z + 0.759316500288427*z^2 + O(z^3)  # 64-bit
             sage: L.taylor_series(series_prec=3)[2:]
             0.000000000000000 + 0.000000000000000*z + 0.759316500288427*z^2 + O(z^3)
         """
@@ -602,7 +602,7 @@ class Lseries_ell(SageObject):
             sage: E.lseries().deriv_at1()
             (-0.00010911444, 0.142428)
             sage: E.lseries().deriv_at1(4000)
-            (6.9902290...e-50, 1.31318e-43)
+            (6.990...e-50, 1.31318e-43)
         """
         sqrtN = sqrt(self.__E.conductor())
         if k:
diff --git a/src/sage/schemes/elliptic_curves/modular_parametrization.py b/src/sage/schemes/elliptic_curves/modular_parametrization.py
index 91833f8..a5ea060 100644
--- a/src/sage/schemes/elliptic_curves/modular_parametrization.py
+++ b/src/sage/schemes/elliptic_curves/modular_parametrization.py
@@ -245,9 +245,9 @@ class ModularParameterization:
 
         EXAMPLES::
 
-            sage: E=EllipticCurve('389a1')
+            sage: E = EllipticCurve('389a1')
             sage: phi = E.modular_parametrization()
-            sage: X,Y = phi.power_series(prec = 10)
+            sage: X,Y = phi.power_series(prec=10)
             sage: X
             q^-2 + 2*q^-1 + 4 + 7*q + 13*q^2 + 18*q^3 + 31*q^4 + 49*q^5 + 74*q^6 + 111*q^7 + O(q^8)
             sage: Y
@@ -264,21 +264,16 @@ class ModularParameterization:
             sage: E.defining_polynomial()(X,Y,1) + O(q^11) == 0
             True
 
-        Note that below we have to change variable from x to q::
+        Note that below we have to change variable from `x` to `q`::
 
-            sage: a1,_,a3,_,_=E.a_invariants()
-            sage: f=E.q_expansion(17)
-            sage: q=f.parent().gen()
+            sage: a1,_,a3,_,_ = E.a_invariants()
+            sage: f = E.q_expansion(17)
+            sage: q = f.parent().gen()
             sage: f/q == (X.derivative()/(2*Y+a1*X+a3))
             True
         """
         R = LaurentSeriesRing(RationalField(),'q')
         if not self._E.is_minimal():
-            raise NotImplementedError("Only implemented for minimal curves.")
-        from sage.libs.all import pari
-        old_prec = pari.get_series_precision()
-        pari.set_series_precision(prec-1)
-        XY = self._E.pari_mincurve().elltaniyama()
-        pari.set_series_precision(old_prec)
+            raise NotImplementedError("only implemented for minimal curves")
+        XY = self._E.pari_mincurve().elltaniyama(prec-1)
         return R(XY[0]),R(XY[1])
-
diff --git a/src/sage/schemes/elliptic_curves/period_lattice.py b/src/sage/schemes/elliptic_curves/period_lattice.py
index 227b32f..ef66865 100644
--- a/src/sage/schemes/elliptic_curves/period_lattice.py
+++ b/src/sage/schemes/elliptic_curves/period_lattice.py
@@ -530,12 +530,12 @@ class PeriodLattice_ell(PeriodLattice):
 
         if algorithm=='pari':
             if self.E.base_field() is QQ:
-                periods = self.E.pari_curve(prec).omega().python()
+                periods = self.E.pari_curve().omega(prec).python()
                 return (R(periods[0]), C(periods[1]))
 
             from sage.libs.pari.all import pari
-            E_pari = pari([R(self.embedding(ai).real()) for ai in self.E.a_invariants()]).ellinit(precision=prec)
-            periods = E_pari.omega().python()
+            E_pari = pari([R(self.embedding(ai).real()) for ai in self.E.a_invariants()]).ellinit()
+            periods = E_pari.omega(prec).python()
             return (R(periods[0]), C(periods[1]))
 
         if algorithm!='sage':
@@ -937,9 +937,9 @@ class PeriodLattice_ell(PeriodLattice):
         if prec is None:
             prec = RealField().precision()
         try:
-            return self.E.pari_curve(prec).ellsigma(z, flag)
+            return self.E.pari_curve().ellsigma(z, flag, precision=prec)
         except AttributeError:
-            raise NotImplementedError("sigma function not yet implemented for period lattices of curves not defined over Q.")
+            raise NotImplementedError("sigma function not yet implemented for period lattices of curves not defined over Q")
 
     def curve(self):
         r"""
diff --git a/src/sage/schemes/plane_conics/con_number_field.py b/src/sage/schemes/plane_conics/con_number_field.py
index 4ae48d8..b241d81 100644
--- a/src/sage/schemes/plane_conics/con_number_field.py
+++ b/src/sage/schemes/plane_conics/con_number_field.py
@@ -124,7 +124,7 @@ class ProjectiveConic_number_field(ProjectiveConic_field):
             sage: C.has_rational_point(algorithm = 'local', read_cache = False)
             True
 
-        Examples over number fields ::
+        Examples over number fields::
 
             sage: K.<i> = QuadraticField(-1)
             sage: C = Conic(K, [1, 3, -5])
diff --git a/src/sage/symbolic/constants.py b/src/sage/symbolic/constants.py
index 6f76834..a91c008 100644
--- a/src/sage/symbolic/constants.py
+++ b/src/sage/symbolic/constants.py
@@ -851,7 +851,7 @@ class Log2(Constant):
         .6931471805599453
         sage: gp(log2)
         0.6931471805599453094172321215             # 32-bit
-        0.69314718055994530941723212145817656808   # 64-bit
+        0.69314718055994530941723212145817656807   # 64-bit
         sage: RealField(150)(2).log()
         0.69314718055994530941723212145817656807550013
     """
diff --git a/src/sage/symbolic/integration/integral.py b/src/sage/symbolic/integration/integral.py
index d092529..901acf0 100644
--- a/src/sage/symbolic/integration/integral.py
+++ b/src/sage/symbolic/integration/integral.py
@@ -677,7 +677,7 @@ def integrate(expression, v=None, a=None, b=None, algorithm=None):
     Check that :trac:`11737` is fixed::
 
         sage: N(integrate(sin(x^2)/(x^2), x, 1, infinity))
-        0.285736646322858
+        0.285736646322853
 
     """
     expression, v, a, b = _normalize_integral_input(expression, v, a, b)
diff --git a/src/sage/tests/parigp.py b/src/sage/tests/parigp.py
index e58d427..6077db3 100644
--- a/src/sage/tests/parigp.py
+++ b/src/sage/tests/parigp.py
@@ -6,7 +6,7 @@ Check that :trac:`9876` has been fixed, this test comes from PARI's
 self-test "rnfkummer"::
 
     sage: pari('setrand(1); lift(rnfkummer(bnrinit(bnfinit(y^4-52*y^2+26,1),3,1),Mat(5)))')  # long time (4s on sage.math, 2011)
-    x^5 + (-12490585381661544359255403301035053110061910*y^3 + 8875378520404561472503422910872004290197460*y^2 + 643203912732761873050292808675549433737179610*y - 457038484130159980782436350930533714409061170)*x^3 + (-134027514281645340620300162483056350640850689292892267066826165512*y^3 + 95235243030030469814112992330493778292557062830362488860799262053*y^2 + 6901759924725033375901003506523314713919218011682438894990413482822*y - 4904148131739972327284545793455166015180538153351582525198684659988)*x^2 + (-47397957557570888155708856849994683849365520972511563824369572802678417823703951003630*y^3 + 33679323468496441220407209890566679520252152888549909181980050360738580514765560899830*y^2 + 2440762448949326006691055037485233408803108189791110990339027554592708168372793653934980*y - 1734320048033240933678067521047553381449799255523887315704756124974424249211251806055445)*x + (88847913213212543643724914281374137431466584547137800780754135469698376356168903046151157223082894732483818/5*y^3 - 63132205749445286461822170095386361952302057584137825393349862937480952856334509099209369622841067534904427/5*y^2 - 4575231959624371057665356018310756876851369587901000773265750996233180145132238920504044583057371848969400608/5*y + 3250999094748458040342075570309205473235256099747294466325048378505864671503910959921397017511503388596960342/5)
+    x^5 + (677308732982301944730030845266716201702837696162187325328/5*y^3 + 481271319660811460139352501916644558975058261230836596652/5*y^2 - 34878079733048511269299413306183851642254427026365686673888/5*y - 24783137893632185532697291886880720222932490781434136563942/5)*x^3 + (3121825424585613564828729670704559492032765858876683224121119983801219547643890505070*y^3 + 2218259473949490736667831079912338956828105689590705243343986337391928943383709808005*y^2 - 160758704836112475349193472119432636971334139776148581364333958289434482806877560648970*y - 114229487928172801039731551289054638597376141715926648946031483976252167029243247022480)*x^2 + (-166692999053535356002572927874917139211874871730209960830468398970597547702137238176414705764356470658863661934844/5*y^3 - 118446188915971905087412803032726595730394344242831753676734791550346393669679117451359918013807557809143042588696/5*y^2 + 8583872250159852857479162156889677342550132950704205078118190632176525884150800135006242479797595396229858998666474/5*y + 6099398054781102460046012340322433264871600802691098946100231203424708988718659688581036467351459717869466864403491/5)*x + (-3761942859516698460017771578887550299728643548425212623644925442305118051299870709569967640457662697840860989973276516003636843449764721490044/5*y^3 - 2673104432455463952284352656647109245231103663592899118247897745294025980581570350460813923435311458682114748384710825808171997155877533243621/5*y^2 + 193721614595917576607166927238849546114076202473503220710707213556396586084964322202670927424345172110316287310450443586757567876756951302594424/5*y + 137651773558650909762864388498297831958827163349141150095186154867116600261791580542516653158613689676015829782898702530873665348851222173825666/5)
 
 Check that :trac:`10195` (PARI bug 1153) has been fixed::
 
@@ -48,7 +48,7 @@ Check that the optional PARI databases work::
     [x^212 + (-y^7 + 5207*y^6 - 10241606*y^5 + 9430560101*y^4 - 4074860204015*y^3 + 718868274900397*y^2 - 34897101275826114*y + 104096378056356968)*x^211...
 
 The following requires the modular polynomials up to degree 223, while
-only those up to degree 199 come standard in Sage:
+only those up to degree 199 come standard in Sage::
 
     sage: p = next_prime(2^328)
     sage: E = EllipticCurve(GF(p), [6,1])
@@ -56,7 +56,7 @@ only those up to degree 199 come standard in Sage:
     546812681195752981093125556779405341338292357723293496548601032930284335897180749997402596957976244
 
 Create a number field with Galois group `A4`. Group `A4` corresponds to
-transitive group `(12,3)` in GAP.
+transitive group `(12,3)` in GAP::
 
     sage: R.<x> = PolynomialRing(ZZ)
     sage: pol = pari("galoisgetpol(12,3)[1]")  # optional -- database_pari
--
cgit v0.9.2
